//! Causal Discovery Agent tool definitions.
//!
//! Provides MCP tools for triggering and managing the causal discovery agent
//! that uses a local LLM (Qwen2.5) to identify cause-effect relationships
//! in existing memories and activate E5 embeddings.
//!
//! # Tools
//!
//! - `trigger_causal_discovery` - Manually trigger causal analysis
//! - `get_causal_discovery_status` - Check agent status and statistics
//!
//! # Constitution Compliance
//!
//! - ARCH-15: E5 uses asymmetric similarity with separate cause/effect encodings
//! - AP-77: Direction modifiers (cause→effect=1.2, effect→cause=0.8)
//! - E5 embeddings generated by real CausalModel inference

use crate::tools::types::ToolDefinition;
use serde_json::json;

/// Returns causal discovery tool definitions.
/// Without `llm` feature: 0 tools (causal discovery requires LLM).
/// With `llm` feature: 2 tools (trigger_causal_discovery, get_causal_discovery_status).
pub fn definitions() -> Vec<ToolDefinition> {
    #[cfg(not(feature = "llm"))]
    {
        return Vec::new();
    }
    #[cfg(feature = "llm")]
    vec![
        // trigger_causal_discovery - Manual trigger for causal analysis
        ToolDefinition::new(
            "trigger_causal_discovery",
            "Manually trigger the causal discovery agent to analyze memories for cause-effect relationships. \
             Uses Qwen2.5 via Candle with native CUDA for RTX 5090 Blackwell optimization. \
             FP16 tensor cores for inference, INT8 for larger models. \
             Confirmed relationships are embedded using CausalModel.embed_dual() for asymmetric E5 vectors. \
             VRAM usage: 3B=~6GB FP16, 7B=~14GB FP16. Use after bulk memory imports or for immediate causal analysis.",
            json!({
                "type": "object",
                "properties": {
                    "maxPairs": {
                        "type": "integer",
                        "description": "Maximum candidate pairs to analyze per run (1-200, default: 50). More pairs = longer runtime.",
                        "default": 50,
                        "minimum": 1,
                        "maximum": 200
                    },
                    "minConfidence": {
                        "type": "number",
                        "description": "Minimum LLM confidence to accept a causal relationship (0.5-1.0, default: 0.7). Higher = fewer but more confident relationships.",
                        "default": 0.7,
                        "minimum": 0.5,
                        "maximum": 1.0
                    },
                    "sessionScope": {
                        "type": "string",
                        "enum": ["current", "all", "recent"],
                        "description": "Scope of indexed files to analyze: 'current' (last 10 indexed files), 'recent' (last 50 indexed files), 'all' (all indexed files). MCP-5 FIX: Causal discovery is file-based, not session-scoped. Default: 'all'.",
                        "default": "all"
                    },
                    "similarityThreshold": {
                        "type": "number",
                        "description": "Minimum E1 similarity for candidate pairs (0.3-0.9, default: 0.5). Pairs below this are skipped.",
                        "default": 0.5,
                        "minimum": 0.3,
                        "maximum": 0.9
                    },
                    "skipAnalyzed": {
                        "type": "boolean",
                        "description": "Skip pairs already analyzed in previous runs (default: true).",
                        "default": true
                    },
                    "dryRun": {
                        "type": "boolean",
                        "description": "If true, only find candidates and analyze with LLM, but don't create embeddings or graph edges. Useful for testing.",
                        "default": false
                    }
                },
                "additionalProperties": false
            }),
        ),
        // get_causal_discovery_status - Check agent status
        ToolDefinition::new(
            "get_causal_discovery_status",
            "Get the status and statistics of the causal discovery agent. \
             Shows whether the agent is running, last cycle results, VRAM usage, \
             and cumulative statistics (pairs analyzed, relationships found, etc.).",
            json!({
                "type": "object",
                "properties": {
                    "includeLastResult": {
                        "type": "boolean",
                        "description": "Include detailed results from the last discovery cycle (default: true).",
                        "default": true
                    },
                    "includeGraphStats": {
                        "type": "boolean",
                        "description": "Include causal graph statistics (node count, edge count, etc.). Default: true.",
                        "default": true
                    }
                },
                "additionalProperties": false
            }),
        ),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_causal_discovery_tool_count() {
        #[cfg(feature = "llm")]
        assert_eq!(definitions().len(), 2);
        #[cfg(not(feature = "llm"))]
        assert_eq!(definitions().len(), 0);
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_trigger_causal_discovery_schema() {
        let tools = definitions();
        let trigger = tools
            .iter()
            .find(|t| t.name == "trigger_causal_discovery")
            .unwrap();

        // Should have no required fields (all optional)
        let has_required = trigger.input_schema.get("required").is_some();
        assert!(
            !has_required
                || trigger
                    .input_schema
                    .get("required")
                    .unwrap()
                    .as_array()
                    .unwrap()
                    .is_empty()
        );

        // Check properties
        let props = trigger
            .input_schema
            .get("properties")
            .unwrap()
            .as_object()
            .unwrap();

        assert!(props.contains_key("maxPairs"));
        assert!(props.contains_key("minConfidence"));
        assert!(props.contains_key("sessionScope"));
        assert!(props.contains_key("similarityThreshold"));
        assert!(props.contains_key("skipAnalyzed"));
        assert!(props.contains_key("dryRun"));
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_trigger_defaults() {
        let tools = definitions();
        let trigger = tools
            .iter()
            .find(|t| t.name == "trigger_causal_discovery")
            .unwrap();

        let props = trigger
            .input_schema
            .get("properties")
            .unwrap()
            .as_object()
            .unwrap();

        assert_eq!(props["maxPairs"]["default"], 50);
        assert_eq!(props["minConfidence"]["default"], 0.7);
        assert_eq!(props["sessionScope"]["default"], "all");
        assert_eq!(props["similarityThreshold"]["default"], 0.5);
        assert_eq!(props["skipAnalyzed"]["default"], true);
        assert_eq!(props["dryRun"]["default"], false);
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_session_scope_enum() {
        let tools = definitions();
        let trigger = tools
            .iter()
            .find(|t| t.name == "trigger_causal_discovery")
            .unwrap();

        let props = trigger
            .input_schema
            .get("properties")
            .unwrap()
            .as_object()
            .unwrap();

        let scope_enum = props["sessionScope"]["enum"].as_array().unwrap();
        assert!(scope_enum.contains(&json!("current")));
        assert!(scope_enum.contains(&json!("all")));
        assert!(scope_enum.contains(&json!("recent")));
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_status_schema() {
        let tools = definitions();
        let status = tools
            .iter()
            .find(|t| t.name == "get_causal_discovery_status")
            .unwrap();

        let props = status
            .input_schema
            .get("properties")
            .unwrap()
            .as_object()
            .unwrap();

        assert!(props.contains_key("includeLastResult"));
        assert!(props.contains_key("includeGraphStats"));
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_trigger_mentions_llm() {
        let tools = definitions();
        let trigger = tools
            .iter()
            .find(|t| t.name == "trigger_causal_discovery")
            .unwrap();

        assert!(
            trigger.description.contains("LLM") || trigger.description.contains("Qwen"),
            "trigger_causal_discovery should mention the LLM"
        );
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_trigger_mentions_vram() {
        let tools = definitions();
        let trigger = tools
            .iter()
            .find(|t| t.name == "trigger_causal_discovery")
            .unwrap();

        assert!(
            trigger.description.contains("VRAM") || trigger.description.contains("FP16"),
            "trigger_causal_discovery should mention VRAM requirements"
        );
    }

    #[cfg(feature = "llm")]
    #[test]
    fn test_trigger_mentions_e5() {
        let tools = definitions();
        let trigger = tools
            .iter()
            .find(|t| t.name == "trigger_causal_discovery")
            .unwrap();

        assert!(
            trigger.description.contains("E5") || trigger.description.contains("CausalModel"),
            "trigger_causal_discovery should mention E5 embeddings"
        );
    }
}
