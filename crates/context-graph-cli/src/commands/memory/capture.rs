//! Memory capture-memory and capture-response command implementations.
//!
//! - `capture-memory`: Capture hook descriptions from PostToolUse/SessionEnd hooks
//! - `capture-response`: Capture Claude responses from Stop hook
//!
//! # Task 14: Connect CLI to MCP Server
//!
//! This module uses the MCP client to connect to the running MCP server
//! for memory storage operations. This eliminates the StubMultiArrayProvider
//! and ensures all embeddings are generated by the MCP server's warm-loaded
//! GPU models.
//!
//! # Constitution Compliance
//!
//! - ARCH-01: TeleologicalArray is atomic (MCP server handles all 13 embeddings)
//! - ARCH-06: All memory ops through MCP tools
//! - ARCH-08: CUDA GPU required (MCP server uses GPU, not CLI)
//! - ARCH-11: Memory sources: HookDescription, ClaudeResponse
//! - AP-06: No direct DB access - MCP tools only
//! - AP-11: Check existing utils before creating helpers (uses mcp_helpers)
//! - AP-14: No .unwrap() in library code
//! - AP-26: Exit code 0=success, 1=error, 2=corruption

use clap::Args;
use tracing::{debug, error, info};

use context_graph_core::memory::{HookType, ResponseType};

use crate::error::CliExitCode;
use crate::mcp_client::McpClient;
use crate::mcp_helpers::{mcp_error_to_exit_code, require_mcp_server, resolve_session_id};

// =============================================================================
// Constants (AP-12: No magic numbers)
// =============================================================================

/// Maximum content length per constitution MAX_CONTENT_LENGTH.
const MAX_CONTENT_LENGTH: usize = 10_000;

// =============================================================================
// Argument Structs
// =============================================================================

/// Arguments for capture-memory command.
///
/// Captures hook descriptions and stores them via MCP server.
/// Used by PostToolUse and SessionEnd hooks.
///
/// # Environment Variables
///
/// - `TOOL_DESCRIPTION`: Primary content source
/// - `SESSION_SUMMARY`: Fallback content source
/// - `CLAUDE_SESSION_ID`: Session identifier
/// - `CONTEXT_GRAPH_MCP_HOST`: MCP server host (default: 127.0.0.1)
/// - `CONTEXT_GRAPH_MCP_PORT`: MCP server port (default: 3100)
#[derive(Args)]
pub struct CaptureMemoryArgs {
    /// Content to capture (or use TOOL_DESCRIPTION/SESSION_SUMMARY env var)
    #[arg(long)]
    pub content: Option<String>,

    /// Memory source type: "hook" (default) - always HookDescription
    #[arg(long, default_value = "hook")]
    pub source: String,

    /// Session ID (or use CLAUDE_SESSION_ID env var)
    #[arg(long)]
    pub session_id: Option<String>,

    /// Hook type: session_start, user_prompt_submit, pre_tool_use, post_tool_use, stop, session_end
    #[arg(long)]
    pub hook_type: Option<String>,

    /// Tool name for PreToolUse/PostToolUse hooks
    #[arg(long)]
    pub tool_name: Option<String>,

    /// Importance score [0.0, 1.0] (default: 0.5)
    #[arg(long, default_value = "0.5")]
    pub importance: f64,
}

/// Arguments for capture-response command.
///
/// Captures Claude responses and stores them via MCP server.
/// Used by Stop hook.
///
/// # Environment Variables
///
/// - `RESPONSE_SUMMARY`: Content source
/// - `CLAUDE_SESSION_ID`: Session identifier
/// - `CONTEXT_GRAPH_MCP_HOST`: MCP server host (default: 127.0.0.1)
/// - `CONTEXT_GRAPH_MCP_PORT`: MCP server port (default: 3100)
#[derive(Args)]
pub struct CaptureResponseArgs {
    /// Response content to capture (or use RESPONSE_SUMMARY env var)
    #[arg(long)]
    pub content: Option<String>,

    /// Session ID (or use CLAUDE_SESSION_ID env var)
    #[arg(long)]
    pub session_id: Option<String>,

    /// Response type: session_summary, stop_response (default), significant_response
    #[arg(long, default_value = "stop_response")]
    pub response_type: String,

    /// Importance score [0.0, 1.0] (default: 0.5)
    #[arg(long, default_value = "0.5")]
    pub importance: f64,
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Resolve content from argument or environment variables.
///
/// Priority: CLI arg > primary_env > fallback_env
fn resolve_content(
    arg: Option<String>,
    primary_env: &str,
    fallback_env: Option<&str>,
) -> Option<String> {
    arg.or_else(|| std::env::var(primary_env).ok())
        .or_else(|| fallback_env.and_then(|env| std::env::var(env).ok()))
        .filter(|c| !c.trim().is_empty())
}

/// Parse hook type string to HookType enum.
///
/// Accepts snake_case strings matching constitution hook types.
fn parse_hook_type(hook_type_str: &str) -> Result<HookType, String> {
    match hook_type_str.to_lowercase().as_str() {
        "session_start" | "sessionstart" => Ok(HookType::SessionStart),
        "user_prompt_submit" | "userpromptsubmit" => Ok(HookType::UserPromptSubmit),
        "pre_tool_use" | "pretooluse" => Ok(HookType::PreToolUse),
        "post_tool_use" | "posttooluse" => Ok(HookType::PostToolUse),
        "stop" => Ok(HookType::Stop),
        "session_end" | "sessionend" => Ok(HookType::SessionEnd),
        other => Err(format!(
            "Invalid hook_type '{}'. Valid values: session_start, user_prompt_submit, pre_tool_use, post_tool_use, stop, session_end",
            other
        )),
    }
}

/// Parse response type string to ResponseType enum.
fn parse_response_type(response_type_str: &str) -> Result<ResponseType, String> {
    match response_type_str.to_lowercase().as_str() {
        "session_summary" | "sessionsummary" => Ok(ResponseType::SessionSummary),
        "stop_response" | "stopresponse" => Ok(ResponseType::StopResponse),
        "significant_response" | "significantresponse" => Ok(ResponseType::SignificantResponse),
        other => Err(format!(
            "Invalid response_type '{}'. Valid values: session_summary, stop_response, significant_response",
            other
        )),
    }
}

/// Validate content length and return error exit code if exceeded.
fn validate_content_length(content: &str) -> Result<(), i32> {
    if content.len() > MAX_CONTENT_LENGTH {
        error!(
            content_len = content.len(),
            max = MAX_CONTENT_LENGTH,
            "Content exceeds maximum length"
        );
        eprintln!(
            "ERROR: Content length {} exceeds maximum {} characters",
            content.len(),
            MAX_CONTENT_LENGTH
        );
        return Err(CliExitCode::Warning as i32);
    }
    Ok(())
}

// =============================================================================
// Command Handlers
// =============================================================================

/// Handle capture-memory command.
///
/// Captures hook descriptions and stores them via MCP server using warm-loaded
/// GPU models for embedding generation.
///
/// Silent on success (exit 0), outputs nothing to stdout.
///
/// # Exit Codes (AP-26)
/// - 0: Success (including empty content - silent ignore)
/// - 1: Error (MCP server not running, timeout, or tool failure)
/// - 2: Corruption (storage corruption detected by MCP)
pub async fn handle_capture_memory(args: CaptureMemoryArgs) -> i32 {
    // Resolve content from arg or environment variables
    let content = resolve_content(args.content, "TOOL_DESCRIPTION", Some("SESSION_SUMMARY"));

    // Empty content = silent success (exit 0)
    let Some(content) = content else {
        debug!("No content to capture, returning success");
        return CliExitCode::Success as i32;
    };

    // Validate content length
    if let Err(exit_code) = validate_content_length(&content) {
        return exit_code;
    }

    // Resolve session ID
    let session_id = resolve_session_id(args.session_id);

    // Parse hook type (default to PostToolUse if not specified)
    let hook_type = match args.hook_type {
        Some(ht) => match parse_hook_type(&ht) {
            Ok(h) => h,
            Err(e) => {
                error!(error = %e, "Invalid hook_type argument");
                eprintln!("ERROR: {}", e);
                return CliExitCode::Warning as i32;
            }
        },
        None => {
            debug!("No hook_type specified, defaulting to PostToolUse");
            HookType::PostToolUse
        }
    };

    info!(
        content_len = content.len(),
        session_id = %session_id,
        hook_type = %hook_type,
        tool_name = ?args.tool_name,
        importance = args.importance,
        "Capturing hook description via MCP"
    );

    // Create MCP client and verify server is running
    let client = McpClient::new();
    if let Err(exit_code) = require_mcp_server(&client).await {
        return exit_code;
    }

    // Build tags for metadata
    let mut tags = vec![
        "HookDescription".to_string(),
        format!("hook_type:{}", hook_type),
        format!("session_id:{}", session_id),
    ];
    if let Some(tool_name) = &args.tool_name {
        tags.push(format!("tool_name:{}", tool_name));
    }

    // Call MCP store_memory
    // SESSION-ID-FIX: Pass session_id for proper session-scoped storage
    match client
        .store_memory(&content, args.importance, "text", Some(tags), Some(&session_id))
        .await
    {
        Ok(result) => {
            if let Some(id) = result.get("id").and_then(|v| v.as_str()) {
                info!(memory_id = %id, session_id = %session_id, "Memory captured successfully via MCP");
            } else {
                info!(session_id = %session_id, "Memory captured successfully via MCP");
            }
            CliExitCode::Success as i32
        }
        Err(e) => {
            eprintln!("ERROR: Failed to store memory via MCP: {}", e);
            mcp_error_to_exit_code(&e)
        }
    }
}

/// Handle capture-response command.
///
/// Captures Claude responses and stores them via MCP server using warm-loaded
/// GPU models for embedding generation.
///
/// Silent on success (exit 0), outputs nothing to stdout.
///
/// # Exit Codes (AP-26)
/// - 0: Success (including empty content - silent ignore)
/// - 1: Error (MCP server not running, timeout, or tool failure)
/// - 2: Corruption (storage corruption detected by MCP)
pub async fn handle_capture_response(args: CaptureResponseArgs) -> i32 {
    // Resolve content from arg or environment variable
    let content = resolve_content(args.content, "RESPONSE_SUMMARY", None);

    // Empty content = silent success (exit 0)
    let Some(content) = content else {
        debug!("No content to capture, returning success");
        return CliExitCode::Success as i32;
    };

    // Validate content length
    if let Err(exit_code) = validate_content_length(&content) {
        return exit_code;
    }

    // Resolve session ID
    let session_id = resolve_session_id(args.session_id);

    // Parse response type
    let response_type = match parse_response_type(&args.response_type) {
        Ok(r) => r,
        Err(e) => {
            error!(error = %e, "Invalid response_type argument");
            eprintln!("ERROR: {}", e);
            return CliExitCode::Warning as i32;
        }
    };

    info!(
        content_len = content.len(),
        session_id = %session_id,
        response_type = %response_type,
        importance = args.importance,
        "Capturing Claude response via MCP"
    );

    // Create MCP client and verify server is running
    let client = McpClient::new();
    if let Err(exit_code) = require_mcp_server(&client).await {
        return exit_code;
    }

    // Build tags for metadata
    let tags = vec![
        "ClaudeResponse".to_string(),
        format!("response_type:{}", response_type),
        format!("session_id:{}", session_id),
    ];

    // Call MCP store_memory
    // SESSION-ID-FIX: Pass session_id for proper session-scoped storage
    match client
        .store_memory(&content, args.importance, "text", Some(tags), Some(&session_id))
        .await
    {
        Ok(result) => {
            if let Some(id) = result.get("id").and_then(|v| v.as_str()) {
                info!(memory_id = %id, session_id = %session_id, "Response captured successfully via MCP");
            } else {
                info!(session_id = %session_id, "Response captured successfully via MCP");
            }
            CliExitCode::Success as i32
        }
        Err(e) => {
            eprintln!("ERROR: Failed to store response via MCP: {}", e);
            mcp_error_to_exit_code(&e)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::commands::test_utils::GLOBAL_IDENTITY_LOCK;
    use crate::mcp_client::McpClientError;

    // =========================================================================
    // Hook Type Parsing Tests
    // =========================================================================

    #[test]
    fn test_parse_hook_type_all_variants() {
        let test_cases = [
            ("session_start", HookType::SessionStart),
            ("sessionstart", HookType::SessionStart),
            ("user_prompt_submit", HookType::UserPromptSubmit),
            ("userpromptsubmit", HookType::UserPromptSubmit),
            ("pre_tool_use", HookType::PreToolUse),
            ("pretooluse", HookType::PreToolUse),
            ("post_tool_use", HookType::PostToolUse),
            ("posttooluse", HookType::PostToolUse),
            ("stop", HookType::Stop),
            ("session_end", HookType::SessionEnd),
            ("sessionend", HookType::SessionEnd),
        ];

        for (input, expected) in test_cases {
            let result = parse_hook_type(input);
            assert!(result.is_ok(), "Failed to parse '{}': {:?}", input, result);
            assert_eq!(
                result.expect("result"),
                expected,
                "Mismatch for '{}'",
                input
            );
        }
    }

    #[test]
    fn test_parse_hook_type_case_insensitive() {
        let test_cases = ["SESSION_START", "Session_Start", "STOP", "Stop"];

        for input in test_cases {
            let result = parse_hook_type(input);
            assert!(
                result.is_ok(),
                "Failed to parse uppercase '{}': {:?}",
                input,
                result
            );
        }
    }

    #[test]
    fn test_parse_hook_type_invalid() {
        let invalid = ["invalid", "foo", "pre-tool-use", "SESSION START", ""];
        for input in invalid {
            let result = parse_hook_type(input);
            assert!(result.is_err(), "Should fail for '{}'", input);
            let err = result.expect_err("error");
            assert!(
                err.contains("Invalid hook_type"),
                "Error message should contain 'Invalid hook_type': {}",
                err
            );
        }
    }

    // =========================================================================
    // Response Type Parsing Tests
    // =========================================================================

    #[test]
    fn test_parse_response_type_all_variants() {
        let test_cases = [
            ("session_summary", ResponseType::SessionSummary),
            ("sessionsummary", ResponseType::SessionSummary),
            ("stop_response", ResponseType::StopResponse),
            ("stopresponse", ResponseType::StopResponse),
            ("significant_response", ResponseType::SignificantResponse),
            ("significantresponse", ResponseType::SignificantResponse),
        ];

        for (input, expected) in test_cases {
            let result = parse_response_type(input);
            assert!(result.is_ok(), "Failed to parse '{}': {:?}", input, result);
            assert_eq!(
                result.expect("result"),
                expected,
                "Mismatch for '{}'",
                input
            );
        }
    }

    #[test]
    fn test_parse_response_type_invalid() {
        let invalid = ["invalid", "foo", "stop-response", ""];
        for input in invalid {
            let result = parse_response_type(input);
            assert!(result.is_err(), "Should fail for '{}'", input);
        }
    }

    // =========================================================================
    // Content Resolution Tests
    // =========================================================================

    #[test]
    fn test_resolve_content_from_arg() {
        let content = resolve_content(Some("arg content".to_string()), "NOT_SET_ENV", None);
        assert_eq!(content, Some("arg content".to_string()));
    }

    #[test]
    fn test_resolve_content_from_primary_env() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();
        std::env::set_var("TEST_PRIMARY_ENV", "primary env content");

        let content = resolve_content(None, "TEST_PRIMARY_ENV", None);
        assert_eq!(content, Some("primary env content".to_string()));

        std::env::remove_var("TEST_PRIMARY_ENV");
    }

    #[test]
    fn test_resolve_content_from_fallback_env() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();
        std::env::remove_var("TEST_PRIMARY_ENV_2");
        std::env::set_var("TEST_FALLBACK_ENV", "fallback env content");

        let content = resolve_content(None, "TEST_PRIMARY_ENV_2", Some("TEST_FALLBACK_ENV"));
        assert_eq!(content, Some("fallback env content".to_string()));

        std::env::remove_var("TEST_FALLBACK_ENV");
    }

    #[test]
    fn test_resolve_content_whitespace_only_is_none() {
        let content = resolve_content(Some("   \n\t  ".to_string()), "NOT_SET", None);
        assert!(content.is_none());
    }

    #[test]
    fn test_resolve_content_none_when_all_empty() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();
        std::env::remove_var("TEST_NOT_SET_1");
        std::env::remove_var("TEST_NOT_SET_2");

        let content = resolve_content(None, "TEST_NOT_SET_1", Some("TEST_NOT_SET_2"));
        assert!(content.is_none());
    }

    // =========================================================================
    // Exit Code Tests
    // =========================================================================

    #[test]
    fn test_exit_code_values() {
        assert_eq!(CliExitCode::Success as i32, 0, "Success must be 0");
        assert_eq!(CliExitCode::Warning as i32, 1, "Warning must be 1");
        assert_eq!(CliExitCode::Blocking as i32, 2, "Blocking must be 2");
    }

    #[test]
    fn test_mcp_error_to_exit_code() {
        // Test server not running
        let server_not_running = McpClientError::ServerNotRunning {
            host: "127.0.0.1".to_string(),
            port: 3100,
            source: std::io::Error::new(std::io::ErrorKind::ConnectionRefused, "refused"),
        };
        assert_eq!(mcp_error_to_exit_code(&server_not_running), 1);

        // Test connection timeout
        let timeout = McpClientError::ConnectionTimeout {
            host: "127.0.0.1".to_string(),
            port: 3100,
            timeout_ms: 5000,
        };
        assert_eq!(mcp_error_to_exit_code(&timeout), 1);

        // Test MCP error with corruption indicator
        let corruption_error = McpClientError::McpError {
            code: -32000,
            message: "corruption detected".to_string(),
        };
        assert_eq!(mcp_error_to_exit_code(&corruption_error), 2);

        // Test regular MCP error
        let mcp_error = McpClientError::McpError {
            code: -32600,
            message: "Invalid request".to_string(),
        };
        assert_eq!(mcp_error_to_exit_code(&mcp_error), 1);
    }

    // =========================================================================
    // Content Length Tests
    // =========================================================================

    #[test]
    fn test_max_content_length_constant() {
        assert_eq!(MAX_CONTENT_LENGTH, 10_000);
    }

    #[test]
    fn test_validate_content_length_ok() {
        let content = "x".repeat(MAX_CONTENT_LENGTH);
        assert!(validate_content_length(&content).is_ok());
    }

    #[test]
    fn test_validate_content_length_exceeded() {
        let content = "x".repeat(MAX_CONTENT_LENGTH + 1);
        assert_eq!(validate_content_length(&content), Err(1));
    }

    // =========================================================================
    // Empty Content Tests (No MCP Server Required)
    // =========================================================================

    #[tokio::test]
    async fn test_capture_memory_empty_content_success() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();

        std::env::remove_var("TOOL_DESCRIPTION");
        std::env::remove_var("SESSION_SUMMARY");

        let args = CaptureMemoryArgs {
            content: None,
            source: "hook".to_string(),
            session_id: Some("test-session".to_string()),
            hook_type: None,
            tool_name: None,
            importance: 0.5,
        };

        let exit_code = handle_capture_memory(args).await;
        assert_eq!(
            exit_code, 0,
            "Empty content should return exit 0 (silent success)"
        );
    }

    #[tokio::test]
    async fn test_capture_memory_whitespace_content_success() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();

        std::env::remove_var("TOOL_DESCRIPTION");
        std::env::remove_var("SESSION_SUMMARY");

        let args = CaptureMemoryArgs {
            content: Some("   \n\t  ".to_string()),
            source: "hook".to_string(),
            session_id: Some("test-session".to_string()),
            hook_type: None,
            tool_name: None,
            importance: 0.5,
        };

        let exit_code = handle_capture_memory(args).await;
        assert_eq!(exit_code, 0, "Whitespace content should return exit 0");
    }

    #[tokio::test]
    async fn test_capture_memory_invalid_hook_type() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();

        let args = CaptureMemoryArgs {
            content: Some("Some content".to_string()),
            source: "hook".to_string(),
            session_id: Some("test".to_string()),
            hook_type: Some("invalid_hook_type".to_string()),
            tool_name: None,
            importance: 0.5,
        };

        let exit_code = handle_capture_memory(args).await;
        assert_eq!(exit_code, 1, "Invalid hook_type should return exit 1");
    }

    #[tokio::test]
    async fn test_capture_response_invalid_response_type() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();

        let args = CaptureResponseArgs {
            content: Some("Some content".to_string()),
            session_id: Some("test".to_string()),
            response_type: "invalid_type".to_string(),
            importance: 0.5,
        };

        let exit_code = handle_capture_response(args).await;
        assert_eq!(exit_code, 1, "Invalid response_type should return exit 1");
    }

    #[tokio::test]
    async fn test_capture_memory_over_max_length() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();

        let over_max_content = "x".repeat(MAX_CONTENT_LENGTH + 1);

        let args = CaptureMemoryArgs {
            content: Some(over_max_content),
            source: "hook".to_string(),
            session_id: Some("over-max-session".to_string()),
            hook_type: Some("stop".to_string()),
            tool_name: None,
            importance: 0.5,
        };

        let exit_code = handle_capture_memory(args).await;
        assert_eq!(exit_code, 1, "Over max length should return exit 1");
    }

    #[tokio::test]
    async fn test_capture_response_over_max_length() {
        let _lock = GLOBAL_IDENTITY_LOCK.lock();

        let over_max_content = "x".repeat(MAX_CONTENT_LENGTH + 1);

        let args = CaptureResponseArgs {
            content: Some(over_max_content),
            session_id: Some("test".to_string()),
            response_type: "stop_response".to_string(),
            importance: 0.5,
        };

        let exit_code = handle_capture_response(args).await;
        assert_eq!(exit_code, 1, "Over max length should return exit 1");
    }
}
