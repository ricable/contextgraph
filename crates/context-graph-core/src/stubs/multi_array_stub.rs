//! Stub implementation of MultiArrayEmbeddingProvider for testing.
//!
//! Provides a deterministic, fast stub that generates reproducible embeddings
//! based on content hash. This is useful for unit tests and development
//! before real embedding models are integrated.
//!
//! # Determinism
//!
//! The stub generates embeddings based on the content's byte sum, ensuring:
//! - Same content always produces the same embedding
//! - Different content produces different embeddings
//! - No external dependencies or randomness
//!
//! # Performance
//!
//! Simulates 5ms latency per embedder (65ms total) for realistic test timing.
//!
//! # Health Tracking
//!
//! This provider tracks its initialization state and any errors that occur.
//! The `is_ready()` and `health_status()` methods return actual health status
//! based on internal state, not hardcoded values.

use async_trait::async_trait;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::RwLock;
use std::time::Duration;

use crate::error::CoreResult;
use crate::traits::{MultiArrayEmbeddingOutput, MultiArrayEmbeddingProvider};
use crate::types::fingerprint::{SemanticFingerprint, SparseVector, NUM_EMBEDDERS};

/// Stub implementation of MultiArrayEmbeddingProvider for testing.
///
/// Generates deterministic embeddings based on content hash.
/// No external model dependencies - pure computation based on input bytes.
///
/// # Health Tracking
///
/// This provider tracks:
/// - Initialization state (set to true on successful construction)
/// - Per-embedder health status (all start healthy, can be individually disabled)
/// - Error state (any fatal errors that would make the provider unusable)
/// - Embedding count (for diagnostics)
///
/// # Example
///
/// ```
/// use context_graph_core::stubs::StubMultiArrayProvider;
/// use context_graph_core::traits::MultiArrayEmbeddingProvider;
///
/// let provider = StubMultiArrayProvider::new();
/// assert!(provider.is_ready());
///
/// // Health status reflects actual per-embedder state
/// let health = provider.health_status();
/// assert!(health.iter().all(|&h| h));
/// ```
pub struct StubMultiArrayProvider {
    /// Tracks whether the provider has been properly initialized.
    initialized: AtomicBool,
    /// Tracks the total number of fingerprints generated (for diagnostics).
    fingerprint_count: AtomicU64,
    /// Stores the last error message if any fatal error occurred.
    last_error: RwLock<Option<String>>,
    /// Per-embedder health status (true = healthy, false = unhealthy).
    /// This allows simulating individual embedder failures for testing.
    embedder_health: RwLock<[bool; NUM_EMBEDDERS]>,
}

impl Default for StubMultiArrayProvider {
    fn default() -> Self {
        Self::new()
    }
}

impl StubMultiArrayProvider {
    /// Create a new StubMultiArrayProvider.
    ///
    /// The provider is marked as initialized upon creation with all embedders healthy.
    #[inline]
    pub fn new() -> Self {
        tracing::debug!(
            "StubMultiArrayProvider: initializing with {} embedders",
            NUM_EMBEDDERS
        );
        Self {
            initialized: AtomicBool::new(true),
            fingerprint_count: AtomicU64::new(0),
            last_error: RwLock::new(None),
            embedder_health: RwLock::new([true; NUM_EMBEDDERS]),
        }
    }

    /// Get the total number of fingerprints generated by this provider.
    pub fn fingerprint_count(&self) -> u64 {
        self.fingerprint_count.load(Ordering::Relaxed)
    }

    /// Get the last error message, if any.
    pub fn last_error(&self) -> Option<String> {
        self.last_error.read().ok().and_then(|e| e.clone())
    }

    /// Mark the provider as having encountered a fatal error.
    ///
    /// After calling this, `is_ready()` will return false.
    pub fn set_error(&self, error: String) {
        tracing::error!("StubMultiArrayProvider: setting error state: {}", error);
        if let Ok(mut last_error) = self.last_error.write() {
            *last_error = Some(error);
        }
    }

    /// Clear any error state.
    ///
    /// After calling this, `is_ready()` will return true (if all embedders are healthy).
    pub fn clear_error(&self) {
        tracing::debug!("StubMultiArrayProvider: clearing error state");
        if let Ok(mut last_error) = self.last_error.write() {
            *last_error = None;
        }
    }

    /// Set the health status of a specific embedder.
    ///
    /// # Arguments
    ///
    /// * `embedder_index` - Index of the embedder (0-12, corresponding to E1-E13)
    /// * `healthy` - Whether the embedder should be marked as healthy
    ///
    /// # Panics
    ///
    /// Panics if `embedder_index` >= NUM_EMBEDDERS.
    pub fn set_embedder_health(&self, embedder_index: usize, healthy: bool) {
        assert!(
            embedder_index < NUM_EMBEDDERS,
            "Embedder index {} out of range (max {})",
            embedder_index,
            NUM_EMBEDDERS - 1
        );

        if let Ok(mut health) = self.embedder_health.write() {
            health[embedder_index] = healthy;
            tracing::debug!(
                "StubMultiArrayProvider: embedder E{} health set to {}",
                embedder_index + 1,
                healthy
            );
        }
    }

    /// Mark all embedders as healthy.
    pub fn reset_embedder_health(&self) {
        if let Ok(mut health) = self.embedder_health.write() {
            *health = [true; NUM_EMBEDDERS];
        }
        tracing::debug!("StubMultiArrayProvider: all embedder health reset to healthy");
    }

    /// Generate a deterministic base value from content.
    ///
    /// Uses byte sum modulo 256 to create a value in [0, 1].
    #[inline]
    fn content_hash(content: &str) -> f32 {
        let sum: u32 = content.bytes().map(u32::from).sum();
        (sum % 256) as f32 / 255.0
    }

    /// Generate a deterministic value for a specific dimension and embedder.
    ///
    /// Combines content hash with dimension index AND embedder index for variety.
    /// Each embedder uses a different multiplier to ensure distinct patterns across
    /// the 13 embedding spaces.
    #[inline]
    fn deterministic_value(base: f32, dim_idx: usize, embedder_idx: usize) -> f32 {
        // Use prime multipliers per embedder to create distinct patterns
        // These primes ensure each embedder has a unique dimensional variation
        const EMBEDDER_PRIMES: [f32; 13] = [
            0.0173, // E1: semantic
            0.0237, // E2: temporal-recent
            0.0311, // E3: temporal-periodic
            0.0419, // E4: temporal-positional
            0.0523, // E5: causal
            0.0631, // E6: sparse (not used for dense)
            0.0739, // E7: code
            0.0853, // E8: graph
            0.0967, // E9: hdc
            0.1087, // E10: multimodal
            0.1193, // E11: entity
            0.1301, // E12: late-interaction
            0.1409, // E13: splade (not used for dense)
        ];

        // Add embedder-specific phase shift and frequency variation
        let prime = EMBEDDER_PRIMES[embedder_idx % 13];
        let embedder_phase = (embedder_idx as f32 * 0.0769) % 1.0; // Different starting phase
        let offset = ((dim_idx as f32 * prime + embedder_phase) % 1.0) - 0.5;

        // Apply a non-linear transformation per embedder to increase variety
        let embedder_scale = 0.7 + (embedder_idx as f32 * 0.023) % 0.3;
        let value = base * embedder_scale + offset * (1.0 - embedder_scale);

        value.clamp(0.0, 1.0)
    }

    /// Fill a dense embedding vector deterministically with embedder-specific variation.
    ///
    /// Each embedder index produces a distinctly different embedding pattern,
    /// ensuring that similarity scores vary across the 13 embedding spaces.
    fn fill_dense_embedding(content: &str, dim: usize, embedder_idx: usize) -> Vec<f32> {
        let base = Self::content_hash(content);
        (0..dim)
            .map(|i| Self::deterministic_value(base, i, embedder_idx))
            .collect()
    }

    /// Generate a deterministic sparse vector.
    ///
    /// # IMPORTANT: Non-Zero Guarantee
    ///
    /// Values are guaranteed to be in range [0.1, 1.0] to ensure non-zero norm.
    /// HNSW/SPLADE indexes require non-zero vectors for cosine similarity.
    fn generate_sparse_vector(content: &str) -> SparseVector {
        let base_sum: u32 = content.bytes().map(u32::from).sum();
        // Generate 10 sparse entries based on content
        let num_entries = 10.min(((base_sum % 20) + 5) as usize);

        let mut indices: Vec<u16> = (0..num_entries)
            .map(|i| ((base_sum as usize * 17 + i * 2003) % 30000) as u16)
            .collect();
        indices.sort();
        indices.dedup();

        // Generate non-zero values: range [0.1, 1.0] guarantees non-zero norm
        // Use different formula than deterministic_value to avoid zero clamping
        let base = Self::content_hash(content);
        let values: Vec<f32> = indices
            .iter()
            .enumerate()
            .map(|(i, _)| {
                // Generate value in [0.1, 1.0] - never zero
                let variation = ((i as f32 * 0.13) % 0.9) + base * 0.1;
                0.1 + (variation % 0.9)
            })
            .collect();

        SparseVector::new(indices, values).unwrap_or_else(|_| SparseVector::empty())
    }

    /// Generate deterministic token embeddings for E12 (late-interaction).
    fn generate_token_embeddings(content: &str) -> Vec<Vec<f32>> {
        let base = Self::content_hash(content);
        // Generate ~1 token per 5 characters, minimum 1
        let num_tokens = (content.len() / 5).clamp(1, 64);

        (0..num_tokens)
            .map(|token_idx| {
                (0..128) // E12 has 128D per token
                    .map(|dim| Self::deterministic_value(base, dim + token_idx * 128, 11)) // E12 = index 11
                    .collect()
            })
            .collect()
    }
}

#[async_trait]
impl MultiArrayEmbeddingProvider for StubMultiArrayProvider {
    async fn embed_all(&self, content: &str) -> CoreResult<MultiArrayEmbeddingOutput> {
        // Check readiness before processing
        if !self.is_ready() {
            tracing::error!("StubMultiArrayProvider: embed_all called but provider is not ready");
            return Err(crate::error::CoreError::Internal(
                "StubMultiArrayProvider is not ready".into(),
            ));
        }

        // Generate deterministic fingerprint
        let mut fingerprint = SemanticFingerprint::zeroed();

        // Fill dense embeddings with embedder-specific patterns
        // Each embedder uses a different index to produce distinct vectors
        fingerprint.e1_semantic = Self::fill_dense_embedding(content, 1024, 0);
        fingerprint.e2_temporal_recent = Self::fill_dense_embedding(content, 512, 1);
        fingerprint.e3_temporal_periodic = Self::fill_dense_embedding(content, 512, 2);
        fingerprint.e4_temporal_positional = Self::fill_dense_embedding(content, 512, 3);
        // E5: CORE-01 FIX: Generate DISTINCT vectors for asymmetric cause/effect fields.
        // Using different embedder indices (4 vs 17) produces different dimensional patterns
        // so that tests can actually verify asymmetric search logic.
        fingerprint.e5_causal_as_cause = Self::fill_dense_embedding(content, 768, 4);
        fingerprint.e5_causal_as_effect = Self::fill_dense_embedding(content, 768, 17);
        // Legacy field uses cause vector for backward compatibility
        fingerprint.e5_causal = fingerprint.e5_causal_as_cause.clone();
        fingerprint.e7_code = Self::fill_dense_embedding(content, 1536, 6);
        // E8: CORE-01 FIX: Generate DISTINCT vectors for asymmetric source/target fields.
        fingerprint.e8_graph_as_source = Self::fill_dense_embedding(content, 1024, 7);
        fingerprint.e8_graph_as_target = Self::fill_dense_embedding(content, 1024, 19);
        // Legacy field uses source vector for backward compatibility
        fingerprint.e8_graph = fingerprint.e8_graph_as_source.clone();
        fingerprint.e9_hdc = Self::fill_dense_embedding(content, 1024, 8); // HDC projected
        // E10: CORE-01 FIX: Generate DISTINCT vectors for asymmetric intent/context fields.
        fingerprint.e10_multimodal_as_intent = Self::fill_dense_embedding(content, 768, 9);
        fingerprint.e10_multimodal_as_context = Self::fill_dense_embedding(content, 768, 21);
        // Legacy field uses intent vector for backward compatibility
        fingerprint.e10_multimodal = fingerprint.e10_multimodal_as_intent.clone();
        fingerprint.e11_entity = Self::fill_dense_embedding(content, 768, 10); // KEPLER

        // Fill sparse embeddings
        fingerprint.e6_sparse = Self::generate_sparse_vector(content);
        fingerprint.e13_splade = Self::generate_sparse_vector(content);

        // Fill token-level embeddings
        fingerprint.e12_late_interaction = Self::generate_token_embeddings(content);

        // Track successful fingerprint generation
        self.fingerprint_count.fetch_add(1, Ordering::Relaxed);

        // Simulated latencies: 5ms per embedder
        let per_embedder_latency = [Duration::from_millis(5); NUM_EMBEDDERS];
        let total_latency = Duration::from_millis(5 * NUM_EMBEDDERS as u64);

        tracing::trace!(
            "StubMultiArrayProvider: generated fingerprint #{} in {:?}",
            self.fingerprint_count.load(Ordering::Relaxed),
            total_latency
        );

        Ok(MultiArrayEmbeddingOutput {
            fingerprint,
            total_latency,
            per_embedder_latency,
            model_ids: core::array::from_fn(|i| format!("stub-e{}", i + 1)),
            e5_hint_provenance: None,
        })
    }

    async fn embed_batch_all(
        &self,
        contents: &[String],
    ) -> CoreResult<Vec<MultiArrayEmbeddingOutput>> {
        // Check readiness before processing
        if !self.is_ready() {
            tracing::error!(
                "StubMultiArrayProvider: embed_batch_all called but provider is not ready"
            );
            return Err(crate::error::CoreError::Internal(
                "StubMultiArrayProvider is not ready".into(),
            ));
        }

        let mut results = Vec::with_capacity(contents.len());
        for content in contents {
            results.push(self.embed_all(content).await?);
        }
        Ok(results)
    }

    fn model_ids(&self) -> [&str; NUM_EMBEDDERS] {
        [
            "stub-e1", "stub-e2", "stub-e3", "stub-e4", "stub-e5", "stub-e6", "stub-e7", "stub-e8",
            "stub-e9", "stub-e10", "stub-e11", "stub-e12", "stub-e13",
        ]
    }

    /// Check if the provider is ready to generate embeddings.
    ///
    /// This performs REAL health checks:
    /// 1. Verifies the provider was properly initialized
    /// 2. Checks for any fatal errors in the error state
    /// 3. Verifies at least one embedder is healthy
    ///
    /// # Returns
    ///
    /// `true` if all health checks pass, `false` otherwise.
    fn is_ready(&self) -> bool {
        // Check 1: Was the provider properly initialized?
        let is_initialized = self.initialized.load(Ordering::SeqCst);
        if !is_initialized {
            tracing::warn!("StubMultiArrayProvider health check failed: not initialized");
            return false;
        }

        // Check 2: Are there any fatal errors?
        let has_error = self.last_error.read().map(|e| e.is_some()).unwrap_or(true); // If lock is poisoned, treat as error

        if has_error {
            if let Ok(error) = self.last_error.read() {
                if let Some(ref err_msg) = *error {
                    tracing::warn!(
                        "StubMultiArrayProvider health check failed: error state: {}",
                        err_msg
                    );
                }
            }
            return false;
        }

        // Check 3: Is at least one embedder healthy?
        let health_status = self.health_status();
        let any_healthy = health_status.iter().any(|&h| h);
        if !any_healthy {
            tracing::warn!("StubMultiArrayProvider health check failed: all embedders unhealthy");
            return false;
        }

        true
    }

    /// Get the health status of each embedder.
    ///
    /// This returns the ACTUAL per-embedder health status, not hardcoded values.
    /// Health status can be modified using `set_embedder_health()` for testing.
    ///
    /// # Returns
    ///
    /// Array of booleans indicating health status for each embedder (E1-E13).
    fn health_status(&self) -> [bool; NUM_EMBEDDERS] {
        self.embedder_health.read().map(|h| *h).unwrap_or_else(|_| {
            // If lock is poisoned, log and return all unhealthy
            tracing::error!(
                "StubMultiArrayProvider: embedder_health lock poisoned, returning all unhealthy"
            );
            [false; NUM_EMBEDDERS]
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test that a properly initialized provider is ready.
    #[test]
    fn test_is_ready() {
        let provider = StubMultiArrayProvider::new();
        assert!(provider.is_ready());
    }

    /// Test that health_status returns all true for new provider.
    #[test]
    fn test_health_status_all_true() {
        let provider = StubMultiArrayProvider::new();
        let health = provider.health_status();
        assert_eq!(health.len(), NUM_EMBEDDERS);
        assert!(health.iter().all(|&h| h));
    }

    /// Test that setting error state makes provider not ready.
    #[test]
    fn test_error_state_makes_not_ready() {
        let provider = StubMultiArrayProvider::new();
        assert!(provider.is_ready());

        provider.set_error("Simulated fatal error".to_string());
        assert!(!provider.is_ready());
        assert_eq!(
            provider.last_error(),
            Some("Simulated fatal error".to_string())
        );

        provider.clear_error();
        assert!(provider.is_ready());
        assert!(provider.last_error().is_none());
    }

    /// Test that setting all embedders unhealthy makes provider not ready.
    #[test]
    fn test_all_embedders_unhealthy_makes_not_ready() {
        let provider = StubMultiArrayProvider::new();
        assert!(provider.is_ready());

        // Mark all embedders as unhealthy
        for i in 0..NUM_EMBEDDERS {
            provider.set_embedder_health(i, false);
        }

        assert!(!provider.is_ready());

        // Reset and verify recovery
        provider.reset_embedder_health();
        assert!(provider.is_ready());
    }

    /// Test that even with one embedder unhealthy, provider is still ready.
    #[test]
    fn test_partial_embedder_failure_still_ready() {
        let provider = StubMultiArrayProvider::new();

        // Mark some embedders as unhealthy (but not all)
        provider.set_embedder_health(0, false); // E1
        provider.set_embedder_health(5, false); // E6

        // Provider should still be ready since some embedders are healthy
        assert!(provider.is_ready());

        // Verify health status reflects individual failures
        let health = provider.health_status();
        assert!(!health[0]); // E1 is unhealthy
        assert!(!health[5]); // E6 is unhealthy
        assert!(health[1]); // E2 is still healthy
    }

    /// Test that model_ids returns correct format.
    #[test]
    fn test_model_ids_format() {
        let provider = StubMultiArrayProvider::new();
        let ids = provider.model_ids();
        assert_eq!(ids.len(), NUM_EMBEDDERS);
        assert_eq!(ids[0], "stub-e1");
        assert_eq!(ids[12], "stub-e13");
    }

    /// Test deterministic output: same content produces same fingerprint.
    #[tokio::test]
    async fn test_deterministic_same_content() {
        let provider = StubMultiArrayProvider::new();

        let output1 = provider.embed_all("test content").await.unwrap();
        let output2 = provider.embed_all("test content").await.unwrap();

        // Fingerprints should be identical for same content
        assert_eq!(output1.fingerprint, output2.fingerprint);
    }

    /// Test deterministic output: different content produces different fingerprint.
    #[tokio::test]
    async fn test_deterministic_different_content() {
        let provider = StubMultiArrayProvider::new();

        let output1 = provider.embed_all("content A").await.unwrap();
        let output2 = provider.embed_all("content B").await.unwrap();

        // Fingerprints should differ for different content
        assert_ne!(output1.fingerprint, output2.fingerprint);
    }

    /// Test that simulated latency is 5ms per embedder.
    #[tokio::test]
    async fn test_latency_simulation() {
        let provider = StubMultiArrayProvider::new();
        let output = provider.embed_all("test").await.unwrap();

        // Total latency should be 5ms * 13 = 65ms
        assert_eq!(output.total_latency, Duration::from_millis(65));

        // Each embedder should have 5ms latency
        for latency in output.per_embedder_latency.iter() {
            assert_eq!(*latency, Duration::from_millis(5));
        }
    }

    /// Test that embed_all produces correct embedding dimensions.
    #[tokio::test]
    async fn test_embedding_dimensions() {
        let provider = StubMultiArrayProvider::new();
        let output = provider.embed_all("test content").await.unwrap();

        let fp = &output.fingerprint;
        assert_eq!(fp.e1_semantic.len(), 1024);
        assert_eq!(fp.e2_temporal_recent.len(), 512);
        assert_eq!(fp.e3_temporal_periodic.len(), 512);
        assert_eq!(fp.e4_temporal_positional.len(), 512);
        assert_eq!(fp.e5_causal.len(), 768);
        assert_eq!(fp.e7_code.len(), 1536);
        assert_eq!(fp.e8_graph.len(), 1024); // Upgraded from 384D
        assert_eq!(fp.e9_hdc.len(), 1024); // HDC projected
        assert_eq!(fp.e10_multimodal.len(), 768);
        assert_eq!(fp.e11_entity.len(), 768); // KEPLER
    }

    /// Test that sparse vectors are generated correctly.
    #[tokio::test]
    async fn test_sparse_vectors() {
        let provider = StubMultiArrayProvider::new();
        let output = provider.embed_all("test content for sparse").await.unwrap();

        // Sparse vectors should have entries
        assert!(!output.fingerprint.e6_sparse.is_empty());
        assert!(!output.fingerprint.e13_splade.is_empty());

        // Check that indices are sorted (validation happens in SparseVector::new)
        let e6 = &output.fingerprint.e6_sparse;
        for i in 1..e6.indices.len() {
            assert!(e6.indices[i] > e6.indices[i - 1]);
        }
    }

    /// Test that token embeddings are generated correctly.
    #[tokio::test]
    async fn test_token_embeddings() {
        let provider = StubMultiArrayProvider::new();
        let output = provider
            .embed_all("this is a longer test content for tokens")
            .await
            .unwrap();

        // Should have multiple tokens
        assert!(!output.fingerprint.e12_late_interaction.is_empty());

        // Each token should have 128D
        for token_embed in &output.fingerprint.e12_late_interaction {
            assert_eq!(token_embed.len(), 128);
        }
    }

    /// Test batch embedding.
    #[tokio::test]
    async fn test_batch_embedding() {
        let provider = StubMultiArrayProvider::new();
        let contents = vec![
            "first content".to_string(),
            "second content".to_string(),
            "third content".to_string(),
        ];

        let outputs = provider.embed_batch_all(&contents).await.unwrap();
        assert_eq!(outputs.len(), 3);

        // Each output should have valid fingerprint
        for output in &outputs {
            assert_eq!(output.fingerprint.e1_semantic.len(), 1024);
        }
    }

    /// Test that default dimensions method works.
    #[test]
    fn test_dimensions_default() {
        let provider = StubMultiArrayProvider::new();
        let dims = provider.dimensions();

        assert_eq!(dims[0], 1024); // E1
        assert_eq!(dims[1], 512); // E2
        assert_eq!(dims[5], 0); // E6 sparse
        assert_eq!(dims[8], 1024); // E9 HDC (projected)
        assert_eq!(dims[12], 0); // E13 sparse
    }

    /// Test empty content handling.
    #[tokio::test]
    async fn test_empty_content() {
        let provider = StubMultiArrayProvider::new();
        let output = provider.embed_all("").await.unwrap();

        // Should produce valid fingerprint even for empty content
        assert_eq!(output.fingerprint.e1_semantic.len(), 1024);
    }

    /// Test that content_hash is deterministic.
    #[test]
    fn test_content_hash_determinism() {
        let hash1 = StubMultiArrayProvider::content_hash("test");
        let hash2 = StubMultiArrayProvider::content_hash("test");
        assert_eq!(hash1, hash2);

        let hash3 = StubMultiArrayProvider::content_hash("different");
        assert_ne!(hash1, hash3);
    }

    /// Test model_ids in output matches trait method.
    #[tokio::test]
    async fn test_output_model_ids_match() {
        let provider = StubMultiArrayProvider::new();
        let output = provider.embed_all("test").await.unwrap();

        let trait_ids = provider.model_ids();
        for (i, output_id) in output.model_ids.iter().enumerate() {
            assert_eq!(output_id, trait_ids[i]);
        }
    }

    // Additional tests for real health checks

    /// Test that embed_all fails when provider is not ready.
    #[tokio::test]
    async fn test_embed_all_fails_when_not_ready() {
        let provider = StubMultiArrayProvider::new();
        provider.set_error("Fatal error".to_string());

        let result = provider.embed_all("test").await;
        assert!(result.is_err());
    }

    /// Test that embed_batch_all fails when provider is not ready.
    #[tokio::test]
    async fn test_embed_batch_all_fails_when_not_ready() {
        let provider = StubMultiArrayProvider::new();

        // Mark all embedders as unhealthy
        for i in 0..NUM_EMBEDDERS {
            provider.set_embedder_health(i, false);
        }

        let contents = vec!["test".to_string()];
        let result = provider.embed_batch_all(&contents).await;
        assert!(result.is_err());
    }

    /// Test fingerprint count tracking.
    #[tokio::test]
    async fn test_fingerprint_count_tracking() {
        let provider = StubMultiArrayProvider::new();
        assert_eq!(provider.fingerprint_count(), 0);

        provider.embed_all("test1").await.unwrap();
        assert_eq!(provider.fingerprint_count(), 1);

        provider.embed_all("test2").await.unwrap();
        assert_eq!(provider.fingerprint_count(), 2);

        let contents = vec!["a".to_string(), "b".to_string(), "c".to_string()];
        provider.embed_batch_all(&contents).await.unwrap();
        assert_eq!(provider.fingerprint_count(), 5);
    }

    /// Test that health status correctly tracks individual embedder state.
    #[test]
    fn test_health_status_individual_tracking() {
        let provider = StubMultiArrayProvider::new();

        // All should start healthy
        let health = provider.health_status();
        assert!(health.iter().all(|&h| h));

        // Set E5 (index 4) as unhealthy
        provider.set_embedder_health(4, false);

        let health = provider.health_status();
        assert!(health[0]); // E1 healthy
        assert!(health[3]); // E4 healthy
        assert!(!health[4]); // E5 unhealthy
        assert!(health[5]); // E6 healthy

        // Count healthy embedders
        let healthy_count = health.iter().filter(|&&h| h).count();
        assert_eq!(healthy_count, NUM_EMBEDDERS - 1);
    }
}
