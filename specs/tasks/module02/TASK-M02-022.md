# TASK-M02-022: Implement CognitivePulse Methods

```xml
<task_spec id="TASK-M02-022" version="1.0">
<metadata>
  <title>Implement CognitivePulse Methods</title>
  <status>blocked</status>
  <layer>surface</layer>
  <module>module-02</module>
  <sequence>22</sequence>
  <priority>critical</priority>
  <estimated_hours>3</estimated_hours>
  <implements>
    <item>REQ-CORE-007: CognitivePulse requirements</item>
    <item>REQ-CORE-008: Pulse action requirements</item>
    <item>TECH-CORE-002 Section 2.4: CognitivePulse specification</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-021</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements the methods for CognitivePulse: construction, action computation, updating, blending, and JSON serialization. The key method is compute_suggested_action() which implements the entropy/coherence decision matrix from the PRD to determine what action the agent should take.
</context>

<input_context_files>
  <file purpose="CognitivePulse struct">crates/context-graph-core/src/pulse.rs</file>
  <file purpose="PRD for action decision matrix">docs2/contextprd.md</file>
  <file purpose="Constitution for action rules">docs2/constitution.yaml</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-021 (CognitivePulse struct) completed</check>
</prerequisites>

<scope>
  <in_scope>
    - new() constructor with metric clamping
    - compute_suggested_action() implementing decision matrix
    - update() for modifying entropy/coherence
    - blend() for linear interpolation between pulses
    - to_json() for JSON serialization
    - Default trait implementation
    - Unit tests for all methods including decision matrix edge cases
  </in_scope>
  <out_of_scope>
    - Integration with MCP handlers (future module)
    - Neuromodulation updates (future module)
    - Session-level pulse aggregation (future module)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-core/src/pulse.rs">
impl CognitivePulse {
    /// Creates a new CognitivePulse with clamped metrics.
    ///
    /// All f32 values are clamped to [0, 1] range.
    /// suggested_action is computed from entropy and coherence.
    pub fn new(
        entropy: f32,
        coherence: f32,
        curiosity_score: f32,
        confidence: f32,
        emotional_state: EmotionalState,
    ) -> Self;

    /// Computes the suggested action based on entropy and coherence.
    ///
    /// Decision matrix:
    /// - entropy &gt; 0.7 &amp;&amp; coherence &lt; 0.4 → Stabilize
    /// - entropy &lt; 0.3 &amp;&amp; coherence &gt; 0.7 → Ready
    /// - curiosity_score &gt; 0.7 → Explore
    /// - entropy &lt; 0.4 &amp;&amp; coherence 0.5-0.8 → Consolidate
    /// - entropy &gt; 0.7 &amp;&amp; coherence &gt; 0.5 → Explore
    /// - coherence &lt; 0.4 → Review
    /// - otherwise → Continue
    pub fn compute_suggested_action(&amp;self) -> SuggestedAction;

    /// Updates entropy and coherence, recomputing suggested_action.
    /// Values are clamped to [0, 1].
    pub fn update(&amp;mut self, delta_entropy: f32, delta_coherence: f32);

    /// Linearly interpolates between two pulses.
    ///
    /// # Arguments
    /// * `other` - The other pulse to blend with
    /// * `t` - Blend factor in [0, 1]. 0 = self, 1 = other
    pub fn blend(&amp;self, other: &amp;CognitivePulse, t: f32) -> CognitivePulse;

    /// Serializes the pulse to JSON string.
    pub fn to_json(&amp;self) -> Result&lt;String, serde_json::Error&gt;;
}

impl Default for CognitivePulse {
    /// Returns a balanced default pulse:
    /// entropy=0.5, coherence=0.5, curiosity=0.5, confidence=0.5,
    /// emotional_state=Neutral, suggested_action=Continue
    fn default() -> Self;
}
    </signature>
  </signatures>

  <constraints>
    - new() must clamp all f32 metrics to [0, 1]
    - compute_suggested_action() must follow exact decision matrix order
    - blend() must clamp t to [0, 1] and interpolate all numeric fields
    - Default entropy=0.5, coherence=0.5 must result in action=Continue
    - timestamp in new() and default() should use Utc::now()
  </constraints>

  <verification>
    - cargo build --package context-graph-core compiles without errors
    - cargo test --package context-graph-core pulse passes all tests
    - Decision matrix edge cases all tested
    - Blend produces correct intermediate values
    - Default returns expected values
  </verification>
</definition_of_done>

<pseudo_code>
pulse.rs (additions):

impl CognitivePulse:
  fn new(entropy, coherence, curiosity_score, confidence, emotional_state):
    let clamped_entropy = entropy.clamp(0.0, 1.0)
    let clamped_coherence = coherence.clamp(0.0, 1.0)
    let clamped_curiosity = curiosity_score.clamp(0.0, 1.0)
    let clamped_confidence = confidence.clamp(0.0, 1.0)

    let mut pulse = CognitivePulse {
      entropy: clamped_entropy,
      coherence: clamped_coherence,
      curiosity_score: clamped_curiosity,
      confidence: clamped_confidence,
      emotional_state,
      suggested_action: SuggestedAction::Continue,  // placeholder
      timestamp: Utc::now(),
    }
    pulse.suggested_action = pulse.compute_suggested_action()
    pulse

  fn compute_suggested_action():
    // Priority-ordered decision matrix
    // 1. High entropy + low coherence = Stabilize (crisis state)
    if self.entropy > 0.7 && self.coherence < 0.4:
      return SuggestedAction::Stabilize

    // 2. Low entropy + high coherence = Ready (optimal state)
    if self.entropy < 0.3 && self.coherence > 0.7:
      return SuggestedAction::Ready

    // 3. High curiosity = Explore
    if self.curiosity_score > 0.7:
      return SuggestedAction::Explore

    // 4. Low entropy + moderate-high coherence = Consolidate
    if self.entropy < 0.4 && self.coherence >= 0.5 && self.coherence <= 0.8:
      return SuggestedAction::Consolidate

    // 5. High entropy + moderate-high coherence = Explore (different path)
    if self.entropy > 0.7 && self.coherence > 0.5:
      return SuggestedAction::Explore

    // 6. Low coherence = Review
    if self.coherence < 0.4:
      return SuggestedAction::Review

    // 7. Default = Continue
    SuggestedAction::Continue

  fn update(delta_entropy, delta_coherence):
    self.entropy = (self.entropy + delta_entropy).clamp(0.0, 1.0)
    self.coherence = (self.coherence + delta_coherence).clamp(0.0, 1.0)
    self.suggested_action = self.compute_suggested_action()
    self.timestamp = Utc::now()

  fn blend(other, t):
    let t = t.clamp(0.0, 1.0)
    let lerp = |a, b| a + t * (b - a)

    CognitivePulse::new(
      lerp(self.entropy, other.entropy),
      lerp(self.coherence, other.coherence),
      lerp(self.curiosity_score, other.curiosity_score),
      lerp(self.confidence, other.confidence),
      if t < 0.5 { self.emotional_state } else { other.emotional_state },
    )

  fn to_json():
    serde_json::to_string(self)

impl Default for CognitivePulse:
  fn default():
    CognitivePulse::new(0.5, 0.5, 0.5, 0.5, EmotionalState::Neutral)

#[cfg(test)]
mod pulse_method_tests:
  test_new_clamps_values()
  test_compute_action_stabilize()
  test_compute_action_ready()
  test_compute_action_explore_curiosity()
  test_compute_action_consolidate()
  test_compute_action_explore_entropy()
  test_compute_action_review()
  test_compute_action_continue()
  test_update_modifies_values()
  test_blend_interpolates()
  test_default_values()
  test_to_json_format()
</pseudo_code>

<files_to_create>
  <!-- No new files - additions to existing pulse.rs -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-core/src/pulse.rs">Add CognitivePulse impl block with all methods</file>
</files_to_modify>

<validation_criteria>
  <criterion>new() clamps all metrics to [0, 1] range</criterion>
  <criterion>compute_suggested_action() returns Stabilize when entropy &gt; 0.7 AND coherence &lt; 0.4</criterion>
  <criterion>compute_suggested_action() returns Ready when entropy &lt; 0.3 AND coherence &gt; 0.7</criterion>
  <criterion>compute_suggested_action() returns Explore when curiosity_score &gt; 0.7</criterion>
  <criterion>compute_suggested_action() returns Consolidate when entropy &lt; 0.4 AND coherence in [0.5, 0.8]</criterion>
  <criterion>compute_suggested_action() returns Review when coherence &lt; 0.4 (and not Stabilize)</criterion>
  <criterion>compute_suggested_action() returns Continue for balanced state</criterion>
  <criterion>update() modifies values and recomputes action</criterion>
  <criterion>blend() linearly interpolates all numeric fields</criterion>
  <criterion>Default returns entropy=0.5, coherence=0.5, action=Continue</criterion>
  <criterion>to_json() produces valid JSON</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-core</command>
  <command>cargo test --package context-graph-core pulse -- --nocapture</command>
  <command>cargo clippy --package context-graph-core -- -D warnings</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Decision Matrix Priority
The order of conditions in compute_suggested_action() matters:
1. Stabilize takes priority (crisis state)
2. Ready is the goal state
3. Explore can be triggered by curiosity OR high entropy with good coherence
4. Consolidate is for stable but not-yet-optimal state
5. Review for low coherence states
6. Continue is the fallback

### Blend Emotional State
The blend() method uses the emotional state from whichever pulse is "closer" (t < 0.5 uses self, otherwise uses other). This is a simple approach; a more sophisticated implementation could interpolate emotional states.

---

*Task ID: TASK-M02-022*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
