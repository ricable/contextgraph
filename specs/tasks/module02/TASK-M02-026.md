# TASK-M02-026: Implement Memex Trait Abstraction

```xml
<task_spec id="TASK-M02-026" version="1.0">
<metadata>
  <title>Implement Memex Trait Abstraction</title>
  <status>blocked</status>
  <layer>surface</layer>
  <module>module-02</module>
  <sequence>26</sequence>
  <priority>high</priority>
  <estimated_hours>2</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3: Storage specification</item>
    <item>REQ-CORE-005: Storage requirements</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-017</task_ref>
    <task_ref>TASK-M02-018</task_ref>
    <task_ref>TASK-M02-023</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
The Memex trait defines a storage abstraction layer that allows the system to work with different storage backends. RocksDbMemex implements this trait, but the abstraction enables future backends (e.g., in-memory for testing, distributed storage). The trait uses async methods and must be object-safe for dyn dispatch.
</context>

<input_context_files>
  <file purpose="RocksDB backend with CRUD operations">crates/context-graph-storage/src/rocksdb_backend.rs</file>
  <file purpose="Index operations">crates/context-graph-storage/src/indexes.rs</file>
  <file purpose="Core types">crates/context-graph-core/src/lib.rs</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-017 (Node CRUD Operations) completed</check>
  <check>TASK-M02-018 (Edge CRUD Operations) completed</check>
  <check>TASK-M02-023 (Secondary Index Operations) completed</check>
</prerequisites>

<scope>
  <in_scope>
    - Memex trait definition with async methods
    - Node CRUD: store_node, get_node, update_node, delete_node
    - Edge CRUD: store_edge, get_edge, get_edges_from, get_edges_to
    - Index queries: query_by_quadrant, query_by_tag
    - Embedding operations: get_embedding
    - Health check method
    - RocksDbMemex implements Memex
    - Object-safe trait design
  </in_scope>
  <out_of_scope>
    - Alternative implementations (in-memory, distributed)
    - Vector similarity search (FAISS integration)
    - Full storage functionality (only core subset in trait)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/memex.rs">
use async_trait::async_trait;
use context_graph_core::{
    GraphEdge, JohariQuadrant, MemoryNode, NodeId, EdgeType,
};
use crate::StorageError;

/// Storage abstraction trait for the Context Graph system.
///
/// This trait defines the core storage operations required by the system.
/// RocksDbMemex implements this trait, but the abstraction allows for
/// alternative backends (in-memory for testing, distributed for scale).
///
/// # Object Safety
/// This trait is object-safe and can be used with dyn dispatch.
#[async_trait]
pub trait Memex: Send + Sync {
    // === Node Operations ===

    /// Stores a memory node.
    async fn store_node(&amp;self, node: &amp;MemoryNode) -> Result&lt;(), StorageError&gt;;

    /// Retrieves a memory node by ID.
    async fn get_node(&amp;self, id: &amp;NodeId) -> Result&lt;MemoryNode, StorageError&gt;;

    /// Updates an existing memory node.
    async fn update_node(&amp;self, node: &amp;MemoryNode) -> Result&lt;(), StorageError&gt;;

    /// Deletes a memory node.
    async fn delete_node(&amp;self, id: &amp;NodeId, soft_delete: bool) -> Result&lt;(), StorageError&gt;;

    // === Edge Operations ===

    /// Stores a graph edge.
    async fn store_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt;;

    /// Retrieves a graph edge.
    async fn get_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;GraphEdge, StorageError&gt;;

    /// Gets all outgoing edges from a node.
    async fn get_edges_from(&amp;self, source_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;

    /// Gets all incoming edges to a node.
    async fn get_edges_to(&amp;self, target_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;

    // === Query Operations ===

    /// Queries nodes by Johari quadrant.
    async fn query_by_quadrant(
        &amp;self,
        quadrant: JohariQuadrant,
        limit: Option&lt;usize&gt;,
    ) -> Result&lt;Vec&lt;NodeId&gt;, StorageError&gt;;

    /// Queries nodes by tag.
    async fn query_by_tag(
        &amp;self,
        tag: &amp;str,
        limit: Option&lt;usize&gt;,
    ) -> Result&lt;Vec&lt;NodeId&gt;, StorageError&gt;;

    // === Embedding Operations ===

    /// Retrieves an embedding by node ID.
    async fn get_embedding(&amp;self, id: &amp;NodeId) -> Result&lt;Vec&lt;f32&gt;, StorageError&gt;;

    // === Health ===

    /// Checks storage health.
    async fn health_check(&amp;self) -> Result&lt;StorageHealth, StorageError&gt;;
}

/// Storage health status.
#[derive(Debug, Clone)]
pub struct StorageHealth {
    pub is_healthy: bool,
    pub node_count: u64,
    pub edge_count: u64,
    pub storage_bytes: u64,
}
    </signature>
  </signatures>

  <constraints>
    - Trait must be object-safe (no generic methods, no Self in return types beyond Result)
    - All methods must be async
    - Must use async_trait crate for async trait methods
    - Send + Sync bounds required for cross-thread usage
    - RocksDbMemex must implement all trait methods
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage memex passes all tests
    - Trait is object-safe (can create Box&lt;dyn Memex&gt;)
    - RocksDbMemex implements Memex correctly
  </verification>
</definition_of_done>

<pseudo_code>
memex.rs:

use async_trait::async_trait;
use context_graph_core::{...}
use crate::StorageError;

#[derive(Debug, Clone)]
pub struct StorageHealth {
    pub is_healthy: bool,
    pub node_count: u64,
    pub edge_count: u64,
    pub storage_bytes: u64,
}

#[async_trait]
pub trait Memex: Send + Sync {
    // Node operations
    async fn store_node(&amp;self, node: &amp;MemoryNode) -> Result&lt;(), StorageError&gt;;
    async fn get_node(&amp;self, id: &amp;NodeId) -> Result&lt;MemoryNode, StorageError&gt;;
    async fn update_node(&amp;self, node: &amp;MemoryNode) -> Result&lt;(), StorageError&gt;;
    async fn delete_node(&amp;self, id: &amp;NodeId, soft_delete: bool) -> Result&lt;(), StorageError&gt;;

    // Edge operations
    async fn store_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt;;
    async fn get_edge(&amp;self, source_id: &amp;NodeId, target_id: &amp;NodeId, edge_type: EdgeType) -> Result&lt;GraphEdge, StorageError&gt;;
    async fn get_edges_from(&amp;self, source_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;
    async fn get_edges_to(&amp;self, target_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;

    // Query operations
    async fn query_by_quadrant(&amp;self, quadrant: JohariQuadrant, limit: Option&lt;usize&gt;) -> Result&lt;Vec&lt;NodeId&gt;, StorageError&gt;;
    async fn query_by_tag(&amp;self, tag: &amp;str, limit: Option&lt;usize&gt;) -> Result&lt;Vec&lt;NodeId&gt;, StorageError&gt;;

    // Embedding
    async fn get_embedding(&amp;self, id: &amp;NodeId) -> Result&lt;Vec&lt;f32&gt;, StorageError&gt;;

    // Health
    async fn health_check(&amp;self) -> Result&lt;StorageHealth, StorageError&gt;;
}

// RocksDbMemex implementation
#[async_trait]
impl Memex for RocksDbMemex {
    async fn store_node(&amp;self, node: &amp;MemoryNode) -> Result&lt;(), StorageError&gt; {
        // Delegate to existing implementation
        self.store_node(node).await
    }

    // ... implement all other methods by delegation

    async fn health_check(&amp;self) -> Result&lt;StorageHealth, StorageError&gt; {
        let inner = self.inner.read().await;

        // Get approximate counts from RocksDB
        let node_count = inner.db.property_int_value_cf(cf_nodes, "rocksdb.estimate-num-keys")
            .unwrap_or(Some(0)).unwrap_or(0);

        Ok(StorageHealth {
            is_healthy: true,
            node_count,
            edge_count: 0, // Estimate similarly
            storage_bytes: 0, // Get from disk stats
        })
    }
}

#[cfg(test)]
mod memex_tests:
  test_trait_object_safe()
  test_rocksdb_implements_memex()
  test_health_check()
</pseudo_code>

<files_to_create>
  <file path="crates/context-graph-storage/src/memex.rs">Memex trait definition and RocksDbMemex implementation</file>
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-storage/src/lib.rs">Add pub mod memex; and re-export Memex trait</file>
  <file path="crates/context-graph-storage/Cargo.toml">Add async-trait dependency</file>
</files_to_modify>

<validation_criteria>
  <criterion>Memex trait defined with all required methods</criterion>
  <criterion>All methods are async</criterion>
  <criterion>RocksDbMemex implements Memex</criterion>
  <criterion>Trait is object-safe (can create Box&lt;dyn Memex&gt;)</criterion>
  <criterion>Documentation explains abstraction purpose</criterion>
  <criterion>health_check() returns storage statistics</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage memex -- --nocapture</command>
  <command>cargo clippy --package context-graph-storage -- -D warnings</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Object Safety
To ensure object safety:
- No generic methods
- No `Self` in return position (except wrapped in Result/Option)
- No associated types with constraints
- async_trait handles the async-in-trait complexity

### Why a Trait?
The Memex trait enables:
1. **Testing**: In-memory implementation for fast unit tests
2. **Flexibility**: Future distributed storage backends
3. **Mocking**: Easy to mock for integration tests
4. **Dependency Injection**: Higher layers depend on trait, not concrete type

### async_trait Crate
Required because Rust doesn't yet have native async trait methods. The `#[async_trait]` macro transforms async methods to return `Pin<Box<dyn Future>>`.

---

*Task ID: TASK-M02-026*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
