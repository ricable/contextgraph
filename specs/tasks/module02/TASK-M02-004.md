# TASK-M02-004: Define ValidationError Enum

## Task Metadata
| Field | Value |
|-------|-------|
| Task ID | TASK-M02-004 |
| Status | ready |
| Layer | foundation |
| Module | module-02 |
| Sequence | 4 |
| Priority | high |
| Estimated Hours | 1.5 |
| Dependencies | None |
| Implements | TECH-CORE-002 Section 2.1 |

---

## CRITICAL CONTEXT FOR AI AGENT

**READ THIS FIRST**: You are implementing validation errors for the Context Graph knowledge system. The codebase uses a specific structure - do NOT create new files, ADD to existing ones.

### Current Project State (as of 2025-12-31)

**Completed Tasks:**
- TASK-M02-001: JohariQuadrant enum ✅
- TASK-M02-002: Modality enum ✅
- TASK-M02-003: NodeMetadata struct ✅

**Git Context:**
```
8353b4e feat: complete Modality enum implementation and verify TASK-M02-002
857b910 feat: complete JohariQuadrant implementation and verify TASK-M02-001
cf9b6c5 feat: extend JohariQuadrant API and add Module 02 task specifications
```

### Exact File Locations (VERIFIED)

| Purpose | Correct Path |
|---------|--------------|
| Target file for ValidationError | `crates/context-graph-core/src/types/memory_node.rs` |
| Types module | `crates/context-graph-core/src/types/mod.rs` |
| Main lib.rs | `crates/context-graph-core/src/lib.rs` |
| Existing error types | `crates/context-graph-core/src/error.rs` |
| Cargo.toml (has thiserror) | `crates/context-graph-core/Cargo.toml` |

**WARNING**: The types are in `src/types/memory_node.rs`, NOT `src/memory_node.rs`. The previous task spec was WRONG.

---

## What Exists Now

### In `types/memory_node.rs`:
```rust
// Imports at top
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;
use super::{JohariQuadrant, Modality};

// Type aliases
pub type NodeId = Uuid;
pub type EmbeddingVector = Vec<f32>;

// Structs (already implemented)
pub struct MemoryNode { ... }  // ~30 fields
pub struct NodeMetadata { ... }  // ~15 fields

// Tests at bottom
#[cfg(test)]
mod tests { ... }  // ~39 tests exist
```

### In `types/mod.rs`:
```rust
mod graph_edge;
mod johari;
mod memory_node;
mod nervous;
mod pulse;
mod utl;

pub use graph_edge::*;
pub use johari::*;
pub use memory_node::*;  // <-- This already exports everything from memory_node.rs
pub use nervous::*;
pub use pulse::*;
pub use utl::*;
```

### In `error.rs` (Generic CoreError - DO NOT MODIFY):
```rust
// There's already a generic ValidationError variant here:
#[derive(Debug, Error)]
pub enum CoreError {
    // ... other variants ...
    #[error("Validation error: {field} - {message}")]
    ValidationError { field: String, message: String },
    // ...
}
```

**IMPORTANT**: The `CoreError::ValidationError` is a DIFFERENT, generic error. Your task is to create a SPECIFIC `ValidationError` enum for MemoryNode validation in `memory_node.rs`. These are separate error types for different purposes.

---

## Exact Implementation Required

### Step 1: Add thiserror import to memory_node.rs

Add `use thiserror::Error;` to the imports section at the top of the file.

**Current imports:**
```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;
use super::{JohariQuadrant, Modality};
```

**After adding:**
```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use thiserror::Error;
use uuid::Uuid;
use super::{JohariQuadrant, Modality};
```

### Step 2: Add ValidationError enum after type aliases

Insert the ValidationError enum AFTER the type aliases (`NodeId` and `EmbeddingVector`) but BEFORE the `MemoryNode` struct.

**Insert this exact code:**
```rust
/// Errors that occur during MemoryNode validation.
///
/// Each variant provides specific context about what validation failed
/// and what values were involved, enabling actionable error messages.
///
/// # Constitution Compliance
/// - AP-009: Prevents NaN/Infinity by validating before storage
/// - Naming: PascalCase enum, snake_case fields
///
/// # Example
/// ```rust
/// use context_graph_core::types::ValidationError;
///
/// let error = ValidationError::InvalidEmbeddingDimension {
///     expected: 1536,
///     actual: 768,
/// };
/// assert!(error.to_string().contains("expected 1536"));
/// ```
#[derive(Debug, Clone, Error, PartialEq)]
pub enum ValidationError {
    /// Embedding vector has incorrect dimensions.
    /// Expected: 1536 (per constitution.yaml embedding spec)
    #[error("Invalid embedding dimension: expected {expected}, got {actual}")]
    InvalidEmbeddingDimension {
        /// Required dimension (1536)
        expected: usize,
        /// Actual dimension provided
        actual: usize,
    },

    /// A numeric field value is outside its valid range.
    /// Used for importance [0.0, 1.0], valence [-1.0, 1.0], etc.
    #[error("Field '{field}' value {value} is out of bounds [{min}, {max}]")]
    OutOfBounds {
        /// Name of the field that failed validation
        field: String,
        /// The invalid value provided
        value: f64,
        /// Minimum allowed value (inclusive)
        min: f64,
        /// Maximum allowed value (inclusive)
        max: f64,
    },

    /// Content exceeds maximum allowed size.
    /// Limit: 1MB (1,048,576 bytes) per constitution.yaml
    #[error("Content size {size} bytes exceeds maximum allowed {max_size} bytes")]
    ContentTooLarge {
        /// Actual content size in bytes
        size: usize,
        /// Maximum allowed size (1,048,576 bytes)
        max_size: usize,
    },

    /// Embedding vector is not normalized (magnitude should be ~1.0).
    /// Tolerance: magnitude must be in [0.99, 1.01]
    #[error("Embedding not normalized: magnitude is {magnitude:.6}, expected ~1.0")]
    EmbeddingNotNormalized {
        /// Actual magnitude of the embedding vector
        magnitude: f64,
    },
}
```

### Step 3: Add unit tests for ValidationError

Add these tests INSIDE the existing `#[cfg(test)] mod tests { ... }` block at the bottom of the file. Add them AFTER the existing tests (before the closing `}`).

**Insert these tests:**
```rust
    // =========================================================================
    // TASK-M02-004: ValidationError Tests
    // =========================================================================

    #[test]
    fn test_validation_error_invalid_embedding_dimension() {
        let error = ValidationError::InvalidEmbeddingDimension {
            expected: 1536,
            actual: 768,
        };
        let msg = error.to_string();

        assert!(msg.contains("expected 1536"), "Should show expected dimension");
        assert!(msg.contains("got 768"), "Should show actual dimension");
        assert!(msg.contains("Invalid embedding dimension"), "Should have correct prefix");
    }

    #[test]
    fn test_validation_error_out_of_bounds() {
        let error = ValidationError::OutOfBounds {
            field: "importance".to_string(),
            value: 1.5,
            min: 0.0,
            max: 1.0,
        };
        let msg = error.to_string();

        assert!(msg.contains("importance"), "Should show field name");
        assert!(msg.contains("1.5"), "Should show invalid value");
        assert!(msg.contains("[0, 1]"), "Should show valid range");
    }

    #[test]
    fn test_validation_error_content_too_large() {
        let error = ValidationError::ContentTooLarge {
            size: 2_000_000,
            max_size: 1_048_576,
        };
        let msg = error.to_string();

        assert!(msg.contains("2000000"), "Should show actual size");
        assert!(msg.contains("1048576"), "Should show max size");
        assert!(msg.contains("exceeds maximum"), "Should indicate overflow");
    }

    #[test]
    fn test_validation_error_embedding_not_normalized() {
        let error = ValidationError::EmbeddingNotNormalized {
            magnitude: 0.85,
        };
        let msg = error.to_string();

        assert!(msg.contains("0.850000"), "Should show magnitude with precision");
        assert!(msg.contains("not normalized"), "Should indicate normalization issue");
        assert!(msg.contains("expected ~1.0"), "Should show expected value");
    }

    #[test]
    fn test_validation_error_implements_std_error() {
        // Verify thiserror properly implements std::error::Error
        let error: Box<dyn std::error::Error> = Box::new(
            ValidationError::InvalidEmbeddingDimension {
                expected: 1536,
                actual: 0,
            }
        );

        // std::error::Error requires Display, which we get from thiserror
        let _ = error.to_string();
    }

    #[test]
    fn test_validation_error_clone() {
        let original = ValidationError::OutOfBounds {
            field: "test".to_string(),
            value: -0.5,
            min: 0.0,
            max: 1.0,
        };
        let cloned = original.clone();

        assert_eq!(original, cloned, "Clone must produce equal value");
    }

    #[test]
    fn test_validation_error_partial_eq() {
        let a = ValidationError::ContentTooLarge { size: 100, max_size: 50 };
        let b = ValidationError::ContentTooLarge { size: 100, max_size: 50 };
        let c = ValidationError::ContentTooLarge { size: 101, max_size: 50 };

        assert_eq!(a, b, "Same values should be equal");
        assert_ne!(a, c, "Different values should not be equal");
    }

    #[test]
    fn test_validation_error_debug_format() {
        let error = ValidationError::InvalidEmbeddingDimension {
            expected: 1536,
            actual: 512,
        };
        let debug_str = format!("{:?}", error);

        assert!(debug_str.contains("InvalidEmbeddingDimension"), "Debug should show variant");
        assert!(debug_str.contains("1536"), "Debug should show expected");
        assert!(debug_str.contains("512"), "Debug should show actual");
    }

    #[test]
    fn test_validation_error_out_of_bounds_negative_range() {
        // Test for valence which has range [-1.0, 1.0]
        let error = ValidationError::OutOfBounds {
            field: "emotional_valence".to_string(),
            value: -1.5,
            min: -1.0,
            max: 1.0,
        };
        let msg = error.to_string();

        assert!(msg.contains("-1.5"), "Should handle negative values");
        assert!(msg.contains("[-1, 1]"), "Should show negative range correctly");
    }

    #[test]
    fn test_validation_error_embedding_edge_magnitudes() {
        // Test edge cases for magnitude
        let too_small = ValidationError::EmbeddingNotNormalized { magnitude: 0.0 };
        let too_large = ValidationError::EmbeddingNotNormalized { magnitude: 100.0 };

        assert!(too_small.to_string().contains("0.000000"));
        assert!(too_large.to_string().contains("100.000000"));
    }
```

---

## Validation Commands (Run ALL)

```bash
# 1. Compile the crate
cargo build --package context-graph-core

# 2. Run ValidationError tests specifically
cargo test --package context-graph-core validation_error -- --nocapture

# 3. Run ALL tests to ensure no regressions
cargo test --package context-graph-core -- --nocapture

# 4. Check for clippy warnings (MUST be zero)
cargo clippy --package context-graph-core -- -D warnings

# 5. Verify the type is exported correctly
cargo doc --package context-graph-core --no-deps
```

---

## Full State Verification Protocol

### Source of Truth
The ValidationError enum will be stored in source code at:
`crates/context-graph-core/src/types/memory_node.rs`

After implementation, the type must be accessible as:
- `context_graph_core::types::ValidationError`
- `context_graph_core::types::memory_node::ValidationError`

### Execute & Inspect Verification

**After making changes, perform these reads to verify:**

1. **Verify enum exists in file:**
```bash
grep -A 30 "pub enum ValidationError" crates/context-graph-core/src/types/memory_node.rs
```
Expected: See all 4 variants with correct error messages.

2. **Verify export works:**
```bash
# Create a test file to verify export
cat > /tmp/test_export.rs << 'EOF'
use context_graph_core::types::ValidationError;
fn main() {
    let e = ValidationError::InvalidEmbeddingDimension { expected: 1536, actual: 0 };
    println!("{}", e);
}
EOF
```

3. **Verify test count increased:**
```bash
cargo test --package context-graph-core 2>&1 | grep "test result"
```
Expected: Test count should increase by 10 (from ~40 to ~50).

### Boundary & Edge Case Audit

**Simulate these 3 edge cases and print before/after state:**

1. **Zero-dimension embedding:**
```rust
let error = ValidationError::InvalidEmbeddingDimension { expected: 1536, actual: 0 };
println!("BEFORE: empty embedding vector");
println!("AFTER: {}", error);
// Expected: "Invalid embedding dimension: expected 1536, got 0"
```

2. **Exactly at boundary (should NOT trigger in real use):**
```rust
// importance=1.0 is valid, importance=1.0000001 is not
let error = ValidationError::OutOfBounds {
    field: "importance".to_string(),
    value: 1.0000001,
    min: 0.0,
    max: 1.0,
};
println!("BEFORE: value 1.0000001 for importance");
println!("AFTER: {}", error);
// Expected: "Field 'importance' value 1.0000001 is out of bounds [0, 1]"
```

3. **Maximum content size:**
```rust
let error = ValidationError::ContentTooLarge {
    size: usize::MAX,
    max_size: 1_048_576,
};
println!("BEFORE: content size usize::MAX");
println!("AFTER: {}", error);
// Expected: Should display the large number without panic
```

### Evidence of Success Log

After completing implementation, capture this evidence:

```bash
# Run and capture test results
cargo test --package context-graph-core validation_error 2>&1 | tee /tmp/m02-004-evidence.log

# Show test count
echo "=== TEST COUNT ===" >> /tmp/m02-004-evidence.log
cargo test --package context-graph-core 2>&1 | grep "test result" >> /tmp/m02-004-evidence.log

# Show clippy result
echo "=== CLIPPY ===" >> /tmp/m02-004-evidence.log
cargo clippy --package context-graph-core -- -D warnings 2>&1 | tail -5 >> /tmp/m02-004-evidence.log

# Show the enum in source
echo "=== ENUM IN SOURCE ===" >> /tmp/m02-004-evidence.log
grep -A 35 "pub enum ValidationError" crates/context-graph-core/src/types/memory_node.rs >> /tmp/m02-004-evidence.log

# Display evidence
cat /tmp/m02-004-evidence.log
```

---

## Anti-Patterns to Avoid (Constitution Compliance)

| Anti-Pattern | Rule | Violation Example | Correct Approach |
|--------------|------|-------------------|------------------|
| AP-001 | No unwrap() in prod | `.unwrap()` | Use `expect()` with context |
| AP-003 | No magic numbers | `1536` without constant | Define `const EMBEDDING_DIM: usize = 1536;` if needed |
| AP-009 | No NaN/Infinity | Accepting NaN magnitude | ValidationError prevents this |

---

## DO NOT

1. **DO NOT create a new file** - Add to existing `types/memory_node.rs`
2. **DO NOT modify `error.rs`** - That's a different error type for different purpose
3. **DO NOT modify `types/mod.rs`** - It already uses `pub use memory_node::*;` which will auto-export
4. **DO NOT delete existing code** - Only ADD the enum and tests
5. **DO NOT use mock data in tests** - Use real error values
6. **DO NOT create workarounds** - If it fails, let it fail fast with clear error

---

## Expected Final State

After completion:

```
crates/context-graph-core/src/types/memory_node.rs:
- Line ~1-8: Imports (including thiserror::Error)
- Line ~10-14: Type aliases (NodeId, EmbeddingVector)
- Line ~16-60: ValidationError enum (NEW)
- Line ~62-80: MemoryNode struct (unchanged)
- Line ~82-280: NodeMetadata struct + methods (unchanged)
- Line ~282-920+: Tests (existing + new validation tests)
```

Test count: Should go from ~39-40 tests to ~49-50 tests.

---

## Final Verification: sherlock-holmes Agent

**MANDATORY**: After completing ALL implementation steps above, you MUST spawn a sherlock-holmes subagent to perform forensic verification:

```
Task: "Forensic verification of TASK-M02-004 ValidationError implementation.

INVESTIGATE:
1. Does ValidationError enum exist at exact path: crates/context-graph-core/src/types/memory_node.rs
2. Does it have EXACTLY 4 variants: InvalidEmbeddingDimension, OutOfBounds, ContentTooLarge, EmbeddingNotNormalized
3. Does each variant have correct fields with correct types
4. Are there at least 10 new tests for ValidationError
5. Do ALL tests pass: cargo test --package context-graph-core
6. Are there ZERO clippy warnings: cargo clippy --package context-graph-core -- -D warnings
7. Is the type properly exported and accessible

EVIDENCE REQUIRED:
- Grep output showing enum definition
- Test output showing all validation_error tests pass
- Clippy output showing no warnings
- Actual test count comparison (before vs after)

FAIL CRITERIA - Task is NOT complete if:
- Any test fails
- Any clippy warning exists
- Enum is in wrong file
- Enum has wrong number of variants
- Any variant has wrong field types"
```

If sherlock-holmes finds ANY issues, fix them before marking task complete.

---

*Task ID: TASK-M02-004*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
*Last Updated: 2025-12-31*
