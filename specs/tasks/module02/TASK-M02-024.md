# TASK-M02-024: Implement Embedding Storage Operations

```xml
<task_spec id="TASK-M02-024" version="1.0">
<metadata>
  <title>Implement Embedding Storage Operations</title>
  <status>blocked</status>
  <layer>surface</layer>
  <module>module-02</module>
  <sequence>24</sequence>
  <priority>high</priority>
  <estimated_hours>2</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3: Storage specification</item>
    <item>REQ-CORE-005: Storage requirements</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-014</task_ref>
    <task_ref>TASK-M02-016</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements specialized operations for embedding vector storage and retrieval. While embeddings are stored as part of store_node(), these methods provide direct access for vector search preparation and batch operations. The focus is on efficient storage of 1536-dimensional vectors (~6KB each) and batch retrieval for similarity search.
</context>

<input_context_files>
  <file purpose="Serialization functions">crates/context-graph-storage/src/serialization.rs</file>
  <file purpose="RocksDB backend">crates/context-graph-storage/src/rocksdb_backend.rs</file>
  <file purpose="Column family definitions">crates/context-graph-storage/src/column_families.rs</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-014 (Bincode Serialization) completed</check>
  <check>TASK-M02-016 (RocksDB Backend Open/Close) completed</check>
  <check>embeddings column family accessible</check>
</prerequisites>

<scope>
  <in_scope>
    - store_embedding() - store embedding vector separately from node
    - get_embedding() - retrieve single embedding by node ID
    - batch_get_embeddings() - retrieve multiple embeddings in single call
    - Efficient raw f32 byte storage (no JSON overhead)
    - Memory-efficient batch operations
  </in_scope>
  <out_of_scope>
    - Vector similarity search (FAISS - future module)
    - Embedding generation (embedding pipeline - future module)
    - Node CRUD operations (TASK-M02-017)
    - Embedding normalization (already in MemoryNode validation)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/rocksdb_backend.rs">
impl RocksDbMemex {
    /// Stores an embedding vector for a node.
    ///
    /// This is typically called as part of store_node(), but can be
    /// used to update embeddings independently.
    ///
    /// # Performance
    /// ~6KB write for 1536-dimensional vector
    pub async fn store_embedding(
        &amp;self,
        node_id: &amp;NodeId,
        embedding: &amp;[f32],
    ) -> Result&lt;(), StorageError&gt;;

    /// Retrieves an embedding vector by node ID.
    ///
    /// # Errors
    /// Returns StorageError::NotFound if no embedding exists for the node
    pub async fn get_embedding(
        &amp;self,
        node_id: &amp;NodeId,
    ) -> Result&lt;Vec&lt;f32&gt;, StorageError&gt;;

    /// Retrieves multiple embeddings in a single batch operation.
    ///
    /// Returns a Vec of Option&lt;Vec&lt;f32&gt;&gt; in the same order as input IDs.
    /// None indicates the embedding was not found for that ID.
    ///
    /// More efficient than multiple get_embedding() calls.
    pub async fn batch_get_embeddings(
        &amp;self,
        node_ids: &amp;[NodeId],
    ) -> Result&lt;Vec&lt;Option&lt;Vec&lt;f32&gt;&gt;&gt;, StorageError&gt;;
}
    </signature>
  </signatures>

  <constraints>
    - Embedding storage must be efficient (~6KB for 1536D)
    - Batch operations must not load all embeddings into memory at once
    - Raw f32 bytes for efficiency (no serde overhead on vectors)
    - Must handle missing embeddings gracefully in batch operations
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage embedding passes all tests
    - Round-trip preserves exact f32 values
    - Batch retrieval returns correct order
    - Missing embeddings return None in batch
  </verification>
</definition_of_done>

<pseudo_code>
rocksdb_backend.rs (additions):

impl RocksDbMemex:
  async fn store_embedding(node_id, embedding):
    let inner = self.inner.read().await

    let key = node_id.as_bytes()
    let value = serialize_embedding(embedding)?

    inner.db.put_cf(cf_embeddings, key, value)?
    Ok(())

  async fn get_embedding(node_id):
    let inner = self.inner.read().await

    let key = node_id.as_bytes()
    let value = inner.db.get_cf(cf_embeddings, key)?
      .ok_or(StorageError::NotFound)?

    deserialize_embedding(&amp;value)

  async fn batch_get_embeddings(node_ids):
    let inner = self.inner.read().await

    // Use RocksDB multi_get for efficiency
    let keys: Vec&lt;_&gt; = node_ids.iter()
      .map(|id| (cf_embeddings, id.as_bytes()))
      .collect()

    let results = inner.db.multi_get_cf(keys)?

    let mut embeddings = Vec::with_capacity(node_ids.len())
    for result in results:
      match result:
        Ok(Some(bytes)) => embeddings.push(Some(deserialize_embedding(&amp;bytes)?)),
        Ok(None) => embeddings.push(None),
        Err(e) => return Err(StorageError::from(e)),

    Ok(embeddings)

serialization.rs:
  // Efficient embedding serialization
  fn serialize_embedding(embedding: &amp;[f32]) -> Result&lt;Vec&lt;u8&gt;, StorageError&gt;:
    // 4 bytes per f32, native endian
    let mut bytes = Vec::with_capacity(embedding.len() * 4)
    for &amp;value in embedding:
      bytes.extend_from_slice(&amp;value.to_le_bytes())
    Ok(bytes)

  fn deserialize_embedding(bytes: &amp;[u8]) -> Result&lt;Vec&lt;f32&gt;, StorageError&gt;:
    if bytes.len() % 4 != 0:
      return Err(StorageError::DeserializationFailed("Invalid embedding length"))

    let mut embedding = Vec::with_capacity(bytes.len() / 4)
    for chunk in bytes.chunks_exact(4):
      let value = f32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]])
      embedding.push(value)
    Ok(embedding)

#[cfg(test)]
mod embedding_tests:
  test_store_and_get_embedding()
  test_embedding_roundtrip_precision()
  test_batch_get_all_found()
  test_batch_get_some_missing()
  test_batch_get_empty()
  test_embedding_size_1536d()
</pseudo_code>

<files_to_create>
  <!-- No new files - additions to existing -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-storage/src/rocksdb_backend.rs">Add embedding methods</file>
  <file path="crates/context-graph-storage/src/serialization.rs">Optimize embedding serialization</file>
</files_to_modify>

<validation_criteria>
  <criterion>store_embedding() writes raw f32 bytes efficiently</criterion>
  <criterion>get_embedding() deserializes to Vec&lt;f32&gt; with exact precision</criterion>
  <criterion>batch_get_embeddings() retrieves multiple in single call</criterion>
  <criterion>Missing embeddings return None in batch operations</criterion>
  <criterion>1536D embedding size is approximately 6KB</criterion>
  <criterion>Memory-efficient: no unnecessary allocations</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage embedding -- --nocapture</command>
  <command>cargo clippy --package context-graph-storage -- -D warnings</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Embedding Size Calculation
- 1536 dimensions * 4 bytes/f32 = 6,144 bytes (~6KB)
- RocksDB LZ4 compression typically reduces this by 20-40%

### RocksDB multi_get_cf
Using `multi_get_cf` is more efficient than multiple `get_cf` calls because:
1. Single disk read operation
2. Better cache utilization
3. Reduced lock contention

### Float Precision
Using native little-endian encoding preserves exact f32 bit patterns. This is important for:
- Embedding comparison consistency
- Normalization verification
- FAISS index compatibility

---

*Task ID: TASK-M02-024*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
