# TASK-M02-028: Document Public API with Examples

```xml
<task_spec id="TASK-M02-028" version="1.0">
<metadata>
  <title>Document Public API with Examples</title>
  <status>blocked</status>
  <layer>surface</layer>
  <module>module-02</module>
  <sequence>28</sequence>
  <priority>medium</priority>
  <estimated_hours>3</estimated_hours>
  <implements>
    <item>TECH-CORE-002: Documentation requirements</item>
    <item>Constitution: doc_format specification</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-027</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task adds comprehensive documentation to all public types and methods in the context-graph-core and context-graph-storage crates. Documentation follows the project's doc_format standard from the constitution: "/// Brief\n/// # Args/Returns/Errors/Examples/Panics\n/// `Constraint: X < Yms`". The task also creates runnable example programs demonstrating key workflows.
</context>

<input_context_files>
  <file purpose="Core types requiring docs">crates/context-graph-core/src/lib.rs</file>
  <file purpose="Storage API requiring docs">crates/context-graph-storage/src/lib.rs</file>
  <file purpose="Constitution doc format">docs2/constitution.yaml</file>
  <file purpose="Integration tests as examples">crates/context-graph-storage/tests/integration_tests.rs</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-027 (Integration Tests) completed</check>
  <check>All public APIs are stable and finalized</check>
</prerequisites>

<scope>
  <in_scope>
    - Doc comments (///) on all public types, traits, methods, and functions
    - Doc tests that compile and pass (```rust examples)
    - Three runnable examples in examples/ directory
    - README.md for context-graph-core crate
    - README.md for context-graph-storage crate
    - Performance constraints documented where applicable
  </in_scope>
  <out_of_scope>
    - Architecture documentation (separate docs/ files)
    - User guide or tutorial (future task)
    - Changelog generation (CI/CD task)
    - API versioning policy (architectural decision)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-core/examples/basic_storage.rs">
//! Basic Storage Example
//!
//! Demonstrates creating a MemoryNode, storing it in RocksDbMemex,
//! and retrieving it by ID.
//!
//! Run with: cargo run --example basic_storage

use context_graph_core::{MemoryNode, JohariQuadrant, NodeMetadata};
use context_graph_storage::{RocksDbMemex, Memex};
use tempfile::TempDir;

#[tokio::main]
async fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a temporary directory for the database
    let temp_dir = TempDir::new()?;

    // Open the Memex storage
    let memex = RocksDbMemex::open(temp_dir.path()).await?;

    // Create a memory node
    let mut node = MemoryNode::new(
        "Rust is a systems programming language focused on safety.",
        generate_embedding(),  // 1536D normalized embedding
    );
    node.quadrant = JohariQuadrant::Open;
    node.importance = 0.8;
    node.metadata.add_tag("programming");
    node.metadata.add_tag("rust");

    // Validate before storing
    node.validate()?;

    // Store the node
    memex.store_node(&amp;node).await?;
    println!("Stored node with ID: {}", node.id);

    // Retrieve by ID
    let retrieved = memex.get_node(&amp;node.id).await?;
    println!("Retrieved: {}", retrieved.content);
    println!("Quadrant: {:?}", retrieved.quadrant);
    println!("Tags: {:?}", retrieved.metadata.tags);

    // Query by quadrant
    let open_nodes = memex.query_by_quadrant(JohariQuadrant::Open, Some(10)).await?;
    println!("Found {} nodes in Open quadrant", open_nodes.len());

    Ok(())
}

fn generate_embedding() -> Vec&lt;f32&gt; {
    // In production, use actual embedding model
    let mut embedding = vec![0.01; 1536];
    // Normalize to unit length
    let norm: f32 = embedding.iter().map(|x| x * x).sum::&lt;f32&gt;().sqrt();
    embedding.iter_mut().for_each(|x| *x /= norm);
    embedding
}
    </signature>

    <signature file="crates/context-graph-core/examples/marblestone_edges.rs">
//! Marblestone Edge Example
//!
//! Demonstrates creating edges with neurotransmitter weights
//! and domain-specific modulation.
//!
//! Run with: cargo run --example marblestone_edges

use context_graph_core::{
    MemoryNode, GraphEdge, EdgeType, Domain,
    NeurotransmitterWeights, JohariQuadrant,
};
use context_graph_storage::{RocksDbMemex, Memex};
use tempfile::TempDir;

#[tokio::main]
async fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let temp_dir = TempDir::new()?;
    let memex = RocksDbMemex::open(temp_dir.path()).await?;

    // Create two concept nodes
    let async_node = MemoryNode::new("async/await pattern", generate_embedding());
    let tokio_node = MemoryNode::new("Tokio runtime", generate_embedding());

    memex.store_node(&amp;async_node).await?;
    memex.store_node(&amp;tokio_node).await?;

    // Create edge with Code domain neurotransmitter weights
    let edge = GraphEdge::new(
        async_node.id,
        tokio_node.id,
        EdgeType::Semantic,
        Domain::Code,
    );

    // Check neurotransmitter weights
    let nt = edge.neurotransmitter_weights.as_ref().unwrap();
    println!("Code Domain NT Weights:");
    println!("  Excitatory: {}", nt.excitatory);
    println!("  Inhibitory: {}", nt.inhibitory);
    println!("  Modulatory: {}", nt.modulatory);

    // Compute modulated weight
    let base_weight = 0.7;
    let modulated = edge.get_modulated_weight(base_weight);
    println!("Base weight: {} -> Modulated: {:.3}", base_weight, modulated);

    // Apply steering reward
    let mut edge = edge;
    edge.apply_steering_reward(0.5);
    println!("After steering reward: {:.3}", edge.steering_reward);

    // Store the edge
    memex.store_edge(&amp;edge).await?;

    // Retrieve edges from source
    let edges = memex.get_edges_from(&amp;async_node.id).await?;
    println!("Found {} outgoing edges", edges.len());

    Ok(())
}

fn generate_embedding() -> Vec&lt;f32&gt; {
    let mut embedding = vec![0.01; 1536];
    let norm: f32 = embedding.iter().map(|x| x * x).sum::&lt;f32&gt;().sqrt();
    embedding.iter_mut().for_each(|x| *x /= norm);
    embedding
}
    </signature>

    <signature file="crates/context-graph-core/examples/cognitive_pulse.rs">
//! Cognitive Pulse Example
//!
//! Demonstrates creating and interpreting CognitivePulse
//! for system state monitoring and action suggestions.
//!
//! Run with: cargo run --example cognitive_pulse

use context_graph_core::{
    CognitivePulse, EmotionalState, SuggestedAction,
};

fn main() {
    println!("=== Cognitive Pulse Examples ===\n");

    // Example 1: Crisis state (high entropy, low coherence)
    let crisis = CognitivePulse::new(
        0.85,  // entropy: high (unstable)
        0.25,  // coherence: low (fragmented)
        0.5,   // curiosity
        0.4,   // confidence
        EmotionalState::Stressed,
    );
    println!("Crisis State:");
    println!("  Entropy: {:.2}", crisis.entropy);
    println!("  Coherence: {:.2}", crisis.coherence);
    println!("  Suggested Action: {:?}", crisis.suggested_action);
    assert_eq!(crisis.suggested_action, SuggestedAction::Stabilize);

    // Example 2: Ready state (low entropy, high coherence)
    let ready = CognitivePulse::new(
        0.2,   // entropy: low (stable)
        0.85,  // coherence: high (integrated)
        0.5,   // curiosity
        0.9,   // confidence
        EmotionalState::Focused,
    );
    println!("\nReady State:");
    println!("  Entropy: {:.2}", ready.entropy);
    println!("  Coherence: {:.2}", ready.coherence);
    println!("  Suggested Action: {:?}", ready.suggested_action);
    assert_eq!(ready.suggested_action, SuggestedAction::Ready);

    // Example 3: Exploration triggered by curiosity
    let curious = CognitivePulse::new(
        0.5,   // entropy: moderate
        0.6,   // coherence: moderate
        0.85,  // curiosity: high!
        0.7,   // confidence
        EmotionalState::Curious,
    );
    println!("\nCurious State:");
    println!("  Curiosity: {:.2}", curious.curiosity_score);
    println!("  Suggested Action: {:?}", curious.suggested_action);
    assert_eq!(curious.suggested_action, SuggestedAction::Explore);

    // Example 4: Blending pulses
    let blended = crisis.blend(&amp;ready, 0.5);
    println!("\nBlended State (50/50 crisis + ready):");
    println!("  Entropy: {:.2}", blended.entropy);
    println!("  Coherence: {:.2}", blended.coherence);
    println!("  Suggested Action: {:?}", blended.suggested_action);

    // Example 5: Update pulse dynamically
    let mut dynamic = CognitivePulse::default();
    println!("\nDynamic Update:");
    println!("  Initial: entropy={:.2}, coherence={:.2}, action={:?}",
        dynamic.entropy, dynamic.coherence, dynamic.suggested_action);

    dynamic.update(0.3, -0.2);  // increase entropy, decrease coherence
    println!("  After update(+0.3, -0.2): entropy={:.2}, coherence={:.2}, action={:?}",
        dynamic.entropy, dynamic.coherence, dynamic.suggested_action);

    // Example 6: JSON serialization
    let json = ready.to_json().unwrap();
    println!("\nJSON Output:\n{}", json);
}
    </signature>

    <signature file="crates/context-graph-core/README.md">
# context-graph-core

Core types and domain logic for the Ultimate Context Graph system.

## Overview

This crate provides the foundational data structures for a bio-nervous memory system based on the Unified Theory of Learning (UTL). It includes:

- **MemoryNode**: Core knowledge node with embedding, importance, and metadata
- **GraphEdge**: Edges with Marblestone neurotransmitter weights
- **JohariQuadrant**: Four-quadrant awareness classification
- **CognitivePulse**: System cognitive state metrics and action suggestions
- **NeurotransmitterWeights**: Domain-specific edge weight modulation

## Quick Start

```rust
use context_graph_core::{MemoryNode, JohariQuadrant, CognitivePulse};

// Create a memory node
let mut node = MemoryNode::new("Important concept", embedding);
node.quadrant = JohariQuadrant::Open;
node.importance = 0.85;

// Check system cognitive state
let pulse = CognitivePulse::new(0.3, 0.7, 0.5, 0.8, EmotionalState::Focused);
match pulse.suggested_action {
    SuggestedAction::Ready => println!("System is ready for queries"),
    SuggestedAction::Stabilize => println!("System needs stabilization"),
    _ => {}
}
```

## Modules

- `memory_node` - MemoryNode struct and validation
- `marblestone` - GraphEdge, NeurotransmitterWeights, Domain, EdgeType
- `johari` - JohariQuadrant, JohariTransition, TransitionTrigger
- `metadata` - NodeMetadata, Modality
- `pulse` - CognitivePulse, EmotionalState, SuggestedAction

## Examples

See the `examples/` directory:
- `basic_storage.rs` - Simple node creation and retrieval
- `marblestone_edges.rs` - Edges with neurotransmitter weights
- `cognitive_pulse.rs` - Pulse generation and interpretation

## Performance Characteristics

| Operation | Target Latency |
|-----------|---------------|
| MemoryNode creation | <100us |
| Embedding validation | <50us |
| CognitivePulse computation | <10us |
| GraphEdge modulated weight | <1us |

## License

MIT OR Apache-2.0
    </signature>

    <signature file="crates/context-graph-storage/README.md">
# context-graph-storage

RocksDB-based storage layer for the Ultimate Context Graph system.

## Overview

This crate provides persistent storage for memory nodes and graph edges using RocksDB. Key features:

- **RocksDbMemex**: Main storage backend implementing the Memex trait
- **Column Families**: 12 optimized CFs for different data types
- **Secondary Indexes**: Query by quadrant, tag, source, time range
- **Async API**: Fully async with tokio integration

## Quick Start

```rust
use context_graph_storage::{RocksDbMemex, Memex};
use context_graph_core::MemoryNode;

#[tokio::main]
async fn main() -> Result&lt;(), StorageError&gt; {
    // Open database
    let memex = RocksDbMemex::open("./data").await?;

    // Store a node
    let node = MemoryNode::new("content", embedding);
    memex.store_node(&amp;node).await?;

    // Retrieve by ID
    let retrieved = memex.get_node(&amp;node.id).await?;

    // Query by quadrant
    let nodes = memex.query_by_quadrant(
        JohariQuadrant::Open,
        Some(100)
    ).await?;

    Ok(())
}
```

## Column Families

| CF Name | Purpose | Optimization |
|---------|---------|-------------|
| nodes | Primary node storage | 256MB cache, bloom filter |
| edges | Graph edge storage | Prefix extractor for range scans |
| embeddings | 1536D vectors | LZ4 compression |
| johari_* | Quadrant indexes | Prefix scan |
| temporal | Time-based index | Range scan |
| tags | Tag index | Prefix scan |
| sources | Source index | Prefix scan |

## Performance Targets

| Operation | P99 Latency |
|-----------|------------|
| store_node | <1ms |
| get_node | <500us |
| query_by_quadrant | <5ms |
| batch_get_embeddings (100) | <10ms |

## Error Handling

```rust
match memex.get_node(&amp;id).await {
    Ok(node) => process(node),
    Err(StorageError::NotFound { .. }) => create_new(),
    Err(e) => return Err(e.into()),
}
```

## License

MIT OR Apache-2.0
    </signature>
  </signatures>

  <constraints>
    - All public items must have /// doc comments
    - Doc comments must follow constitution format: Brief + sections
    - Examples must compile (verified by cargo test --doc)
    - Performance constraints documented with `Constraint:` syntax
    - README files must include Quick Start and feature overview
    - No private implementation details exposed in docs
    - Examples must use tempfile for database paths (no hardcoded paths)
  </constraints>

  <verification>
    - cargo doc --package context-graph-core --no-deps generates clean docs
    - cargo doc --package context-graph-storage --no-deps generates clean docs
    - cargo test --doc --package context-graph-core passes
    - cargo test --doc --package context-graph-storage passes
    - cargo run --example basic_storage succeeds
    - cargo run --example marblestone_edges succeeds
    - cargo run --example cognitive_pulse succeeds
    - No warnings in doc generation
  </verification>
</definition_of_done>

<pseudo_code>
Documentation Pattern (constitution format):

/// Brief one-line description.
///
/// More detailed explanation if needed, covering the purpose
/// and context of this item.
///
/// # Arguments
///
/// * `arg1` - Description of first argument
/// * `arg2` - Description of second argument
///
/// # Returns
///
/// Description of return value
///
/// # Errors
///
/// * `ErrorType` - When this error occurs
///
/// # Examples
///
/// ```rust
/// let result = function(arg1, arg2)?;
/// assert!(result.is_valid());
/// ```
///
/// # Panics
///
/// Describes when this function panics (if ever)
///
/// `Constraint: latency < 1ms`
pub fn function(arg1: Type1, arg2: Type2) -> Result&lt;Output, Error&gt;

For MemoryNode (example):

/// A node in the knowledge graph representing a discrete memory unit.
///
/// MemoryNode contains content, embedding, metadata, and cognitive properties
/// like importance and emotional valence. Each node belongs to a Johari
/// quadrant indicating awareness state.
///
/// # Performance
///
/// - Average size: ~6.5KB (dominated by 1536D embedding)
/// - Creation: <100us
/// - Validation: <50us
///
/// # Examples
///
/// ```rust
/// use context_graph_core::{MemoryNode, JohariQuadrant};
///
/// let mut node = MemoryNode::new("Concept definition", embedding);
/// node.quadrant = JohariQuadrant::Open;
/// node.importance = 0.8;
/// node.validate()?;
/// ```
pub struct MemoryNode { ... }

For store_node (example):

/// Stores a memory node to persistent storage.
///
/// This operation atomically writes to multiple column families:
/// - nodes: Primary node data
/// - embeddings: Embedding vector
/// - johari_*: Quadrant index
/// - temporal: Time index
/// - tags: Tag indexes
/// - sources: Source index
///
/// # Arguments
///
/// * `node` - The MemoryNode to store (must pass validation)
///
/// # Errors
///
/// * `StorageError::ValidationFailed` - Node fails validation
/// * `StorageError::WriteFailed` - Database write error
///
/// # Examples
///
/// ```rust
/// let node = MemoryNode::new("content", embedding);
/// memex.store_node(&amp;node).await?;
/// ```
///
/// `Constraint: latency < 1ms`
pub async fn store_node(&amp;self, node: &amp;MemoryNode) -> Result&lt;(), StorageError&gt;
</pseudo_code>

<files_to_create>
  <file path="crates/context-graph-core/examples/basic_storage.rs">Simple node creation and retrieval example</file>
  <file path="crates/context-graph-core/examples/marblestone_edges.rs">Edge creation with NT weights example</file>
  <file path="crates/context-graph-core/examples/cognitive_pulse.rs">Pulse generation and interpretation example</file>
  <file path="crates/context-graph-core/README.md">Crate-level documentation</file>
  <file path="crates/context-graph-storage/README.md">Crate-level documentation</file>
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-core/src/lib.rs">Add module-level documentation</file>
  <file path="crates/context-graph-core/src/memory_node.rs">Add doc comments to MemoryNode and methods</file>
  <file path="crates/context-graph-core/src/marblestone.rs">Add doc comments to all Marblestone types</file>
  <file path="crates/context-graph-core/src/johari.rs">Add doc comments to JohariQuadrant and transitions</file>
  <file path="crates/context-graph-core/src/metadata.rs">Add doc comments to NodeMetadata and Modality</file>
  <file path="crates/context-graph-core/src/pulse.rs">Add doc comments to CognitivePulse types</file>
  <file path="crates/context-graph-storage/src/lib.rs">Add module-level documentation</file>
  <file path="crates/context-graph-storage/src/rocksdb_backend.rs">Add doc comments to RocksDbMemex methods</file>
  <file path="crates/context-graph-storage/src/memex.rs">Add doc comments to Memex trait</file>
  <file path="crates/context-graph-storage/src/indexes.rs">Add doc comments to index operations</file>
  <file path="crates/context-graph-storage/Cargo.toml">Add [[example]] sections</file>
</files_to_modify>

<validation_criteria>
  <criterion>All public items have /// doc comments following constitution format</criterion>
  <criterion>Doc tests compile and pass (cargo test --doc)</criterion>
  <criterion>Three runnable examples in examples/ directory</criterion>
  <criterion>README.md exists for both crates with Quick Start</criterion>
  <criterion>Performance constraints documented with Constraint: syntax</criterion>
  <criterion>cargo doc generates clean HTML without warnings</criterion>
  <criterion>Examples demonstrate key workflows: storage, edges, pulse</criterion>
  <criterion>Error handling documented in # Errors sections</criterion>
</validation_criteria>

<test_commands>
  <command>cargo doc --package context-graph-core --no-deps</command>
  <command>cargo doc --package context-graph-storage --no-deps</command>
  <command>cargo test --doc --package context-graph-core</command>
  <command>cargo test --doc --package context-graph-storage</command>
  <command>cargo run --package context-graph-core --example basic_storage</command>
  <command>cargo run --package context-graph-core --example marblestone_edges</command>
  <command>cargo run --package context-graph-core --example cognitive_pulse</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Doc Comment Format
Following the constitution's `doc_format` specification:
```
/// Brief
/// # Args/Returns/Errors/Examples/Panics
/// `Constraint: X < Yms`
```

### Example Considerations
- All examples use `tempfile::TempDir` for database isolation
- Examples include assertions to serve as additional tests
- `cognitive_pulse.rs` is sync (no database needed)
- Other examples require async runtime

### Performance Documentation
Every method with a latency target should include:
```rust
/// `Constraint: latency < 1ms`
```

This makes performance requirements visible in the generated documentation.

---

*Task ID: TASK-M02-028*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
