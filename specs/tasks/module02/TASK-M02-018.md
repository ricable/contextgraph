# TASK-M02-018: Implement Edge CRUD Operations

```xml
<task_spec id="TASK-M02-018" version="1.0">
<metadata>
  <title>Implement Edge CRUD Operations</title>
  <status>blocked</status>
  <layer>logic</layer>
  <module>module-02</module>
  <sequence>18</sequence>
  <priority>high</priority>
  <estimated_hours>3</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3.2: RocksDB backend specification</item>
    <item>Marblestone Integration Spec: Edge storage with NT weights</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-011</task_ref>
    <task_ref>TASK-M02-017</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements CRUD operations for GraphEdge storage, including efficient lookups for edges by source and target nodes. The implementation uses composite keys (source_id:target_id:edge_type) for efficient prefix scanning and must preserve all Marblestone fields (neurotransmitter weights, steering_reward, is_amortized_shortcut).
</context>

<input_context_files>
  <file purpose="GraphEdge struct definition">crates/context-graph-core/src/marblestone.rs</file>
  <file purpose="RocksDB backend with node CRUD">crates/context-graph-storage/src/rocksdb_backend.rs</file>
  <file purpose="Serialization functions">crates/context-graph-storage/src/serialization.rs</file>
  <file purpose="Column family definitions">crates/context-graph-storage/src/column_families.rs</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-011 (GraphEdge Methods) completed</check>
  <check>TASK-M02-017 (Node CRUD Operations) completed</check>
  <check>GraphEdge serialization is implemented</check>
  <check>edges column family is available</check>
</prerequisites>

<scope>
  <in_scope>
    - store_edge() method - store GraphEdge with composite key
    - get_edge() method - retrieve edge by source, target, and type
    - update_edge() method - update existing edge
    - delete_edge() method - remove edge
    - get_edges_from() method - get all outgoing edges from a node
    - get_edges_to() method - get all incoming edges to a node
    - Composite key format: source_id:target_id:edge_type
    - Prefix scan for efficient edge queries
    - Marblestone field preservation
  </in_scope>
  <out_of_scope>
    - Node CRUD operations (TASK-M02-017)
    - Edge weight calculations (already in TASK-M02-011)
    - Graph traversal algorithms (future module)
    - Memex trait abstraction (TASK-M02-026)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/rocksdb_backend.rs">
impl RocksDbMemex {
    /// Stores a GraphEdge with composite key for efficient lookups.
    ///
    /// Key format: source_id:target_id:edge_type
    /// Preserves all Marblestone fields (NT weights, steering_reward, is_amortized_shortcut)
    pub async fn store_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt;;

    /// Retrieves a GraphEdge by source, target, and edge type.
    pub async fn get_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;GraphEdge, StorageError&gt;;

    /// Updates an existing GraphEdge.
    pub async fn update_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt;;

    /// Deletes a GraphEdge.
    pub async fn delete_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;(), StorageError&gt;;

    /// Gets all outgoing edges from a source node.
    /// Uses prefix scan for efficiency.
    pub async fn get_edges_from(&amp;self, source_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;

    /// Gets all incoming edges to a target node.
    /// Requires full scan with filter (reverse index not implemented here).
    pub async fn get_edges_to(&amp;self, target_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;
}
    </signature>
  </signatures>

  <constraints>
    - Composite key format must be consistent: source_id:target_id:edge_type
    - UUID bytes must use big-endian for proper sorting
    - Prefix scan must use RocksDB iterator with prefix extractor
    - All Marblestone fields must be preserved through serialization
    - get_edges_to() may be slower than get_edges_from() (no reverse index in this task)
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage edge passes all tests
    - Store/get round-trip preserves all GraphEdge fields including Marblestone
    - get_edges_from() correctly uses prefix scan
    - Multiple edges between same nodes with different types work correctly
  </verification>
</definition_of_done>

<pseudo_code>
rocksdb_backend.rs (additions):

// Key formatting for edges
fn format_edge_key(source_id: &amp;NodeId, target_id: &amp;NodeId, edge_type: EdgeType) -> Vec&lt;u8&gt;:
  // Format: source_uuid_bytes:target_uuid_bytes:edge_type_byte
  let mut key = Vec::with_capacity(33)  // 16 + 16 + 1
  key.extend_from_slice(source_id.as_bytes())
  key.extend_from_slice(target_id.as_bytes())
  key.push(edge_type as u8)
  key

fn format_edge_prefix(source_id: &amp;NodeId) -> Vec&lt;u8&gt;:
  // Prefix is just the source UUID bytes
  source_id.as_bytes().to_vec()

impl RocksDbMemex:
  async fn store_edge(edge: &amp;GraphEdge):
    let inner = self.inner.read().await

    let key = format_edge_key(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type)
    let value = serialize_edge(edge)?

    inner.db.put_cf(cf_edges, key, value)?
    Ok(())

  async fn get_edge(source_id, target_id, edge_type):
    let inner = self.inner.read().await

    let key = format_edge_key(source_id, target_id, edge_type)
    let value = inner.db.get_cf(cf_edges, key)?
      .ok_or(StorageError::NotFound)?

    deserialize_edge(&amp;value)

  async fn update_edge(edge: &amp;GraphEdge):
    // Same as store - RocksDB overwrites existing keys
    self.store_edge(edge).await

  async fn delete_edge(source_id, target_id, edge_type):
    let inner = self.inner.read().await
    let key = format_edge_key(source_id, target_id, edge_type)
    inner.db.delete_cf(cf_edges, key)?
    Ok(())

  async fn get_edges_from(source_id: &amp;NodeId):
    let inner = self.inner.read().await

    let prefix = format_edge_prefix(source_id)
    let mut edges = Vec::new()

    // Use prefix iterator
    let iter = inner.db.prefix_iterator_cf(cf_edges, &amp;prefix)

    for item in iter:
      let (key, value) = item?

      // Check that key still starts with our prefix
      if !key.starts_with(&amp;prefix):
        break

      let edge = deserialize_edge(&amp;value)?
      edges.push(edge)

    Ok(edges)

  async fn get_edges_to(target_id: &amp;NodeId):
    let inner = self.inner.read().await

    // Full scan with filter (no reverse index)
    // This is less efficient but correct
    let mut edges = Vec::new()

    let iter = inner.db.iterator_cf(cf_edges, IteratorMode::Start)

    for item in iter:
      let (key, value) = item?
      let edge = deserialize_edge(&amp;value)?

      if &amp;edge.target_id == target_id:
        edges.push(edge)

    Ok(edges)

#[cfg(test)]
mod edge_tests:
  test_store_and_get_edge()
  test_store_edge_with_marblestone_fields()
  test_update_edge()
  test_delete_edge()
  test_get_edges_from_prefix_scan()
  test_get_edges_to_full_scan()
  test_multiple_edge_types_same_nodes()
  test_edge_roundtrip_preserves_nt_weights()
  test_edge_roundtrip_preserves_steering_reward()
</pseudo_code>

<files_to_create>
  <!-- No new files - additions to existing -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-storage/src/rocksdb_backend.rs">Add edge CRUD methods</file>
  <file path="crates/context-graph-storage/src/serialization.rs">Ensure serialize_edge/deserialize_edge handle all Marblestone fields</file>
</files_to_modify>

<validation_criteria>
  <criterion>store_edge() writes to edges CF with composite key</criterion>
  <criterion>get_edge() retrieves edge by source, target, and type</criterion>
  <criterion>get_edges_from() efficiently retrieves all outgoing edges using prefix scan</criterion>
  <criterion>get_edges_to() retrieves all incoming edges (full scan with filter)</criterion>
  <criterion>Marblestone fields (NT weights, steering_reward, is_amortized_shortcut) preserved</criterion>
  <criterion>Multiple edges between same nodes with different types work correctly</criterion>
  <criterion>Prefix scan correctly terminates when prefix no longer matches</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage edge -- --nocapture</command>
  <command>cargo clippy --package context-graph-storage -- -D warnings</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Composite Key Design
The key format `source_id:target_id:edge_type` enables:
1. Efficient prefix scans for all edges from a source node
2. Unique identification of edges (same nodes can have multiple edge types)
3. Proper byte ordering for RocksDB iteration

### Marblestone Field Preservation
The following fields must survive serialization round-trip:
- `neurotransmitter_weights` (excitatory, inhibitory, modulatory)
- `steering_reward` (f32 in [-1, 1])
- `is_amortized_shortcut` (bool)
- `traversal_count` (u32)
- `domain` (Domain enum)

### Future Optimization: Reverse Index
`get_edges_to()` currently uses a full scan. A future optimization could add a reverse index column family for O(n) incoming edge lookups where n is the number of incoming edges.

---

*Task ID: TASK-M02-018*
*Module: 02 - Core Infrastructure*
*Layer: Logic*
