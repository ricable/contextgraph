# TASK-M02-012: Implement Johari Transition Logic

```xml
<task_spec id="TASK-M02-012" version="2.0">
<metadata>
  <title>Implement Johari Transition Logic</title>
  <status>complete</status>
  <layer>foundation</layer>
  <module>module-02</module>
  <sequence>12</sequence>
  <priority>high</priority>
  <estimated_hours>2</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 2.2: Johari transition specification</item>
  </implements>
  <depends_on>
    <task_ref status="COMPLETE">TASK-M02-001</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
  <last_audit>2025-12-31</last_audit>
</metadata>

<context>
This task implements the state machine logic for transitioning MemoryNodes between Johari quadrants. The JohariQuadrant enum already exists in johari.rs (verified COMPLETE in TASK-M02-001). This task ADDS:
1. TransitionTrigger enum (6 variants)
2. JohariTransition struct (from, to, trigger, timestamp)
3. Methods on JohariQuadrant for transition validation

The Johari Window model classifies knowledge by self/other awareness. Transitions occur when:
- User shares private info (Hidden→Open)
- User privatizes public info (Open→Hidden)
- Agent recognizes blind spots (Blind→Open/Hidden)
- Dream/pattern discovery surfaces unknowns (Unknown→Open/Hidden/Blind)
</context>

<codebase_state audit_date="2025-12-31">
  <verified_complete>
    <task id="TASK-M02-001">JohariQuadrant enum with 4 variants (Open, Hidden, Blind, Unknown) - VERIFIED at line 24-33 of johari.rs</task>
    <task id="TASK-M02-002">Modality enum - in same file johari.rs lines 186-200</task>
  </verified_complete>
  <file path="crates/context-graph-core/src/types/johari.rs">
    <status>EXISTS - 773 lines, contains JohariQuadrant + Modality + tests</status>
    <imports_present>serde::{Deserialize, Serialize}, std::fmt, std::str::FromStr</imports_present>
    <imports_needed>chrono::{DateTime, Utc}</imports_needed>
    <insertion_point>After line 127 (end of JohariQuadrant impl block), before line 129 (impl Default)</insertion_point>
  </file>
  <file path="crates/context-graph-core/src/lib.rs">
    <status>EXISTS - 32 lines, exports types module</status>
    <note>types/mod.rs already has `pub use johari::*` so new types auto-export</note>
  </file>
  <file path="crates/context-graph-core/Cargo.toml">
    <status>chrono.workspace = true ALREADY PRESENT at line 18</status>
  </file>
  <build_status>cargo build passes - 0 errors, 0 warnings</build_status>
  <test_status>cargo test passes - 24 doc tests + all unit tests</test_status>
</codebase_state>

<input_context_files>
  <file path="crates/context-graph-core/src/types/johari.rs" purpose="Add TransitionTrigger enum, JohariTransition struct, and transition methods AFTER JohariQuadrant impl block (line 127)"/>
  <file path="docs2/constitution.yaml" purpose="UTL johari mapping at lines 159-163"/>
  <file path="specs/technical/module-02-core-infrastructure.md" purpose="Canonical transition spec at lines 469-546"/>
</input_context_files>

<prerequisites>
  <check status="VERIFIED">TASK-M02-001 (JohariQuadrant enum) COMPLETE - enum at johari.rs:24-33</check>
  <check status="VERIFIED">chrono dependency available via workspace</check>
  <check status="VERIFIED">serde Serialize/Deserialize derives work on existing enums</check>
</prerequisites>

<scope>
  <in_scope>
    <item>TransitionTrigger enum with exactly 6 variants (ExplicitShare, SelfRecognition, PatternDiscovery, Privatize, ExternalObservation, DreamConsolidation)</item>
    <item>JohariTransition struct with fields: from (JohariQuadrant), to (JohariQuadrant), trigger (TransitionTrigger), timestamp (DateTime&lt;Utc&gt;)</item>
    <item>JohariQuadrant::valid_transitions(&amp;self) method returning static slice</item>
    <item>JohariQuadrant::can_transition_to(&amp;self, target) method</item>
    <item>JohariQuadrant::transition_to(&amp;self, target, trigger) -> Result method</item>
    <item>JohariTransition::new(from, to, trigger) constructor with Utc::now() timestamp</item>
    <item>TransitionTrigger::description(&amp;self) method</item>
    <item>Unit tests for ALL transition rules (minimum 10 tests)</item>
  </in_scope>
  <out_of_scope>
    <item>Automatic transition detection logic (Module 05 UTL Integration)</item>
    <item>Dream-based transition triggering (Module 09 Dream Layer)</item>
    <item>Persistence of transition history (Module 02 Storage tasks)</item>
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-core/src/types/johari.rs" insert_after_line="127">
use chrono::{DateTime, Utc};

/// Triggers that cause Johari quadrant transitions.
///
/// Each trigger represents a specific event that moves knowledge
/// between quadrants in the Johari Window model.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TransitionTrigger {
    /// User explicitly shares hidden knowledge (Hidden → Open).
    ExplicitShare,
    /// Agent recognizes pattern in blind spot (Blind → Open/Hidden).
    SelfRecognition,
    /// Dream consolidation discovers new patterns (Unknown → Open).
    PatternDiscovery,
    /// User marks knowledge as private (Open → Hidden).
    Privatize,
    /// External observation reveals blind spot (Unknown → Blind).
    ExternalObservation,
    /// Dream consolidation surfaces unknown knowledge (Unknown → Open/Hidden).
    DreamConsolidation,
}

impl TransitionTrigger {
    /// Returns a human-readable description of this trigger.
    pub fn description(&amp;self) -> &amp;'static str {
        match self {
            Self::ExplicitShare => "User explicitly shares hidden knowledge",
            Self::SelfRecognition => "Agent recognizes pattern in blind spot",
            Self::PatternDiscovery => "Dream consolidation discovers new patterns",
            Self::Privatize => "User marks knowledge as private",
            Self::ExternalObservation => "External observation reveals blind spot",
            Self::DreamConsolidation => "Dream consolidation surfaces unknown knowledge",
        }
    }

    /// Returns all trigger variants as a fixed-size array.
    pub fn all() -> [TransitionTrigger; 6] {
        [
            Self::ExplicitShare,
            Self::SelfRecognition,
            Self::PatternDiscovery,
            Self::Privatize,
            Self::ExternalObservation,
            Self::DreamConsolidation,
        ]
    }
}

impl std::fmt::Display for TransitionTrigger {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -> std::fmt::Result {
        match self {
            Self::ExplicitShare => write!(f, "ExplicitShare"),
            Self::SelfRecognition => write!(f, "SelfRecognition"),
            Self::PatternDiscovery => write!(f, "PatternDiscovery"),
            Self::Privatize => write!(f, "Privatize"),
            Self::ExternalObservation => write!(f, "ExternalObservation"),
            Self::DreamConsolidation => write!(f, "DreamConsolidation"),
        }
    }
}

/// Record of a Johari quadrant transition.
///
/// Captures the complete context of a knowledge reclassification event,
/// including source/target quadrants, trigger, and timestamp.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct JohariTransition {
    /// Starting quadrant.
    pub from: JohariQuadrant,
    /// Ending quadrant.
    pub to: JohariQuadrant,
    /// What triggered this transition.
    pub trigger: TransitionTrigger,
    /// When this transition occurred.
    pub timestamp: DateTime&lt;Utc&gt;,
}

impl JohariTransition {
    /// Create a new transition record with current UTC timestamp.
    ///
    /// # Arguments
    /// * `from` - Source quadrant
    /// * `to` - Target quadrant
    /// * `trigger` - Event that caused the transition
    ///
    /// # Example
    /// ```
    /// use context_graph_core::types::{JohariQuadrant, TransitionTrigger, JohariTransition};
    /// let t = JohariTransition::new(
    ///     JohariQuadrant::Hidden,
    ///     JohariQuadrant::Open,
    ///     TransitionTrigger::ExplicitShare
    /// );
    /// assert_eq!(t.from, JohariQuadrant::Hidden);
    /// assert_eq!(t.to, JohariQuadrant::Open);
    /// ```
    pub fn new(from: JohariQuadrant, to: JohariQuadrant, trigger: TransitionTrigger) -> Self {
        Self {
            from,
            to,
            trigger,
            timestamp: Utc::now(),
        }
    }
}
    </signature>
    <signature file="crates/context-graph-core/src/types/johari.rs" add_to_johari_impl="true">
// ADD these methods to the existing impl JohariQuadrant block (before the closing brace at line 127)

    /// Get all valid transitions from this quadrant.
    ///
    /// Returns a static slice of (target_quadrant, trigger) pairs representing
    /// all legal state transitions from the current quadrant.
    ///
    /// # Transition Rules (from constitution.yaml)
    /// - Open → Hidden (Privatize)
    /// - Hidden → Open (ExplicitShare)
    /// - Blind → Open (SelfRecognition), Hidden (SelfRecognition)
    /// - Unknown → Open (DreamConsolidation, PatternDiscovery), Hidden (DreamConsolidation), Blind (ExternalObservation)
    pub fn valid_transitions(&amp;self) -> &amp;'static [(JohariQuadrant, TransitionTrigger)] {
        use TransitionTrigger::*;
        static OPEN_TRANSITIONS: [(JohariQuadrant, TransitionTrigger); 1] =
            [(JohariQuadrant::Hidden, Privatize)];
        static HIDDEN_TRANSITIONS: [(JohariQuadrant, TransitionTrigger); 1] =
            [(JohariQuadrant::Open, ExplicitShare)];
        static BLIND_TRANSITIONS: [(JohariQuadrant, TransitionTrigger); 2] = [
            (JohariQuadrant::Open, SelfRecognition),
            (JohariQuadrant::Hidden, SelfRecognition),
        ];
        static UNKNOWN_TRANSITIONS: [(JohariQuadrant, TransitionTrigger); 4] = [
            (JohariQuadrant::Open, DreamConsolidation),
            (JohariQuadrant::Open, PatternDiscovery),
            (JohariQuadrant::Hidden, DreamConsolidation),
            (JohariQuadrant::Blind, ExternalObservation),
        ];

        match self {
            Self::Open => &amp;OPEN_TRANSITIONS,
            Self::Hidden => &amp;HIDDEN_TRANSITIONS,
            Self::Blind => &amp;BLIND_TRANSITIONS,
            Self::Unknown => &amp;UNKNOWN_TRANSITIONS,
        }
    }

    /// Check if a transition to the target quadrant is valid.
    ///
    /// Returns false for self-transitions (from == to).
    pub fn can_transition_to(&amp;self, target: JohariQuadrant) -> bool {
        if *self == target {
            return false; // No self-transitions allowed
        }
        self.valid_transitions().iter().any(|(t, _)| *t == target)
    }

    /// Attempt to transition to a target quadrant with the given trigger.
    ///
    /// # Returns
    /// - `Ok(JohariTransition)` if the transition is valid for this trigger
    /// - `Err(String)` with descriptive message if transition is invalid
    ///
    /// # Errors
    /// - Self-transitions (from == to)
    /// - Invalid target quadrant for this source
    /// - Wrong trigger for the source→target pair
    pub fn transition_to(
        &amp;self,
        target: JohariQuadrant,
        trigger: TransitionTrigger,
    ) -> Result&lt;JohariTransition, String&gt; {
        if *self == target {
            return Err(format!(
                "Cannot transition to same quadrant: {:?}",
                self
            ));
        }

        let is_valid = self
            .valid_transitions()
            .iter()
            .any(|(t, tr)| *t == target &amp;&amp; *tr == trigger);

        if is_valid {
            Ok(JohariTransition::new(*self, target, trigger))
        } else {
            Err(format!(
                "Invalid transition: {:?} -> {:?} via {:?}. Valid transitions from {:?}: {:?}",
                self, target, trigger, self, self.valid_transitions()
            ))
        }
    }
    </signature>
  </signatures>

  <constraints>
    <constraint id="C1">Transition rules MUST match specification exactly (no approximations)</constraint>
    <constraint id="C2">Open can ONLY transition to Hidden (via Privatize)</constraint>
    <constraint id="C3">Hidden can ONLY transition to Open (via ExplicitShare)</constraint>
    <constraint id="C4">Blind can transition to Open OR Hidden (both via SelfRecognition)</constraint>
    <constraint id="C5">Unknown can transition to Open (DreamConsolidation, PatternDiscovery), Hidden (DreamConsolidation), or Blind (ExternalObservation)</constraint>
    <constraint id="C6">NO self-transitions allowed (from == to MUST error)</constraint>
    <constraint id="C7">Invalid transitions MUST return descriptive error (not panic)</constraint>
    <constraint id="C8">All derives: Debug, Clone, Copy (TransitionTrigger), PartialEq, Eq, Hash, Serialize, Deserialize</constraint>
    <constraint id="C9">JohariTransition is Clone but NOT Copy (contains DateTime)</constraint>
  </constraints>

  <verification>
    <command>cargo build --package context-graph-core</command>
    <expected>Compiles with 0 errors, 0 warnings</expected>

    <command>cargo test --package context-graph-core transition -- --nocapture</command>
    <expected>All transition_* tests pass</expected>

    <command>cargo clippy --package context-graph-core -- -D warnings</command>
    <expected>0 clippy warnings</expected>

    <command>cargo test --package context-graph-core --doc</command>
    <expected>Doc tests for JohariTransition::new pass</expected>
  </verification>
</definition_of_done>

<test_specification>
  <test_file>crates/context-graph-core/src/types/johari.rs (append to existing #[cfg(test)] mod tests)</test_file>
  <required_tests>
    <test name="test_transition_trigger_all_variants">Verify TransitionTrigger::all() returns 6 variants</test>
    <test name="test_transition_trigger_description_not_empty">All descriptions non-empty</test>
    <test name="test_transition_trigger_display">Display impl works for all variants</test>
    <test name="test_transition_trigger_serde_roundtrip">JSON serialize/deserialize works</test>
    <test name="test_open_to_hidden_via_privatize">Open→Hidden with Privatize succeeds</test>
    <test name="test_open_cannot_go_to_blind">Open→Blind returns Err</test>
    <test name="test_open_cannot_go_to_unknown">Open→Unknown returns Err</test>
    <test name="test_hidden_to_open_via_explicit_share">Hidden→Open with ExplicitShare succeeds</test>
    <test name="test_hidden_cannot_go_to_blind">Hidden→Blind returns Err</test>
    <test name="test_blind_to_open_via_self_recognition">Blind→Open with SelfRecognition succeeds</test>
    <test name="test_blind_to_hidden_via_self_recognition">Blind→Hidden with SelfRecognition succeeds</test>
    <test name="test_unknown_to_open_via_dream_consolidation">Unknown→Open with DreamConsolidation succeeds</test>
    <test name="test_unknown_to_open_via_pattern_discovery">Unknown→Open with PatternDiscovery succeeds</test>
    <test name="test_unknown_to_hidden_via_dream_consolidation">Unknown→Hidden with DreamConsolidation succeeds</test>
    <test name="test_unknown_to_blind_via_external_observation">Unknown→Blind with ExternalObservation succeeds</test>
    <test name="test_no_self_transitions">All quadrants reject self-transitions with error</test>
    <test name="test_invalid_trigger_rejected">Valid target but wrong trigger returns Err</test>
    <test name="test_transition_creates_record">JohariTransition::new creates valid record with timestamp</test>
    <test name="test_valid_transitions_count">Open=1, Hidden=1, Blind=2, Unknown=4</test>
    <test name="test_can_transition_to_false_for_self">can_transition_to(self) returns false</test>
  </required_tests>
</test_specification>

<implementation_steps>
  <step order="1">
    <action>Add chrono import to johari.rs</action>
    <location>Line 8, after `use std::str::FromStr;`</location>
    <code>use chrono::{DateTime, Utc};</code>
  </step>

  <step order="2">
    <action>Add TransitionTrigger enum</action>
    <location>After line 127 (closing brace of impl JohariQuadrant), before line 129 (impl Default)</location>
    <note>Include all 6 variants with doc comments, derives for Debug/Clone/Copy/PartialEq/Eq/Hash/Serialize/Deserialize, and serde(rename_all="snake_case")</note>
  </step>

  <step order="3">
    <action>Add TransitionTrigger impl block</action>
    <location>Immediately after TransitionTrigger enum</location>
    <methods>description(&amp;self), all(), Display impl</methods>
  </step>

  <step order="4">
    <action>Add JohariTransition struct</action>
    <location>After TransitionTrigger impl block</location>
    <fields>from: JohariQuadrant, to: JohariQuadrant, trigger: TransitionTrigger, timestamp: DateTime&lt;Utc&gt;</fields>
    <derives>Debug, Clone, PartialEq, Serialize, Deserialize (NOT Copy - DateTime)</derives>
  </step>

  <step order="5">
    <action>Add JohariTransition::new() constructor</action>
    <location>Inside impl JohariTransition block</location>
    <implementation>Sets timestamp to Utc::now()</implementation>
  </step>

  <step order="6">
    <action>Add transition methods to existing impl JohariQuadrant block</action>
    <location>Before the closing brace at line 127</location>
    <methods>valid_transitions(), can_transition_to(), transition_to()</methods>
    <note>Use static arrays for valid_transitions to return &amp;'static slice</note>
  </step>

  <step order="7">
    <action>Add unit tests to existing tests module</action>
    <location>After line 773 (before closing brace of mod tests)</location>
    <count>Minimum 20 tests covering all transition rules and edge cases</count>
  </step>
</implementation_steps>

<state_machine_diagram>
```
┌─────────────────────────────────────────────────────────────────┐
│                    JOHARI TRANSITIONS STATE MACHINE              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────┐                           ┌──────────┐           │
│   │   OPEN   │◄──── ExplicitShare ──────│  HIDDEN  │           │
│   │          │                           │          │           │
│   │  (1 out) │────── Privatize ─────────►│  (1 out) │           │
│   └──────────┘                           └──────────┘           │
│        ▲                                       ▲                │
│        │                                       │                │
│   SelfRecognition                        SelfRecognition        │
│        │                                       │                │
│   ┌────┴─────┐                                 │                │
│   │   BLIND  │─────────────────────────────────┘                │
│   │          │                                                  │
│   │  (2 out) │                                                  │
│   └──────────┘                                                  │
│        ▲                                                        │
│        │ ExternalObservation                                    │
│        │                                                        │
│   ┌────┴─────┐                                                  │
│   │ UNKNOWN  │───── DreamConsolidation ──────► OPEN             │
│   │          │───── PatternDiscovery ────────► OPEN             │
│   │  (4 out) │───── DreamConsolidation ──────► HIDDEN           │
│   └──────────┘                                                  │
│                                                                  │
│  CONSTRAINT: No self-transitions (from == to is INVALID)        │
└─────────────────────────────────────────────────────────────────┘
```
</state_machine_diagram>

<transition_rules_table>
| Source   | Target  | Valid Trigger(s)                    | Count |
|----------|---------|-------------------------------------|-------|
| Open     | Hidden  | Privatize                           | 1     |
| Open     | Blind   | NONE (invalid)                      | 0     |
| Open     | Unknown | NONE (invalid)                      | 0     |
| Hidden   | Open    | ExplicitShare                       | 1     |
| Hidden   | Blind   | NONE (invalid)                      | 0     |
| Hidden   | Unknown | NONE (invalid)                      | 0     |
| Blind    | Open    | SelfRecognition                     | 1     |
| Blind    | Hidden  | SelfRecognition                     | 1     |
| Blind    | Unknown | NONE (invalid)                      | 0     |
| Unknown  | Open    | DreamConsolidation, PatternDiscovery| 2     |
| Unknown  | Hidden  | DreamConsolidation                  | 1     |
| Unknown  | Blind   | ExternalObservation                 | 1     |
</transition_rules_table>

<full_state_verification>
  <description>
    After implementing, you MUST verify state transitions work correctly by:
    1. Running transition_to() for every valid combination
    2. Inspecting the returned JohariTransition struct fields
    3. Confirming error messages for invalid transitions
  </description>

  <source_of_truth>
    The JohariTransition struct returned by transition_to() IS the source of truth.
    Fields: from (source quadrant), to (target quadrant), trigger (what caused it), timestamp (when).
  </source_of_truth>

  <execute_and_inspect>
    <verification name="Valid Transition Test">
      <action>Call JohariQuadrant::Hidden.transition_to(JohariQuadrant::Open, TransitionTrigger::ExplicitShare)</action>
      <expected_result>Ok(JohariTransition { from: Hidden, to: Open, trigger: ExplicitShare, timestamp: &lt;now&gt; })</expected_result>
      <verify>Assert result.is_ok(), result.from == Hidden, result.to == Open, result.trigger == ExplicitShare</verify>
    </verification>

    <verification name="Invalid Transition Test">
      <action>Call JohariQuadrant::Open.transition_to(JohariQuadrant::Blind, TransitionTrigger::ExplicitShare)</action>
      <expected_result>Err("Invalid transition: Open -> Blind via ExplicitShare...")</expected_result>
      <verify>Assert result.is_err(), error message contains "Invalid transition"</verify>
    </verification>

    <verification name="Self-Transition Test">
      <action>Call JohariQuadrant::Open.transition_to(JohariQuadrant::Open, TransitionTrigger::Privatize)</action>
      <expected_result>Err("Cannot transition to same quadrant: Open")</expected_result>
      <verify>Assert result.is_err(), error message contains "same quadrant"</verify>
    </verification>
  </execute_and_inspect>

  <boundary_edge_cases>
    <case name="Empty enum check">
      <before>TransitionTrigger::all() returns 6 elements</before>
      <action>Iterate all variants, call description()</action>
      <after>All 6 variants have non-empty descriptions</after>
      <print>println!("Variant {:?} -> '{}'", trigger, trigger.description())</print>
    </case>

    <case name="Maximum transitions (Unknown quadrant)">
      <before>JohariQuadrant::Unknown.valid_transitions() returns 4 pairs</before>
      <action>Iterate transitions, attempt each via transition_to()</action>
      <after>All 4 valid transitions succeed</after>
      <print>For each: println!("Unknown -> {:?} via {:?}: {:?}", target, trigger, result)</print>
    </case>

    <case name="Minimum transitions (Open/Hidden)">
      <before>JohariQuadrant::Open.valid_transitions() returns exactly 1 pair</before>
      <action>Try transitioning to all 4 quadrants</action>
      <after>Only Hidden succeeds, Open/Blind/Unknown fail with Err</after>
      <print>For each: println!("Open -> {:?}: {:?}", target, result)</print>
    </case>
  </boundary_edge_cases>

  <evidence_of_success>
    Provide test output showing:
    1. All valid_transitions() return correct counts: Open=1, Hidden=1, Blind=2, Unknown=4
    2. All valid transition_to() calls return Ok with correct struct fields
    3. All invalid transition_to() calls return Err with descriptive message
    4. Serde roundtrip works for TransitionTrigger and JohariTransition
  </evidence_of_success>
</full_state_verification>

<sherlock_holmes_verification>
  <requirement>After completing implementation, spawn sherlock-holmes subagent for final verification</requirement>
  <verification_scope>
    <item>All 20+ tests pass with --nocapture showing actual values</item>
    <item>Transition rules match specification exactly (compare against transition_rules_table)</item>
    <item>Error messages are descriptive and include context</item>
    <item>No clippy warnings</item>
    <item>Doc tests compile and pass</item>
    <item>Serde serialization produces snake_case (not PascalCase)</item>
    <item>TransitionTrigger is Copy, JohariTransition is NOT Copy</item>
  </verification_scope>
  <fix_requirement>FIX any issues sherlock-holmes identifies before marking task complete</fix_requirement>
</sherlock_holmes_verification>

<test_commands>
  <command purpose="Build">cargo build --package context-graph-core</command>
  <command purpose="All tests">cargo test --package context-graph-core -- --nocapture 2>&amp;1 | grep -E "test.*transition|ok|FAILED"</command>
  <command purpose="Transition tests only">cargo test --package context-graph-core transition -- --nocapture</command>
  <command purpose="Clippy">cargo clippy --package context-graph-core -- -D warnings</command>
  <command purpose="Doc tests">cargo test --package context-graph-core --doc</command>
</test_commands>

<anti_patterns>
  <avoid id="AP-001">Do NOT use unwrap() - use expect() with context</avoid>
  <avoid id="AP-003">Do NOT hardcode magic numbers - valid_transitions counts are 1/1/2/4</avoid>
  <avoid id="AP-007">Do NOT use stub/mock data in tests - test real transition logic</avoid>
  <avoid id="NO-FALLBACK">Do NOT create backwards compatibility shims - if broken, it should fail fast</avoid>
  <avoid id="NO-WORKAROUND">Do NOT suppress errors - invalid transitions MUST return Err</avoid>
</anti_patterns>

<error_handling>
  <principle>FAIL FAST with descriptive errors</principle>
  <invalid_transition>Return Err(String) with: source quadrant, target quadrant, attempted trigger, list of valid transitions from source</invalid_transition>
  <self_transition>Return Err(String) with: "Cannot transition to same quadrant: {quadrant}"</self_transition>
  <no_panic>NEVER panic on invalid transitions - always return Result</no_panic>
</error_handling>
</task_spec>
```

## Implementation Notes

### Johari Transition State Machine

The Johari Window model classifies knowledge based on self-awareness and other-awareness:

| Quadrant | Self-Aware | Other-Aware | Meaning |
|----------|------------|-------------|---------|
| Open     | Yes        | Yes         | Known to all |
| Hidden   | Yes        | No          | Known only to self |
| Blind    | No         | Yes         | Others see what self doesn't |
| Unknown  | No         | No          | Undiscovered knowledge |

### Key Implementation Points

1. **File Location**: All code goes in `crates/context-graph-core/src/types/johari.rs`
2. **Insert After**: Line 127 (end of existing `impl JohariQuadrant` block)
3. **Chrono Import**: Add `use chrono::{DateTime, Utc};` at line 8
4. **Static Slices**: Use `static` arrays for `valid_transitions()` return values to get `&'static` lifetime
5. **No Copy for JohariTransition**: `DateTime<Utc>` is not Copy, so neither is the struct

### Transition Count Summary

| Quadrant | Outgoing Transitions |
|----------|---------------------|
| Open     | 1 (→ Hidden)        |
| Hidden   | 1 (→ Open)          |
| Blind    | 2 (→ Open, Hidden)  |
| Unknown  | 4 (→ Open×2, Hidden, Blind) |

---

*Task ID: TASK-M02-012*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
*Audited: 2025-12-31*
