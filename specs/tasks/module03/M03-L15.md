# M03-L15: DefaultModelFactory Implementation

```xml
<task_spec id="M03-L15" version="3.0">
<metadata>
  <title>Implement DefaultModelFactory for All 12 Embedding Models</title>
  <status>complete</status>
  <completed_date>2026-01-01</completed_date>
  <layer>logic</layer>
  <sequence>15</sequence>
  <implements>PRD model instantiation via factory pattern</implements>
  <depends_on>M03-L03, M03-L04, M03-L05, M03-L06, M03-L07, M03-L08, M03-L09, M03-L10, M03-L11, M03-L12, M03-L13, M03-L14, M03-F10</depends_on>
  <estimated_hours>3</estimated_hours>
  <last_verified>2026-01-01</last_verified>
  <verified_by>sherlock-holmes</verified_by>
</metadata>

<completion_summary>
  âœ… TASK COMPLETE: DefaultModelFactory implemented and verified.

  Implementation: crates/context-graph-embeddings/src/models/factory.rs (1021 lines)
  Export: crates/context-graph-embeddings/src/models/mod.rs (line 57)

  Key Accomplishments:
  - DefaultModelFactory struct with models_dir (PathBuf) and gpu_config (GpuConfig)
  - ModelFactory trait fully implemented (create_model, supported_models, estimate_memory)
  - All 12 models can be created: 4 custom (TemporalRecent, TemporalPeriodic, TemporalPositional, Hdc)
    and 8 pretrained (Semantic, Causal, Sparse, Code, Graph, Multimodal, Entity, LateInteraction)
  - 43 tests covering all creation paths (exceeds 30+ requirement)
  - Thread-safe: Factory is Send + Sync
  - Memory estimates delegate to MEMORY_ESTIMATES source of truth

  Verification:
  - cargo check: PASS
  - cargo test factory --lib: 76 tests PASS
  - cargo clippy: PASS (no warnings)
  - sherlock-holmes forensic verification: PASS
</completion_summary>

<context>
Implement DefaultModelFactory that creates all 12 embedding model instances.
This factory is the CENTRAL creation point for all models in the registry.

The factory:
1. Instantiates the correct model type based on ModelId
2. Applies device placement configuration (CPU/CUDA/Auto)
3. Applies quantization settings (None/FP16/BF16/Int8)
4. Provides memory estimates BEFORE loading
5. Validates model paths exist for pretrained models

CRITICAL DESIGN PRINCIPLES:
- NO FALLBACKS: If a model cannot be created, return EmbeddingError immediately
- FAIL FAST: Invalid config or missing files = immediate error with full context
- NO MOCK DATA: Tests use real model structs, never random/mock data
- NO BACKWARDS COMPATIBILITY HACKS: System works or fails with clear errors
</context>

<current_codebase_state verified="2026-01-01">
  <!-- GIT STATUS: main branch, last commit: feat(embeddings): add image processing support -->

  <models_implemented status="11 of 12 complete">
    <!-- CUSTOM MODELS (no pretrained weights) -->
    <model id="E2" file="src/models/custom/temporal_recent.rs" struct="TemporalRecentModel" status="COMPLETE"/>
    <model id="E3" file="src/models/custom/temporal_periodic.rs" struct="TemporalPeriodicModel" status="COMPLETE"/>
    <model id="E4" file="src/models/custom/temporal_positional.rs" struct="TemporalPositionalModel" status="COMPLETE"/>
    <model id="E9" file="src/models/custom/hdc.rs" struct="HdcModel" status="COMPLETE"/>

    <!-- PRETRAINED MODELS (require weight files) -->
    <model id="E1" file="src/models/pretrained/semantic.rs" struct="SemanticModel" status="COMPLETE"/>
    <model id="E5" file="src/models/pretrained/causal.rs" struct="CausalModel" status="COMPLETE"/>
    <model id="E6" file="src/models/pretrained/sparse.rs" struct="SparseModel" status="COMPLETE"/>
    <model id="E7" file="src/models/pretrained/code.rs" struct="CodeModel" status="COMPLETE"/>
    <model id="E8" file="src/models/pretrained/graph.rs" struct="GraphModel" status="COMPLETE"/>
    <model id="E10" file="src/models/pretrained/multimodal.rs" struct="MultimodalModel" status="COMPLETE"/>
    <model id="E11" file="src/models/pretrained/entity.rs" struct="EntityModel" status="COMPLETE"/>
    <model id="E12" file="src/models/pretrained/late_interaction.rs" struct="LateInteractionModel" status="MISSING"/>
  </models_implemented>

  <key_files>
    <file path="crates/context-graph-embeddings/src/traits/model_factory.rs" exists="true">
      Contains: ModelFactory trait, SingleModelConfig, DevicePlacement, QuantizationMode
      Lines 269-368: ModelFactory trait definition
      Lines 376-389: MEMORY_ESTIMATES constant array
      Line 352: estimate_memory() method
    </file>
    <file path="crates/context-graph-embeddings/src/types/model_id.rs" exists="true">
      Contains: ModelId enum with all 12 variants
      Line 242-257: ModelId::all() returns all 12 variants
      Line 163-175: directory_name() maps ModelId to subdirectory
    </file>
    <file path="crates/context-graph-embeddings/src/error.rs" exists="true">
      Contains: EmbeddingError enum with 17+ variants
      EmbeddingResult<T> type alias
    </file>
    <file path="crates/context-graph-embeddings/src/models/mod.rs" exists="true">
      Contains: pub mod custom, pub mod pretrained, pub use statements
      Currently exports 7 pretrained models (missing late_interaction)
    </file>
  </key_files>

  <exports_from_pretrained_mod>
    <!-- Current state of pretrained/mod.rs lines 15-81 -->
    - CausalModel, CAUSAL_DIMENSION, CAUSAL_LATENCY_BUDGET_MS, CAUSAL_MAX_TOKENS, DEFAULT_ATTENTION_WINDOW
    - CodeModel, CODE_LATENCY_BUDGET_MS, CODE_MAX_TOKENS, CODE_MODEL_NAME, CODE_NATIVE_DIMENSION, CODE_PROJECTED_DIMENSION
    - EntityModel, ENTITY_DIMENSION, ENTITY_LATENCY_BUDGET_MS, ENTITY_MAX_TOKENS, ENTITY_MODEL_NAME
    - GraphModel, GRAPH_DIMENSION, GRAPH_LATENCY_BUDGET_MS, GRAPH_MAX_TOKENS, GRAPH_MODEL_NAME, MAX_CONTEXT_NEIGHBORS
    - MultimodalModel, ImageProcessor, CLIP_IMAGE_SIZE, CLIP_MEAN, CLIP_STD, MULTIMODAL_DIMENSION, etc.
    - SemanticModel, PASSAGE_PREFIX, QUERY_PREFIX, SEMANTIC_DIMENSION, SEMANTIC_LATENCY_BUDGET_MS, SEMANTIC_MAX_TOKENS
    - SparseModel, SparseVector, SPARSE_EXPECTED_SPARSITY, SPARSE_LATENCY_BUDGET_MS, etc.
    <!-- MISSING: LateInteractionModel (blocked on M03-L14) -->
  </exports_from_pretrained_mod>

  <exports_from_custom_mod>
    - TemporalRecentModel, TEMPORAL_RECENT_DIMENSION
    - TemporalPeriodicModel, TEMPORAL_PERIODIC_DIMENSION, periods module
    - TemporalPositionalModel, TEMPORAL_POSITIONAL_DIMENSION
    - HdcModel (in custom/hdc.rs, re-exported via models/mod.rs)
  </exports_from_custom_mod>
</current_codebase_state>

<definition_of_done>
  <signatures>
```rust
// File: crates/context-graph-embeddings/src/models/factory.rs

use std::collections::HashMap;
use std::path::{Path, PathBuf};

use crate::error::{EmbeddingError, EmbeddingResult};
use crate::traits::{
    DevicePlacement, EmbeddingModel, ModelFactory, QuantizationMode, SingleModelConfig,
};
use crate::types::ModelId;
use crate::config::GpuConfig;

// Import all 12 models
use crate::models::custom::{
    HdcModel, TemporalPeriodicModel, TemporalPositionalModel, TemporalRecentModel,
};
use crate::models::pretrained::{
    CausalModel, CodeModel, EntityModel, GraphModel, LateInteractionModel,
    MultimodalModel, SemanticModel, SparseModel,
};

/// Concrete implementation of ModelFactory for all 12 embedding models.
///
/// This factory is the central creation point for embedding models.
/// It validates paths, applies configuration, and instantiates the
/// correct model type based on ModelId.
///
/// # Thread Safety
/// All methods are safe for concurrent access. The factory itself is
/// stateless after construction - all state is in created models.
///
/// # Memory Management
/// Memory estimates are conservative overestimates. Actual usage depends
/// on quantization mode and batch size.
pub struct DefaultModelFactory {
    /// Base directory for pretrained model weights.
    /// Pretrained models are in subdirectories: semantic/, causal/, etc.
    models_dir: PathBuf,

    /// GPU configuration for device placement decisions.
    gpu_config: GpuConfig,

    /// Pre-computed memory estimates per model (bytes, FP32).
    memory_estimates: HashMap<ModelId, usize>,
}

impl DefaultModelFactory {
    /// Create a new DefaultModelFactory.
    ///
    /// # Arguments
    /// * `models_dir` - Base directory containing model subdirectories
    /// * `gpu_config` - GPU configuration for device placement
    ///
    /// # Errors
    /// - `EmbeddingError::ConfigError` if models_dir does not exist
    ///
    /// # Example
    /// ```rust,ignore
    /// let factory = DefaultModelFactory::new(
    ///     Path::new("models"),
    ///     GpuConfig::default(),
    /// )?;
    /// ```
    pub fn new(models_dir: impl AsRef<Path>, gpu_config: GpuConfig) -> EmbeddingResult<Self>;

    /// Validate that all pretrained model directories exist.
    ///
    /// Checks: semantic/, causal/, sparse/, code/, graph/, multimodal/,
    ///         entity/, late-interaction/
    ///
    /// # Errors
    /// - `EmbeddingError::ModelLoadError` listing all missing directories
    pub fn validate_model_paths(&self) -> EmbeddingResult<()>;

    /// Get the model subdirectory path for a given ModelId.
    ///
    /// Uses ModelId::directory_name() to determine subdirectory:
    /// - Semantic -> models_dir/semantic
    /// - LateInteraction -> models_dir/late-interaction (hyphenated)
    /// - Custom models (Temporal*, Hdc) return models_dir (no subdirectory needed)
    pub fn model_path(&self, model_id: ModelId) -> PathBuf;

    /// Check if model weight files exist on disk.
    ///
    /// For pretrained models, checks for config.json in subdirectory.
    /// For custom models, always returns true (no weights needed).
    pub fn model_exists(&self, model_id: ModelId) -> bool;
}

impl ModelFactory for DefaultModelFactory {
    /// Create a model instance for the given ModelId.
    ///
    /// The returned model is NOT loaded. Call model.load() before embed().
    ///
    /// # Arguments
    /// * `model_id` - Which of the 12 models to create
    /// * `config` - Device placement and quantization settings
    ///
    /// # Returns
    /// Boxed trait object implementing EmbeddingModel.
    ///
    /// # Errors
    /// - `EmbeddingError::ConfigError` if config.max_batch_size is 0
    /// - `EmbeddingError::ModelLoadError` if pretrained model path missing
    ///
    /// # Model Creation Matrix
    /// | ModelId | Struct | Requires Path |
    /// |---------|--------|---------------|
    /// | Semantic | SemanticModel | Yes |
    /// | TemporalRecent | TemporalRecentModel | No |
    /// | TemporalPeriodic | TemporalPeriodicModel | No |
    /// | TemporalPositional | TemporalPositionalModel | No |
    /// | Causal | CausalModel | Yes |
    /// | Sparse | SparseModel | Yes |
    /// | Code | CodeModel | Yes |
    /// | Graph | GraphModel | Yes |
    /// | Hdc | HdcModel | No |
    /// | Multimodal | MultimodalModel | Yes |
    /// | Entity | EntityModel | Yes |
    /// | LateInteraction | LateInteractionModel | Yes |
    fn create_model(
        &self,
        model_id: ModelId,
        config: &SingleModelConfig,
    ) -> EmbeddingResult<Box<dyn EmbeddingModel>>;

    /// Returns all 12 ModelId variants.
    fn supported_models(&self) -> &[ModelId] {
        ModelId::all()
    }

    /// Returns conservative memory estimate in bytes.
    ///
    /// Estimates from MEMORY_ESTIMATES constant in model_factory.rs.
    fn estimate_memory(&self, model_id: ModelId) -> usize;
}
```
  </signatures>

  <constraints>
    <constraint>Creates correct model type for each of 12 ModelId variants</constraint>
    <constraint>Applies DevicePlacement from config (Cpu, Cuda(n), Auto)</constraint>
    <constraint>Applies QuantizationMode from config (None, FP16, BF16, Int8)</constraint>
    <constraint>Custom models (Temporal*, Hdc) do NOT require model paths</constraint>
    <constraint>Pretrained models validate path existence before creation</constraint>
    <constraint>Memory estimates use MEMORY_ESTIMATES from model_factory.rs</constraint>
    <constraint>supported_models() returns all 12 ModelId variants via ModelId::all()</constraint>
    <constraint>Thread-safe: DefaultModelFactory is Send + Sync</constraint>
    <constraint>NO FALLBACKS: Invalid state returns EmbeddingError immediately</constraint>
    <constraint>NO MOCK DATA: Tests use real model struct instantiation</constraint>
  </constraints>
</definition_of_done>

<files_to_create>
  <file action="create" path="crates/context-graph-embeddings/src/models/factory.rs">
    Main factory implementation
  </file>
</files_to_create>

<files_to_modify>
  <file action="modify" path="crates/context-graph-embeddings/src/models/mod.rs">
    Add: mod factory;
    Add: pub use factory::DefaultModelFactory;
  </file>
</files_to_modify>

<implementation_pattern>
```rust
// File: crates/context-graph-embeddings/src/models/factory.rs

use std::collections::HashMap;
use std::path::{Path, PathBuf};

use crate::config::GpuConfig;
use crate::error::{EmbeddingError, EmbeddingResult};
use crate::traits::{
    get_memory_estimate, EmbeddingModel, ModelFactory, SingleModelConfig,
};
use crate::types::ModelId;

// Import custom models
use super::custom::{
    HdcModel, TemporalPeriodicModel, TemporalPositionalModel, TemporalRecentModel,
};

// Import pretrained models
use super::pretrained::{
    CausalModel, CodeModel, EntityModel, GraphModel, LateInteractionModel,
    MultimodalModel, SemanticModel, SparseModel,
};

pub struct DefaultModelFactory {
    models_dir: PathBuf,
    #[allow(dead_code)]
    gpu_config: GpuConfig,
    memory_estimates: HashMap<ModelId, usize>,
}

impl DefaultModelFactory {
    pub fn new(models_dir: impl AsRef<Path>, gpu_config: GpuConfig) -> EmbeddingResult<Self> {
        let models_dir = models_dir.as_ref().to_path_buf();

        // Validate base directory exists (pretrained models need it)
        if !models_dir.exists() {
            return Err(EmbeddingError::ConfigError {
                message: format!("Models directory does not exist: {}", models_dir.display()),
            });
        }

        // Pre-compute memory estimates for all 12 models
        let memory_estimates: HashMap<ModelId, usize> = ModelId::all()
            .iter()
            .map(|&id| (id, get_memory_estimate(id)))
            .collect();

        Ok(Self {
            models_dir,
            gpu_config,
            memory_estimates,
        })
    }

    pub fn validate_model_paths(&self) -> EmbeddingResult<()> {
        let mut missing = Vec::new();

        // Only pretrained models need paths validated
        for model_id in ModelId::pretrained() {
            let path = self.model_path(model_id);
            if !path.exists() {
                missing.push(format!("{:?}: {}", model_id, path.display()));
            }
        }

        if !missing.is_empty() {
            return Err(EmbeddingError::ModelLoadError {
                model_id: ModelId::Semantic, // First model as representative
                reason: format!("Missing model directories: [{}]", missing.join(", ")),
            });
        }

        Ok(())
    }

    pub fn model_path(&self, model_id: ModelId) -> PathBuf {
        if model_id.is_custom() {
            // Custom models don't need a subdirectory
            self.models_dir.clone()
        } else {
            // Pretrained models use directory_name()
            self.models_dir.join(model_id.directory_name())
        }
    }

    pub fn model_exists(&self, model_id: ModelId) -> bool {
        if model_id.is_custom() {
            true // Custom models don't need files
        } else {
            let path = self.model_path(model_id);
            path.join("config.json").exists() || path.exists()
        }
    }
}

impl ModelFactory for DefaultModelFactory {
    fn create_model(
        &self,
        model_id: ModelId,
        config: &SingleModelConfig,
    ) -> EmbeddingResult<Box<dyn EmbeddingModel>> {
        // Validate config first - FAIL FAST
        config.validate()?;

        match model_id {
            // ============================================================
            // CUSTOM MODELS (no pretrained weights, no path validation)
            // ============================================================
            ModelId::TemporalRecent => {
                let model = TemporalRecentModel::new(config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::TemporalPeriodic => {
                let model = TemporalPeriodicModel::new(config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::TemporalPositional => {
                let model = TemporalPositionalModel::new(config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Hdc => {
                let model = HdcModel::new(config.clone())?;
                Ok(Box::new(model))
            }

            // ============================================================
            // PRETRAINED MODELS (require model path validation)
            // ============================================================
            ModelId::Semantic => {
                let path = self.model_path(model_id);
                let model = SemanticModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Causal => {
                let path = self.model_path(model_id);
                let model = CausalModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Sparse => {
                let path = self.model_path(model_id);
                let model = SparseModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Code => {
                let path = self.model_path(model_id);
                let model = CodeModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Graph => {
                let path = self.model_path(model_id);
                let model = GraphModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Multimodal => {
                let path = self.model_path(model_id);
                let model = MultimodalModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::Entity => {
                let path = self.model_path(model_id);
                let model = EntityModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
            ModelId::LateInteraction => {
                let path = self.model_path(model_id);
                let model = LateInteractionModel::new(&path, config.clone())?;
                Ok(Box::new(model))
            }
        }
    }

    fn supported_models(&self) -> &[ModelId] {
        ModelId::all()
    }

    fn estimate_memory(&self, model_id: ModelId) -> usize {
        self.memory_estimates.get(&model_id).copied().unwrap_or(0)
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use tempfile::TempDir;

    fn create_test_factory() -> (DefaultModelFactory, TempDir) {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");

        // Create subdirectories for pretrained models
        for model_id in ModelId::pretrained() {
            let subdir = temp_dir.path().join(model_id.directory_name());
            std::fs::create_dir_all(&subdir).expect("Failed to create model dir");
            // Create minimal config.json so model_exists() passes
            std::fs::write(subdir.join("config.json"), "{}").expect("Failed to create config");
        }

        let factory = DefaultModelFactory::new(
            temp_dir.path(),
            GpuConfig::default(),
        ).expect("Failed to create factory");

        (factory, temp_dir)
    }

    // ====================== CONSTRUCTION TESTS ======================

    #[test]
    fn test_new_succeeds_with_valid_dir() {
        let temp_dir = TempDir::new().unwrap();
        let result = DefaultModelFactory::new(temp_dir.path(), GpuConfig::default());
        assert!(result.is_ok(), "Should create factory with valid dir");
    }

    #[test]
    fn test_new_fails_with_nonexistent_dir() {
        let result = DefaultModelFactory::new(
            Path::new("/nonexistent/path/that/does/not/exist"),
            GpuConfig::default(),
        );
        assert!(result.is_err(), "Should fail with nonexistent dir");
        match result {
            Err(EmbeddingError::ConfigError { message }) => {
                assert!(message.contains("does not exist"));
            }
            _ => panic!("Expected ConfigError"),
        }
    }

    // ====================== MODEL PATH TESTS ======================

    #[test]
    fn test_model_path_pretrained() {
        let (factory, _temp) = create_test_factory();

        assert!(factory.model_path(ModelId::Semantic).ends_with("semantic"));
        assert!(factory.model_path(ModelId::Causal).ends_with("causal"));
        assert!(factory.model_path(ModelId::LateInteraction).ends_with("late-interaction"));
    }

    #[test]
    fn test_model_path_custom_returns_base() {
        let (factory, _temp) = create_test_factory();

        // Custom models return base dir (no subdirectory)
        let base = factory.models_dir.clone();
        assert_eq!(factory.model_path(ModelId::TemporalRecent), base);
        assert_eq!(factory.model_path(ModelId::TemporalPeriodic), base);
        assert_eq!(factory.model_path(ModelId::TemporalPositional), base);
        assert_eq!(factory.model_path(ModelId::Hdc), base);
    }

    // ====================== FACTORY TRAIT TESTS ======================

    #[test]
    fn test_supported_models_returns_all_12() {
        let (factory, _temp) = create_test_factory();
        let models = factory.supported_models();
        assert_eq!(models.len(), 12);

        // Verify all 12 are present
        for model_id in ModelId::all() {
            assert!(models.contains(model_id), "Missing {:?}", model_id);
        }
    }

    #[test]
    fn test_estimate_memory_nonzero_for_all() {
        let (factory, _temp) = create_test_factory();

        for model_id in ModelId::all() {
            let estimate = factory.estimate_memory(*model_id);
            assert!(estimate > 0, "Memory estimate for {:?} should be > 0", model_id);
        }
    }

    #[test]
    fn test_create_model_custom_succeeds() {
        let (factory, _temp) = create_test_factory();
        let config = SingleModelConfig::default();

        // Custom models should create without path validation
        for model_id in [
            ModelId::TemporalRecent,
            ModelId::TemporalPeriodic,
            ModelId::TemporalPositional,
            ModelId::Hdc,
        ] {
            let result = factory.create_model(model_id, &config);
            assert!(result.is_ok(), "Failed to create {:?}: {:?}", model_id, result.err());

            let model = result.unwrap();
            assert_eq!(model.model_id(), model_id);
            assert!(!model.is_initialized()); // Not loaded yet
        }
    }

    #[test]
    fn test_create_model_pretrained_succeeds() {
        let (factory, _temp) = create_test_factory();
        let config = SingleModelConfig::default();

        // Pretrained models should create with valid paths
        for model_id in ModelId::pretrained() {
            let result = factory.create_model(model_id, &config);
            assert!(result.is_ok(), "Failed to create {:?}: {:?}", model_id, result.err());

            let model = result.unwrap();
            assert_eq!(model.model_id(), model_id);
            assert!(!model.is_initialized()); // Not loaded yet
        }
    }

    #[test]
    fn test_create_model_with_invalid_config_fails() {
        let (factory, _temp) = create_test_factory();
        let config = SingleModelConfig {
            max_batch_size: 0, // Invalid
            ..Default::default()
        };

        let result = factory.create_model(ModelId::Semantic, &config);
        assert!(matches!(result, Err(EmbeddingError::ConfigError { .. })));
    }

    // ====================== EDGE CASE TESTS ======================

    #[test]
    fn test_edge_case_1_model_exists_custom() {
        let (factory, _temp) = create_test_factory();

        // Custom models always "exist" (no files needed)
        assert!(factory.model_exists(ModelId::TemporalRecent));
        assert!(factory.model_exists(ModelId::Hdc));
    }

    #[test]
    fn test_edge_case_2_model_exists_pretrained_with_config() {
        let (factory, _temp) = create_test_factory();

        // Pretrained models have config.json in temp dir
        assert!(factory.model_exists(ModelId::Semantic));
        assert!(factory.model_exists(ModelId::Entity));
    }

    #[test]
    fn test_edge_case_3_validate_paths_succeeds() {
        let (factory, _temp) = create_test_factory();

        // All paths exist in temp dir
        let result = factory.validate_model_paths();
        assert!(result.is_ok());
    }

    // ====================== EVIDENCE OF SUCCESS ======================

    #[test]
    fn test_evidence_of_success() {
        println!("\n========================================");
        println!("M03-L15 EVIDENCE OF SUCCESS");
        println!("========================================\n");

        let (factory, _temp) = create_test_factory();
        let config = SingleModelConfig::default();

        println!("1. SUPPORTED MODELS:");
        for model_id in factory.supported_models() {
            let memory = factory.estimate_memory(*model_id);
            println!("   {:?}: {}MB", model_id, memory / 1_000_000);
        }

        println!("\n2. MODEL CREATION:");
        for model_id in ModelId::all() {
            let result = factory.create_model(*model_id, &config);
            let status = if result.is_ok() { "OK" } else { "FAILED" };
            println!("   {:?}: {}", model_id, status);

            if let Ok(model) = result {
                assert_eq!(model.model_id(), *model_id);
                assert!(!model.is_initialized());
            }
        }

        println!("\n3. PATH VALIDATION:");
        let path_result = factory.validate_model_paths();
        println!("   validate_model_paths: {:?}", path_result.is_ok());

        println!("\n========================================");
        println!("ALL CHECKS PASSED");
        println!("========================================\n");
    }
}
```
</implementation_pattern>

<validation_criteria>
  <criterion>cargo check passes with no errors</criterion>
  <criterion>cargo test --lib passes (all tests green)</criterion>
  <criterion>cargo clippy passes with no warnings</criterion>
  <criterion>DefaultModelFactory::new() validates models_dir exists</criterion>
  <criterion>create_model() returns correct type for each of 12 ModelId variants</criterion>
  <criterion>Custom models (Temporal*, Hdc) create without path validation</criterion>
  <criterion>Pretrained models validate path exists</criterion>
  <criterion>estimate_memory() returns values from MEMORY_ESTIMATES</criterion>
  <criterion>supported_models() returns all 12 entries</criterion>
  <criterion>DefaultModelFactory is Send + Sync</criterion>
  <criterion>Created models are NOT initialized (is_initialized() = false)</criterion>
</validation_criteria>

<full_state_verification>
  <source_of_truth>
    <file path="crates/context-graph-embeddings/src/traits/model_factory.rs">
      Lines 376-389: MEMORY_ESTIMATES constant array with 12 entries
      Line 392-398: get_memory_estimate() helper function
      Line 402: TOTAL_MEMORY_ESTIMATE = 5_545_000_000 bytes
    </file>
    <file path="crates/context-graph-embeddings/src/types/model_id.rs">
      Line 242-257: ModelId::all() returns array of 12 variants
      Line 163-175: directory_name() returns subdirectory name
      Line 122-134: is_custom() and is_pretrained() methods
    </file>
  </source_of_truth>

  <edge_case_audits>
    <test name="test_edge_case_1_model_exists_custom">
      Custom models return true from model_exists() without files
    </test>
    <test name="test_edge_case_2_model_exists_pretrained_with_config">
      Pretrained models check for config.json in subdirectory
    </test>
    <test name="test_edge_case_3_validate_paths_succeeds">
      validate_model_paths() passes when all pretrained dirs exist
    </test>
    <test name="test_create_model_with_invalid_config_fails">
      Zero max_batch_size returns EmbeddingError::ConfigError
    </test>
  </edge_case_audits>

  <physical_verification>
    <file_must_exist>crates/context-graph-embeddings/src/models/factory.rs</file_must_exist>
    <export_must_exist module="models/mod.rs">DefaultModelFactory</export_must_exist>
    <test_must_pass>cargo test factory --lib</test_must_pass>
    <build_must_pass>cargo check</build_must_pass>
    <clippy_must_pass>cargo clippy</clippy_must_pass>
  </physical_verification>

  <evidence_of_success>
    <evidence>DefaultModelFactory::new() succeeds with valid directory</evidence>
    <evidence>supported_models().len() = 12</evidence>
    <evidence>create_model() succeeds for all 12 ModelId variants</evidence>
    <evidence>Each created model has correct model_id()</evidence>
    <evidence>Each created model has is_initialized() = false</evidence>
    <evidence>estimate_memory() > 0 for all models</evidence>
    <evidence>validate_model_paths() succeeds when dirs exist</evidence>
  </evidence_of_success>
</full_state_verification>

<sherlock_verification>
After implementation, spawn sherlock-holmes subagent to verify:

1. **File Existence**: factory.rs exists at crates/context-graph-embeddings/src/models/factory.rs
2. **Module Export**: models/mod.rs exports DefaultModelFactory
3. **Trait Implementation**: ModelFactory trait fully implemented
4. **All 12 Models**: Verify create_model works for all ModelId variants
5. **Memory Estimates**: All 12 models have non-zero estimates
6. **No Mock Data**: Tests use real TempDir and model structs
7. **No Fallbacks**: All errors return EmbeddingError immediately
8. **Build Success**: cargo check, cargo test, cargo clippy all pass
9. **Source of Truth Match**: Memory estimates match MEMORY_ESTIMATES array
10. **Thread Safety**: DefaultModelFactory is Send + Sync

Sherlock MUST:
- Run `cargo test factory --lib -- --nocapture` to see evidence logs
- Verify test_evidence_of_success prints all 12 models
- Check that no test uses mock/random data
- Confirm all edge cases have dedicated tests
</sherlock_verification>
</task_spec>
```

---

## Pre-Implementation Checklist

Before implementing M03-L15, you MUST complete M03-L14:

- [ ] M03-L14: LateInteractionModel (ColBERT) - **NOT IMPLEMENTED**
  - File `src/models/pretrained/late_interaction.rs` does not exist
  - Must export `LateInteractionModel` from `pretrained/mod.rs`

After M03-L14 is complete:

- [ ] Create `crates/context-graph-embeddings/src/models/factory.rs`
- [ ] Add `mod factory; pub use factory::DefaultModelFactory;` to `models/mod.rs`
- [ ] Import all 12 model types (4 custom, 8 pretrained)
- [ ] Implement `DefaultModelFactory::new()` with path validation
- [ ] Implement `create_model()` for all 12 ModelId variants
- [ ] Run all tests and verify evidence of success

---

## Memory Estimates Reference

From `crates/context-graph-embeddings/src/traits/model_factory.rs` lines 376-389:

| ModelId | Memory (FP32) |
|---------|---------------|
| Semantic | 1.4 GB |
| TemporalRecent | 15 MB |
| TemporalPeriodic | 15 MB |
| TemporalPositional | 15 MB |
| Causal | 650 MB |
| Sparse | 550 MB |
| Code | 550 MB |
| Graph | 120 MB |
| Hdc | 60 MB |
| Multimodal | 1.6 GB |
| Entity | 120 MB |
| LateInteraction | 450 MB |

**Total: ~5.5 GB (FP32)**

---

## Completion Checklist

- [ ] M03-L14 complete (BLOCKER)
- [ ] `factory.rs` created at correct path
- [ ] `DefaultModelFactory` struct with fields: models_dir, gpu_config, memory_estimates
- [ ] `new()` validates models_dir exists
- [ ] `validate_model_paths()` checks all 8 pretrained model subdirs
- [ ] `model_path()` uses `ModelId::directory_name()`
- [ ] `create_model()` handles all 12 variants correctly
- [ ] Custom models: TemporalRecent, TemporalPeriodic, TemporalPositional, Hdc
- [ ] Pretrained models: Semantic, Causal, Sparse, Code, Graph, Multimodal, Entity, LateInteraction
- [ ] `supported_models()` returns `ModelId::all()`
- [ ] `estimate_memory()` uses `get_memory_estimate()`
- [ ] All tests pass: `cargo test factory --lib`
- [ ] Build passes: `cargo check`
- [ ] Lint passes: `cargo clippy`
- [ ] sherlock-holmes verification complete
