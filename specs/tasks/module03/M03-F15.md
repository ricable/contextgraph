# M03-F15: CacheConfig and GpuConfig Structs

```xml
<task_spec id="M03-F15" version="3.0">
<metadata>
  <title>Complete CacheConfig and GpuConfig Configuration Structs</title>
  <status>complete</status>
  <layer>foundation</layer>
  <sequence>15</sequence>
  <implements>constitution.yaml:embeddings.cache, embeddings.gpu, CUDA-13-1-RTX-5090-Report.md</implements>
  <depends_on>M03-F08 (EmbeddingError)</depends_on>
  <estimated_hours>2</estimated_hours>
  <updated>2026-01-01</updated>
</metadata>

<context>
Configuration for:
1. **Embedding Cache** - LRU cache for computed embeddings to avoid recomputation
2. **GPU Settings** - CUDA 13.1 / RTX 5090 device configuration for accelerated inference

The cache provides <100us lookup vs ~200ms recomputation.
Target hit rate: >80% under normal workload.

GPU target: RTX 5090 (32GB GDDR7, Compute 12.0, CUDA 13.1)

CURRENT STATE (2026-01-01 sherlock-holmes forensic audit - VERIFIED COMPLETE):

**EvictionPolicy enum (lines 574-615):**
✅ COMPLETE - 4 variants: Lru, Lfu, TtlLru, Arc
✅ Has #[derive(Copy)] for efficiency
✅ Has all() and as_str() methods
✅ Serde snake_case serialization

**CacheConfig (lines 632-742):**
✅ COMPLETE - All 7 fields implemented:
  - enabled: bool (default: true)
  - max_entries: usize (default: 100_000)
  - max_bytes: usize (default: 1_073_741_824 = 1GB)
  - ttl_seconds: Option<u64> (default: None)
  - eviction_policy: EvictionPolicy (default: Lru)
  - persist_to_disk: bool (default: false)
  - disk_path: Option<PathBuf> (default: None)
✅ validate() returns EmbeddingResult<()>
✅ disabled() and bytes_per_entry() helper methods

**GpuConfig (lines 757-903):**
✅ COMPLETE - All 7 fields implemented:
  - enabled: bool (default: true)
  - device_ids: Vec<u32> (default: [0])
  - memory_fraction: f32 (default: 0.9)
  - use_cuda_graphs: bool (default: true)
  - mixed_precision: bool (default: true)
  - green_contexts: bool (default: false)
  - gds_enabled: bool (default: false)
✅ validate() returns EmbeddingResult<()>
✅ cpu_only() returns disabled config (enabled=false, device_ids=[], memory_fraction=0.0)
✅ rtx_5090_optimized() returns optimized config (green_contexts=true, gds_enabled=true)
✅ is_gpu_enabled() helper method

**Exports (lib.rs line 38):**
✅ EvictionPolicy properly exported

**Tests (52 total):**
✅ 19 CacheConfig tests
✅ 27 GpuConfig tests
✅ 6 EvictionPolicy tests
✅ All pass with 0 failures

**Old field names REMOVED (no backward compatibility):**
✅ disk_persistence → persist_to_disk
✅ cache_path → disk_path
✅ memory_limit → memory_fraction
✅ cuda_graphs → use_cuda_graphs
✅ green_context_percentage → green_contexts
</context>

<current_implementation>
File: crates/context-graph-embeddings/src/config.rs

**IMPLEMENTATION STATUS: ✅ COMPLETE (verified 2026-01-01)**

EvictionPolicy enum (lines 574-615):
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum EvictionPolicy {
    #[default]
    Lru,
    Lfu,
    TtlLru,
    Arc,
}
```

CacheConfig (lines 632-742):
```rust
pub struct CacheConfig {
    pub enabled: bool,                    // ✅ default: true
    pub max_entries: usize,               // ✅ default: 100_000
    pub max_bytes: usize,                 // ✅ default: 1_073_741_824 (1GB)
    pub ttl_seconds: Option<u64>,         // ✅ default: None
    pub eviction_policy: EvictionPolicy,  // ✅ default: Lru
    pub persist_to_disk: bool,            // ✅ default: false
    pub disk_path: Option<PathBuf>,       // ✅ default: None
}
// Methods: validate(), disabled(), bytes_per_entry()
```

GpuConfig (lines 757-903):
```rust
pub struct GpuConfig {
    pub enabled: bool,          // ✅ default: true
    pub device_ids: Vec<u32>,   // ✅ default: [0]
    pub memory_fraction: f32,   // ✅ default: 0.9
    pub use_cuda_graphs: bool,  // ✅ default: true
    pub mixed_precision: bool,  // ✅ default: true
    pub green_contexts: bool,   // ✅ default: false
    pub gds_enabled: bool,      // ✅ default: false
}
// Methods: validate(), cpu_only(), rtx_5090_optimized(), is_gpu_enabled()
```

Exports (lib.rs):
```rust
pub use config::{
    BatchConfig, CacheConfig, EmbeddingConfig, EvictionPolicy, FusionConfig,
    GpuConfig, ModelRegistryConfig, PaddingStrategy, SingleModelConfig,
};
```
</current_implementation>

<definition_of_done>
  <signatures>
```rust
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use crate::error::{EmbeddingError, EmbeddingResult};

// ============================================================================
// EVICTION POLICY ENUM (NEW - MUST CREATE)
// ============================================================================

/// Cache eviction policy.
///
/// Determines how entries are removed when the cache reaches capacity.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum EvictionPolicy {
    /// Least Recently Used - evict oldest access.
    /// Best for: temporal locality workloads
    #[default]
    Lru,

    /// Least Frequently Used - evict lowest access count.
    /// Best for: frequency-based access patterns
    Lfu,

    /// LRU with TTL consideration.
    /// Prioritizes expired entries for eviction.
    TtlLru,

    /// Adaptive Replacement Cache - balanced LRU/LFU hybrid.
    /// Best for: mixed workloads with unknown access patterns
    Arc,
}

impl EvictionPolicy {
    /// Returns all available eviction policies.
    pub fn all() -> &'static [EvictionPolicy] {
        &[
            EvictionPolicy::Lru,
            EvictionPolicy::Lfu,
            EvictionPolicy::TtlLru,
            EvictionPolicy::Arc,
        ]
    }

    /// Returns the policy name as a string.
    pub fn as_str(&self) -> &'static str {
        match self {
            EvictionPolicy::Lru => "lru",
            EvictionPolicy::Lfu => "lfu",
            EvictionPolicy::TtlLru => "ttl_lru",
            EvictionPolicy::Arc => "arc",
        }
    }
}

// ============================================================================
// CACHE CONFIG STRUCT (REPLACE EXISTING)
// ============================================================================

/// Configuration for embedding cache.
///
/// The cache stores computed embeddings keyed by content hash (xxhash64).
/// Provides <100us lookup vs ~200ms recomputation for cache hits.
///
/// # Capacity Calculation
/// ```text
/// Single FusedEmbedding: 1536 * 4 bytes = 6,144 bytes
/// 100K entries: 100,000 * 6,144 = 614,400,000 bytes (~614 MB)
/// With metadata overhead: ~1 GB
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheConfig {
    /// Whether caching is enabled.
    /// Default: true
    #[serde(default = "default_cache_enabled")]
    pub enabled: bool,

    /// Maximum number of cached embeddings.
    /// Constitution spec: 100,000 entries
    /// Default: 100_000
    #[serde(default = "default_max_entries")]
    pub max_entries: usize,

    /// Maximum cache size in bytes.
    /// Default: 1GB (1_073_741_824 bytes)
    /// This is the primary memory budget constraint.
    #[serde(default = "default_max_bytes")]
    pub max_bytes: usize,

    /// Time-to-live for cached entries in seconds.
    /// None = no expiration (entries evicted only by policy).
    /// Default: None
    #[serde(default)]
    pub ttl_seconds: Option<u64>,

    /// Eviction policy when cache is full.
    /// Default: Lru
    #[serde(default)]
    pub eviction_policy: EvictionPolicy,

    /// Whether to persist cache to disk on shutdown.
    /// Default: false
    #[serde(default)]
    pub persist_to_disk: bool,

    /// Path for disk persistence (required if persist_to_disk is true).
    /// Default: None
    #[serde(default)]
    pub disk_path: Option<PathBuf>,
}

fn default_cache_enabled() -> bool {
    true
}

fn default_max_entries() -> usize {
    100_000
}

fn default_max_bytes() -> usize {
    1_073_741_824 // 1 GB
}

impl Default for CacheConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_entries: 100_000,
            max_bytes: 1_073_741_824, // 1 GB
            ttl_seconds: None,
            eviction_policy: EvictionPolicy::Lru,
            persist_to_disk: false,
            disk_path: None,
        }
    }
}

impl CacheConfig {
    /// Validate cache configuration.
    ///
    /// # Errors
    /// Returns `EmbeddingError::ConfigError` if:
    /// - enabled && max_entries == 0
    /// - enabled && max_bytes == 0
    /// - persist_to_disk && disk_path.is_none()
    pub fn validate(&self) -> EmbeddingResult<()> {
        if self.enabled && self.max_entries == 0 {
            return Err(EmbeddingError::ConfigError {
                message: "max_entries must be > 0 when cache enabled".to_string(),
            });
        }
        if self.enabled && self.max_bytes == 0 {
            return Err(EmbeddingError::ConfigError {
                message: "max_bytes must be > 0 when cache enabled".to_string(),
            });
        }
        if self.persist_to_disk && self.disk_path.is_none() {
            return Err(EmbeddingError::ConfigError {
                message: "disk_path required when persist_to_disk enabled".to_string(),
            });
        }
        Ok(())
    }

    /// Create a disabled cache configuration.
    pub fn disabled() -> Self {
        Self {
            enabled: false,
            ..Default::default()
        }
    }

    /// Calculate the average bytes per entry based on current configuration.
    pub fn bytes_per_entry(&self) -> usize {
        if self.max_entries == 0 {
            0
        } else {
            self.max_bytes / self.max_entries
        }
    }
}

// ============================================================================
// GPU CONFIG STRUCT (REPLACE EXISTING)
// ============================================================================

/// Configuration for GPU usage.
///
/// Target hardware: RTX 5090 (32GB GDDR7, Compute 12.0, CUDA 13.1)
///
/// # Key Features
/// - Green Contexts: Static SM partitioning for deterministic latency
/// - Mixed Precision: FP16/BF16 for 2x throughput
/// - CUDA Graphs: Kernel fusion for reduced launch overhead
/// - GPU Direct Storage: 25+ GB/s model loading vs ~6 GB/s via CPU
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GpuConfig {
    /// Whether GPU acceleration is enabled.
    /// Default: true
    #[serde(default = "default_gpu_enabled")]
    pub enabled: bool,

    /// CUDA device IDs to use.
    /// Empty means auto-select first available device.
    /// Default: [0]
    #[serde(default = "default_device_ids")]
    pub device_ids: Vec<u32>,

    /// Fraction of GPU memory to use (0.0-1.0].
    /// Constitution spec: <24GB of 32GB = 0.75 max, default 0.9
    /// Reserve 10% for other operations.
    /// Default: 0.9
    #[serde(default = "default_memory_fraction")]
    pub memory_fraction: f32,

    /// Use CUDA graphs for kernel fusion.
    /// Reduces kernel launch overhead.
    /// Default: true
    #[serde(default = "default_use_cuda_graphs")]
    pub use_cuda_graphs: bool,

    /// Enable mixed precision (FP16/BF16) inference.
    /// Provides 2x throughput with minimal accuracy loss.
    /// Default: true
    #[serde(default = "default_mixed_precision")]
    pub mixed_precision: bool,

    /// Use CUDA 13.1 green contexts for power efficiency.
    /// Provides static SM partitioning for deterministic latency.
    /// Requires: CUDA 13.1+, Blackwell architecture (Compute 12.0)
    /// Default: false (requires explicit opt-in)
    #[serde(default)]
    pub green_contexts: bool,

    /// Whether to enable GPU Direct Storage (GDS) for fast model loading.
    /// Provides 25+ GB/s vs ~6 GB/s via CPU path.
    /// Requires: GDS driver, NVMe SSD
    /// Default: false
    #[serde(default)]
    pub gds_enabled: bool,
}

fn default_gpu_enabled() -> bool {
    true
}

fn default_device_ids() -> Vec<u32> {
    vec![0]
}

fn default_memory_fraction() -> f32 {
    0.9
}

fn default_use_cuda_graphs() -> bool {
    true
}

fn default_mixed_precision() -> bool {
    true
}

impl Default for GpuConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            device_ids: vec![0],
            memory_fraction: 0.9,
            use_cuda_graphs: true,
            mixed_precision: true,
            green_contexts: false,
            gds_enabled: false,
        }
    }
}

impl GpuConfig {
    /// Validate GPU configuration.
    ///
    /// # Errors
    /// Returns `EmbeddingError::ConfigError` if:
    /// - enabled && device_ids.is_empty()
    /// - memory_fraction <= 0.0 or > 1.0 or is NaN
    pub fn validate(&self) -> EmbeddingResult<()> {
        if self.enabled && self.device_ids.is_empty() {
            return Err(EmbeddingError::ConfigError {
                message: "device_ids cannot be empty when GPU enabled".to_string(),
            });
        }
        if self.memory_fraction <= 0.0 || self.memory_fraction > 1.0 || self.memory_fraction.is_nan() {
            return Err(EmbeddingError::ConfigError {
                message: format!(
                    "memory_fraction must be in (0.0, 1.0], got {}",
                    self.memory_fraction
                ),
            });
        }
        Ok(())
    }

    /// Create CPU-only configuration (GPU disabled).
    ///
    /// Use when:
    /// - No GPU available
    /// - Testing without CUDA
    /// - Fallback for non-Blackwell hardware
    pub fn cpu_only() -> Self {
        Self {
            enabled: false,
            device_ids: vec![],
            memory_fraction: 0.0,
            use_cuda_graphs: false,
            mixed_precision: false,
            green_contexts: false,
            gds_enabled: false,
        }
    }

    /// Create high-performance configuration for RTX 5090.
    ///
    /// Enables all optimizations:
    /// - CUDA graphs
    /// - Mixed precision
    /// - Green contexts
    /// - GDS (if available)
    pub fn rtx_5090_optimized() -> Self {
        Self {
            enabled: true,
            device_ids: vec![0],
            memory_fraction: 0.75, // Leave headroom for VRAM pressure
            use_cuda_graphs: true,
            mixed_precision: true,
            green_contexts: true,
            gds_enabled: true,
        }
    }

    /// Check if this config uses GPU acceleration.
    pub fn is_gpu_enabled(&self) -> bool {
        self.enabled && !self.device_ids.is_empty()
    }
}
```
  </signatures>

  <constraints>
    - max_bytes = 1GB default (fits 100K embeddings * 6KB each + overhead)
    - memory_fraction in (0.0, 1.0] - reserve 10% for other operations
    - device_ids required when GPU enabled (cannot be empty)
    - disk_path required when persist_to_disk enabled
    - green_contexts requires CUDA 13.1+ (RTX 5090 target)
    - EvictionPolicy must derive Copy for efficiency
    - All validation uses EmbeddingResult<()> not Result<(), String>
    - NO BACKWARDS COMPATIBILITY - old fields are removed, code must fail fast
  </constraints>

  <verification>
    - Default::default() passes validate() for both structs
    - CacheConfig default max_entries = 100_000
    - CacheConfig default max_bytes = 1_073_741_824 (1GB)
    - CacheConfig default eviction_policy = EvictionPolicy::Lru
    - CacheConfig default persist_to_disk = false
    - CacheConfig default disk_path = None
    - CacheConfig default ttl_seconds = None
    - GpuConfig default device_ids = [0]
    - GpuConfig default memory_fraction = 0.9
    - GpuConfig default use_cuda_graphs = true
    - GpuConfig default mixed_precision = true
    - GpuConfig default green_contexts = false
    - GpuConfig default gds_enabled = false
    - GpuConfig::cpu_only() has enabled = false
    - GpuConfig::cpu_only() has device_ids = []
    - GpuConfig::cpu_only() has memory_fraction = 0.0
    - GpuConfig::rtx_5090_optimized() has green_contexts = true
    - GpuConfig::rtx_5090_optimized() has gds_enabled = true
    - All EvictionPolicy variants serialize correctly (snake_case)
    - validate() rejects enabled cache with max_entries = 0
    - validate() rejects enabled cache with max_bytes = 0
    - validate() rejects persist_to_disk without disk_path
    - validate() rejects enabled GPU with empty device_ids
    - validate() rejects memory_fraction = 0.0
    - validate() rejects memory_fraction > 1.0
    - validate() rejects memory_fraction = NaN
    - Serde roundtrip preserves all fields (JSON and TOML)
  </verification>
</definition_of_done>

<files_to_modify>
  <file path="crates/context-graph-embeddings/src/config.rs">
    1. Add EvictionPolicy enum (insert before CacheConfig, around line 570)
    2. Replace CacheConfig struct (lines 575-631)
    3. Replace GpuConfig struct (lines 658-720)
    4. Update/add default_* functions
    5. Remove old functions: default_cache_path, default_ttl_seconds (u64 version), default_memory_limit, default_cuda_graphs
    6. Add new functions: default_max_bytes, default_memory_fraction, default_use_cuda_graphs, default_mixed_precision
  </file>
  <file path="crates/context-graph-embeddings/src/lib.rs">
    Export EvictionPolicy in pub use config::{...} statement
  </file>
</files_to_modify>

<validation_criteria>
  <criterion>cargo check --package context-graph-embeddings passes</criterion>
  <criterion>cargo test --package context-graph-embeddings passes</criterion>
  <criterion>cargo clippy --package context-graph-embeddings -- -D warnings shows 0 warnings</criterion>
  <criterion>CacheConfig has max_bytes field defaulting to 1GB</criterion>
  <criterion>CacheConfig has eviction_policy field defaulting to Lru</criterion>
  <criterion>CacheConfig has ttl_seconds as Option<u64> not u64</criterion>
  <criterion>GpuConfig has memory_fraction field defaulting to 0.9</criterion>
  <criterion>GpuConfig has mixed_precision field defaulting to true</criterion>
  <criterion>GpuConfig::cpu_only() exists and returns disabled config</criterion>
  <criterion>GpuConfig::rtx_5090_optimized() exists and enables all features</criterion>
  <criterion>All validation methods return EmbeddingResult not Result<(), String></criterion>
  <criterion>All tests use real validation logic, not mocks</criterion>
  <criterion>Old field names DO NOT EXIST: disk_persistence, cache_path, memory_limit, cuda_graphs, green_context_percentage</criterion>
</validation_criteria>
</task_spec>
```

---

## Implementation Guide

### Step 1: Add EvictionPolicy Enum

Insert BEFORE the CacheConfig struct definition (around line 570 in config.rs):

```rust
/// Cache eviction policy.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum EvictionPolicy {
    #[default]
    Lru,
    Lfu,
    TtlLru,
    Arc,
}

impl EvictionPolicy {
    pub fn all() -> &'static [EvictionPolicy] {
        &[EvictionPolicy::Lru, EvictionPolicy::Lfu, EvictionPolicy::TtlLru, EvictionPolicy::Arc]
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            EvictionPolicy::Lru => "lru",
            EvictionPolicy::Lfu => "lfu",
            EvictionPolicy::TtlLru => "ttl_lru",
            EvictionPolicy::Arc => "arc",
        }
    }
}
```

### Step 2: Replace CacheConfig Struct

Delete the existing CacheConfig struct and all its impl blocks and default functions (lines 575-631 approximately), then replace with the implementation from the `<signatures>` section above.

### Step 3: Replace GpuConfig Struct

Delete the existing GpuConfig struct and all its impl blocks and default functions (lines 658-720 approximately), then replace with the implementation from the `<signatures>` section above.

### Step 4: Update lib.rs Exports

In `crates/context-graph-embeddings/src/lib.rs`, add EvictionPolicy to the exports:

```rust
pub use config::{
    BatchConfig, CacheConfig, EmbeddingConfig, EvictionPolicy, FusionConfig,
    GpuConfig, ModelRegistryConfig, PaddingStrategy, SingleModelConfig,
};
```

### Step 5: Add Required Import

At the top of config.rs, ensure `std::path::PathBuf` is imported:

```rust
use std::path::PathBuf;
```

### Step 6: Remove Old Compatibility Code

Search the entire codebase and remove any references to:
- `disk_persistence` (replaced by `persist_to_disk`)
- `cache_path` (replaced by `disk_path`)
- `memory_limit` (replaced by `memory_fraction`)
- `cuda_graphs` (replaced by `use_cuda_graphs`)
- `green_context_percentage` (replaced by `green_contexts`)

If any code uses these old field names, it should FAIL TO COMPILE. Do not add compatibility shims.

---

## Test Cases (Minimum Required - 35 Tests)

### EvictionPolicy Tests (4 tests)
1. `test_eviction_policy_default` - Default is Lru
2. `test_eviction_policy_all_variants` - all() returns 4 variants
3. `test_eviction_policy_as_str` - Correct string representation for each variant
4. `test_eviction_policy_serde_roundtrip` - JSON serialization works for all variants

### CacheConfig Default Tests (7 tests)
5. `test_cache_default_enabled` - true
6. `test_cache_default_max_entries` - 100_000
7. `test_cache_default_max_bytes` - 1_073_741_824
8. `test_cache_default_ttl_seconds` - None
9. `test_cache_default_eviction_policy` - Lru
10. `test_cache_default_persist_to_disk` - false
11. `test_cache_default_disk_path` - None

### CacheConfig Validation Tests (6 tests)
12. `test_cache_validate_valid` - Default passes validation
13. `test_cache_validate_max_entries_zero` - Returns EmbeddingError::ConfigError
14. `test_cache_validate_max_bytes_zero` - Returns EmbeddingError::ConfigError
15. `test_cache_validate_persist_without_path` - Returns EmbeddingError::ConfigError
16. `test_cache_validate_disabled_allows_zero` - Disabled cache allows 0 values
17. `test_cache_validate_with_disk_path` - persist_to_disk=true with valid path passes

### CacheConfig Method Tests (2 tests)
18. `test_cache_disabled_constructor` - disabled() returns enabled=false
19. `test_cache_bytes_per_entry` - Correct calculation (1GB / 100K = 10,737 bytes)

### GpuConfig Default Tests (7 tests)
20. `test_gpu_default_enabled` - true
21. `test_gpu_default_device_ids` - [0]
22. `test_gpu_default_memory_fraction` - 0.9
23. `test_gpu_default_use_cuda_graphs` - true
24. `test_gpu_default_mixed_precision` - true
25. `test_gpu_default_green_contexts` - false
26. `test_gpu_default_gds_enabled` - false

### GpuConfig Validation Tests (5 tests)
27. `test_gpu_validate_valid` - Default passes validation
28. `test_gpu_validate_empty_devices` - Returns EmbeddingError::ConfigError
29. `test_gpu_validate_memory_fraction_zero` - Returns EmbeddingError::ConfigError
30. `test_gpu_validate_memory_fraction_above_one` - Returns EmbeddingError::ConfigError
31. `test_gpu_validate_memory_fraction_nan` - Returns EmbeddingError::ConfigError

### GpuConfig Constructor Tests (4 tests)
32. `test_gpu_cpu_only_enabled` - enabled = false
33. `test_gpu_cpu_only_device_ids` - device_ids = []
34. `test_gpu_cpu_only_memory_fraction` - memory_fraction = 0.0
35. `test_gpu_rtx_5090_optimized` - green_contexts = true, gds_enabled = true

### Serde Tests (2 tests)
36. `test_cache_serde_roundtrip` - All fields preserved through JSON roundtrip
37. `test_gpu_serde_roundtrip` - All fields preserved through TOML roundtrip

---

## Full State Verification Requirements

After completing the implementation, you MUST perform Full State Verification:

### 1. Source of Truth

The source of truth for these configurations is:
- **File**: `crates/context-graph-embeddings/src/config.rs`
- **Structs**: `EvictionPolicy`, `CacheConfig`, `GpuConfig`
- **Test module**: `mod tests` within the same file

### 2. Execute & Inspect

After making changes, run these commands and verify output:

```bash
# Build check - must pass with 0 errors
cargo check --package context-graph-embeddings

# Run all tests - must show all tests passing
cargo test --package context-graph-embeddings -- --nocapture 2>&1 | grep -E "(test_|PASSED|FAILED|ok|running)"

# Clippy - must show 0 warnings
cargo clippy --package context-graph-embeddings -- -D warnings

# Verify specific test categories pass
cargo test --package context-graph-embeddings test_cache -- --nocapture
cargo test --package context-graph-embeddings test_gpu -- --nocapture
cargo test --package context-graph-embeddings test_eviction -- --nocapture
```

### 3. Boundary & Edge Case Audit

Manually verify these 3 edge cases by adding test assertions:

**Edge Case 1: memory_fraction at boundary (1.0)**
```rust
#[test]
fn test_gpu_memory_fraction_boundary_one() {
    let config = GpuConfig { memory_fraction: 1.0, ..Default::default() };
    println!("BEFORE: memory_fraction={}", config.memory_fraction);
    let result = config.validate();
    println!("AFTER: validate result = {:?}", result);
    assert!(result.is_ok(), "memory_fraction=1.0 should be valid (inclusive upper bound)");
}
```

**Edge Case 2: CacheConfig disabled allows zero entries**
```rust
#[test]
fn test_cache_disabled_allows_zero_entries() {
    let config = CacheConfig {
        enabled: false,
        max_entries: 0,
        max_bytes: 0,
        ..Default::default()
    };
    println!("BEFORE: enabled={}, max_entries={}, max_bytes={}",
             config.enabled, config.max_entries, config.max_bytes);
    let result = config.validate();
    println!("AFTER: validate result = {:?}", result);
    assert!(result.is_ok(), "Disabled cache should allow zero values");
}
```

**Edge Case 3: EvictionPolicy serde with all variants**
```rust
#[test]
fn test_eviction_policy_serde_all_variants() {
    for policy in EvictionPolicy::all() {
        let json = serde_json::to_string(policy).unwrap();
        println!("BEFORE: {:?} -> serialized: {}", policy, json);
        let deserialized: EvictionPolicy = serde_json::from_str(&json).unwrap();
        println!("AFTER: deserialized: {:?}", deserialized);
        assert_eq!(*policy, deserialized, "Roundtrip failed for {:?}", policy);
    }
}
```

### 4. Evidence of Success

After all tests pass, capture this evidence:

```bash
# Capture test results to file
cargo test --package context-graph-embeddings 2>&1 | tee /tmp/cache_gpu_config_test_results.txt

# Verify key tests passed
grep -E "test_cache_default" /tmp/cache_gpu_config_test_results.txt
grep -E "test_gpu_cpu_only" /tmp/cache_gpu_config_test_results.txt
grep -E "test_eviction_policy" /tmp/cache_gpu_config_test_results.txt

# Show final test summary
tail -10 /tmp/cache_gpu_config_test_results.txt
```

Expected output should show:
- `test result: ok. X passed; 0 failed`
- All cache and GPU config tests passing
- No clippy warnings

### 5. Manual Output Verification

For any struct created, print and verify the values:

```rust
// After creating default CacheConfig
let cache = CacheConfig::default();
println!("CacheConfig::default() = {:?}", cache);
// VERIFY: max_bytes = 1073741824, eviction_policy = Lru, ttl_seconds = None

// After creating GpuConfig::cpu_only()
let gpu = GpuConfig::cpu_only();
println!("GpuConfig::cpu_only() = {:?}", gpu);
// VERIFY: enabled = false, device_ids = [], memory_fraction = 0.0

// After creating GpuConfig::rtx_5090_optimized()
let gpu_opt = GpuConfig::rtx_5090_optimized();
println!("GpuConfig::rtx_5090_optimized() = {:?}", gpu_opt);
// VERIFY: green_contexts = true, gds_enabled = true, memory_fraction = 0.75
```

---

## Final Verification Step (MANDATORY)

**After completing all implementation and tests, use the `sherlock-holmes` subagent to perform forensic verification:**

The sherlock-holmes agent MUST verify ALL of the following:

1. **EvictionPolicy enum exists** with exactly 4 variants: Lru, Lfu, TtlLru, Arc
2. **EvictionPolicy has #[derive(Copy)]** for efficiency
3. **CacheConfig has all required fields**: enabled, max_entries, max_bytes, ttl_seconds (Option<u64>), eviction_policy, persist_to_disk, disk_path (Option<PathBuf>)
4. **GpuConfig has all required fields**: enabled, device_ids, memory_fraction, use_cuda_graphs, mixed_precision, green_contexts, gds_enabled
5. **Default values are correct** per the specification above
6. **GpuConfig::cpu_only()** exists and returns config with enabled=false, device_ids=[], memory_fraction=0.0
7. **GpuConfig::rtx_5090_optimized()** exists and returns config with green_contexts=true, gds_enabled=true
8. **All validate() methods return EmbeddingResult<()>** not Result<(), String>
9. **Old field names are COMPLETELY REMOVED**: disk_persistence, cache_path, memory_limit, cuda_graphs (without use_ prefix), green_context_percentage
10. **No backward compatibility hacks or workarounds exist**
11. **All tests use real validation logic, not mocks**
12. **EvictionPolicy is exported from lib.rs**
13. **std::path::PathBuf is properly imported**
14. **cargo check, cargo test, and cargo clippy all pass with 0 errors/warnings**

The sherlock-holmes agent must confirm the implementation is complete and correct before this task can be marked as done.

---

## Example TOML Configuration

After implementation, this TOML should parse correctly:

```toml
[cache]
enabled = true
max_entries = 100000
max_bytes = 1073741824
ttl_seconds = 3600
eviction_policy = "lru"
persist_to_disk = true
disk_path = "/var/cache/context-graph/embeddings"

[gpu]
enabled = true
device_ids = [0]
memory_fraction = 0.9
use_cuda_graphs = true
mixed_precision = true
green_contexts = true
gds_enabled = false
```

---

*Task ID: M03-F15*
*Module: 03 - 12-Model Embedding Pipeline*
*Layer: Foundation*
*Created: 2026-01-01*
*Updated: 2026-01-01*
*Version: 3.0*
