# M05-T19: Implement LifecycleManager State Machine

```yaml
metadata:
  id: "M05-T19"
  title: "Implement LifecycleManager State Machine"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "surface"
  priority: "critical"
  estimated_hours: 3
  created: "2026-01-04"
  updated: "2026-01-04"
  status: "COMPLETE"
  dependencies:
    - "M05-T05"  # LifecycleStage enum
    - "M05-T06"  # LifecycleLambdaWeights struct
    - "M05-T07"  # LifecycleConfig and StageConfig
  spec_refs:
    - "constitution.yaml lines 164-167"
    - "contextprd.md Section 2.4"
    - "learntheory.md - Marblestone model"
```

---

## CRITICAL: Current Implementation State

**STATUS: COMPLETE - 68 tests passing**

The `LifecycleManager` and all related types are **fully implemented** in `crates/context-graph-utl/src/lifecycle/`. This task document describes the verified implementation.

**Verification Command:**
```bash
cargo test -p context-graph-utl --lib lifecycle 2>&1 | grep -E "(running|test result)"
# Expected: running 68 tests
#           test result: ok. 68 passed
```

**Git Reference:** `f521803 feat(utl): complete context-graph-utl crate with 453 tests passing`

---

## File Locations (VERIFIED)

| File | Path | Lines | Purpose |
|------|------|-------|---------|
| Module root | `crates/context-graph-utl/src/lifecycle/mod.rs` | 55 | Re-exports public types |
| LifecycleManager | `crates/context-graph-utl/src/lifecycle/manager.rs` | 877 | State machine implementation |
| LifecycleStage | `crates/context-graph-utl/src/lifecycle/stage.rs` | 598 | Stage enum and transitions |
| LifecycleLambdaWeights | `crates/context-graph-utl/src/lifecycle/lambda.rs` | 642 | Lambda weight computation |
| LifecycleConfig | `crates/context-graph-utl/src/config.rs` | Lines 643-758 | Configuration struct |

---

## Constitution Reference (Source of Truth)

From `docs2/constitution.yaml` lines 164-167:

```yaml
lifecycle:  # Marblestone λ weights
  infancy:  { n: "0-50",   ΔS_trig: 0.9, ΔC_trig: 0.2, λ_ΔS: 0.7, λ_ΔC: 0.3, stance: "capture-novelty" }
  growth:   { n: "50-500", ΔS_trig: 0.7, ΔC_trig: 0.4, λ_ΔS: 0.5, λ_ΔC: 0.5, stance: "balanced" }
  maturity: { n: "500+",  ΔS_trig: 0.6, ΔC_trig: 0.5, λ_ΔS: 0.3, λ_ΔC: 0.7, stance: "curation-coherence" }
```

---

## Implemented Types

### LifecycleStage Enum (`lifecycle/stage.rs:40-66`)

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum LifecycleStage {
    Infancy,   // 0-49 interactions, λ_s=0.7, λ_c=0.3
    Growth,    // 50-499 interactions, λ_s=0.5, λ_c=0.5
    Maturity,  // 500+ interactions, λ_s=0.3, λ_c=0.7
}
```

**Key Constants:**
- `INFANCY_THRESHOLD: u64 = 50`
- `GROWTH_THRESHOLD: u64 = 500`

**Key Methods:**
| Method | Signature | Purpose |
|--------|-----------|---------|
| `from_interaction_count` | `fn(count: u64) -> Self` | Determine stage from count |
| `interaction_range` | `fn(&self) -> (u64, u64)` | Get (min, max) range |
| `stance` | `fn(&self) -> &'static str` | Get stance name |
| `next_stage` | `fn(&self) -> Option<LifecycleStage>` | Get next stage |
| `can_transition_to` | `fn(&self, target: Self) -> bool` | Validate transition |

### LifecycleLambdaWeights (`lifecycle/lambda.rs:49-56`)

```rust
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct LifecycleLambdaWeights {
    lambda_s: f32,  // Surprise/novelty weight [0.0, 1.0]
    lambda_c: f32,  // Coherence/consolidation weight [0.0, 1.0]
}
```

**Invariant:** `lambda_s + lambda_c == 1.0` (enforced, EPSILON = 0.001)

**Key Methods:**
| Method | Signature | Purpose |
|--------|-----------|---------|
| `new` | `fn(lambda_s: f32, lambda_c: f32) -> UtlResult<Self>` | Validated creation |
| `for_stage` | `fn(stage: LifecycleStage) -> Self` | Get canonical weights |
| `for_interaction_count` | `fn(count: u64) -> Self` | Auto-determine stage |
| `interpolated` | `fn(count: u64, config: &LifecycleConfig) -> Self` | Smooth transitions |
| `apply` | `fn(&self, delta_s: f32, delta_c: f32) -> f32` | Weight surprise/coherence |
| `focus` | `fn(&self) -> &'static str` | Get "surprise"/"balanced"/"coherence" |

**Canonical Weights by Stage:**
| Stage | lambda_s | lambda_c | Focus |
|-------|----------|----------|-------|
| Infancy | 0.7 | 0.3 | surprise |
| Growth | 0.5 | 0.5 | balanced |
| Maturity | 0.3 | 0.7 | coherence |

### LifecycleManager (`lifecycle/manager.rs:52-74`)

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LifecycleManager {
    interaction_count: u64,          // Total interactions
    current_stage: LifecycleStage,   // Current stage
    auto_transition: bool,           // Enable automatic transitions
    transition_hysteresis: u64,      // Prevent rapid switching
    last_transition_count: u64,      // Count at last transition
    smooth_transitions: bool,        // Enable interpolated weights
    smoothing_window: u64,           // Interpolation window size
}
```

**Key Methods:**
| Method | Signature | Purpose |
|--------|-----------|---------|
| `new` | `fn(config: &LifecycleConfig) -> Self` | Create from config |
| `with_count` | `fn(config: &LifecycleConfig, count: u64) -> Self` | Create with initial count |
| `current_stage` | `fn(&self) -> LifecycleStage` | Get current stage |
| `interaction_count` | `fn(&self) -> u64` | Get total interactions |
| `current_weights` | `fn(&self) -> LifecycleLambdaWeights` | Get discrete weights |
| `interpolated_weights` | `fn(&self, config: &LifecycleConfig) -> LifecycleLambdaWeights` | Get smooth weights |
| `increment` | `fn(&mut self) -> bool` | Add 1 interaction, returns true if transitioned |
| `increment_by` | `fn(&mut self, count: u64) -> bool` | Add N interactions |
| `transition_to` | `fn(&mut self, stage: LifecycleStage) -> UtlResult<()>` | Manual transition |
| `reset` | `fn(&mut self)` | Reset to Infancy |
| `stage_progress` | `fn(&self) -> f64` | Progress % through current stage |
| `interactions_until_next_stage` | `fn(&self) -> Option<u64>` | Interactions remaining |
| `current_stance` | `fn(&self) -> &'static str` | Get stance string |

### LifecycleConfig (`config.rs:643-658`)

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LifecycleConfig {
    pub stages: Vec<StageConfig>,       // [Infancy, Growth, Maturity]
    pub auto_transition: bool,          // Default: true
    pub transition_hysteresis: u64,     // Default: 10
    pub smooth_transitions: bool,       // Default: true
    pub smoothing_window: u64,          // Default: 25
}
```

---

## How to Use (Integration Guide)

### Basic Usage

```rust
use context_graph_utl::config::LifecycleConfig;
use context_graph_utl::lifecycle::{LifecycleManager, LifecycleStage, LifecycleLambdaWeights};

// Create manager
let config = LifecycleConfig::default();
let mut manager = LifecycleManager::new(&config);

// Check initial state
assert_eq!(manager.current_stage(), LifecycleStage::Infancy);
assert_eq!(manager.interaction_count(), 0);

// Record interactions
for _ in 0..50 {
    let transitioned = manager.increment();
    if transitioned {
        println!("Transitioned to: {}", manager.current_stage());
    }
}

// Get weights for UTL computation
let weights = manager.current_weights();
let learning_delta = weights.apply(delta_s, delta_c);
```

### Smooth Transitions (at stage boundaries)

```rust
let config = LifecycleConfig::default();
let manager = LifecycleManager::with_count(&config, 55);

// Returns interpolated weights near boundary
let smooth_weights = manager.interpolated_weights(&config);
// lambda_s will be between 0.5 and 0.7
```

### Manual Transitions

```rust
let config = LifecycleConfig::default();
let mut manager = LifecycleManager::new(&config);

// Forward transitions allowed
manager.transition_to(LifecycleStage::Maturity)?;

// Backward transitions ERROR
let result = manager.transition_to(LifecycleStage::Infancy);
assert!(result.is_err()); // InvalidLifecycleTransition error
```

---

## Acceptance Criteria (ALL VERIFIED)

- [x] `LifecycleStage` enum with Infancy, Growth, Maturity variants
- [x] `LifecycleLambdaWeights` with validated weight sum = 1.0
- [x] `LifecycleManager` tracks interaction count and current stage
- [x] Stage transitions at correct thresholds:
  - [x] Infancy → Growth at 50 interactions
  - [x] Growth → Maturity at 500 interactions
- [x] Lambda weights per stage:
  - [x] Infancy: lambda_s=0.7, lambda_c=0.3
  - [x] Growth: lambda_s=0.5, lambda_c=0.5
  - [x] Maturity: lambda_s=0.3, lambda_c=0.7
- [x] Smooth interpolation at stage boundaries
- [x] Hysteresis to prevent rapid stage switching
- [x] Manual transition with forward-only validation
- [x] Serialization/deserialization (serde)
- [x] 68 unit tests passing

---

## Test Summary

### Test Categories (68 total)

| Category | Count | File |
|----------|-------|------|
| LifecycleStage | 18 | `stage.rs` |
| LifecycleLambdaWeights | 25 | `lambda.rs` |
| LifecycleManager | 25 | `manager.rs` |

### Key Test Cases

```rust
// Stage transitions at correct thresholds
#[test] fn test_auto_transition_to_growth()    // at 50
#[test] fn test_auto_transition_to_maturity()  // at 500

// Lambda weight invariant
#[test] fn test_all_stages_weights_sum_to_one()

// Smooth interpolation
#[test] fn test_interpolated_with_smoothing()

// Manual transition validation
#[test] fn test_invalid_backward_transition()

// Full lifecycle progression
#[test] fn test_full_lifecycle_progression()
```

---

## Full State Verification Protocol

### Source of Truth

The lifecycle state is stored in `LifecycleManager` struct fields:
- `interaction_count: u64` - Total recorded interactions
- `current_stage: LifecycleStage` - Current lifecycle stage
- `last_transition_count: u64` - Count at last transition

### Execute & Inspect Pattern

```rust
// 1. Execute operation
let mut manager = LifecycleManager::new(&config);
let transitioned = manager.increment_by(50);

// 2. Read Source of Truth
assert_eq!(manager.interaction_count(), 50);      // Count updated
assert_eq!(manager.current_stage(), LifecycleStage::Growth); // Stage changed
assert!(transitioned);                            // Transition occurred

// 3. Verify side effects
let weights = manager.current_weights();
assert!((weights.lambda_s() - 0.5).abs() < 0.001); // Weights updated
assert_eq!(manager.current_stance(), "balanced");   // Stance updated
```

### Edge Case Verification (REQUIRED)

**Edge Case 1: Boundary at exactly threshold**
```rust
// State BEFORE: count=49, stage=Infancy
let mut manager = LifecycleManager::with_count(&config, 49);
println!("BEFORE: count={}, stage={}", manager.interaction_count(), manager.current_stage());
// Expected: count=49, stage=Infancy

// Execute
manager.increment();

// State AFTER: count=50, stage=Growth
println!("AFTER: count={}, stage={}", manager.interaction_count(), manager.current_stage());
// Expected: count=50, stage=Growth
```

**Edge Case 2: Overflow protection (saturating_add)**
```rust
// State BEFORE: count=u64::MAX - 1
let mut manager = LifecycleManager::with_count(&config, u64::MAX - 1);
println!("BEFORE: count={}", manager.interaction_count());

// Execute (should saturate, not overflow)
manager.increment_by(10);

// State AFTER: count=u64::MAX (saturated)
println!("AFTER: count={}", manager.interaction_count());
assert_eq!(manager.interaction_count(), u64::MAX);
```

**Edge Case 3: Backward transition rejection**
```rust
// State BEFORE: stage=Maturity
let mut manager = LifecycleManager::with_count(&config, 600);
println!("BEFORE: stage={}", manager.current_stage());
// Expected: stage=Maturity

// Execute (should fail)
let result = manager.transition_to(LifecycleStage::Infancy);

// State AFTER: stage unchanged, error returned
println!("AFTER: stage={}, error={:?}", manager.current_stage(), result.err());
// Expected: stage=Maturity (unchanged), error=InvalidLifecycleTransition
assert!(result.is_err());
assert_eq!(manager.current_stage(), LifecycleStage::Maturity);
```

---

## Manual Verification Commands

```bash
# 1. Run all lifecycle tests
cargo test -p context-graph-utl --lib lifecycle -- --nocapture

# 2. Verify specific test
cargo test -p context-graph-utl --lib test_full_lifecycle_progression -- --nocapture

# 3. Check module compiles cleanly
cargo check -p context-graph-utl 2>&1 | grep -E "(error|warning.*lifecycle)"

# 4. Run with logging to see transitions
RUST_LOG=debug cargo test -p context-graph-utl --lib lifecycle -- --nocapture
```

---

## Dependencies

| Dependency | Crate | Purpose |
|------------|-------|---------|
| M05-T05 | context-graph-utl | LifecycleStage enum |
| M05-T06 | context-graph-utl | LifecycleLambdaWeights struct |
| M05-T07 | context-graph-utl | LifecycleConfig struct |
| chrono (removed) | - | Timestamps NOT used in current impl |
| serde | external | Serialization |

---

## Related Tasks

| Task ID | Relationship |
|---------|--------------|
| M05-T05 | Provides LifecycleStage enum |
| M05-T06 | Provides LifecycleLambdaWeights |
| M05-T07 | Provides LifecycleConfig |
| M05-T22 | UtlProcessor uses LifecycleManager |
| M05-T39 | Persists lifecycle state to RocksDB |
| M05-T62 | Dynamic thresholds by lifecycle stage |

---

## Final Verification Checklist

Before marking complete, verify:

- [ ] All 68 lifecycle tests pass: `cargo test -p context-graph-utl --lib lifecycle`
- [ ] No compiler warnings in lifecycle module
- [ ] Lambda weights sum to 1.0 for all stages
- [ ] Stage transitions occur at exact thresholds (50, 500)
- [ ] Backward transitions return error (not panic)
- [ ] Serialization round-trips correctly
- [ ] Edge cases (boundary, overflow, backward) all handled

---

## SHERLOCK VERIFICATION REQUIRED

After completing any changes, run:

```bash
# Sherlock will verify:
# 1. All tests pass
# 2. No regressions
# 3. Edge cases covered
# 4. Implementation matches spec
```

Use the `sherlock-holmes` subagent to perform final verification of this task.

---

*Task updated: 2026-01-04*
*Implementation verified against crate version in git commit f521803*
*68 tests passing, all acceptance criteria met*
