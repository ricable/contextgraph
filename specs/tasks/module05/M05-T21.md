# M05-T21: Implement LearningSignal and UtlState Structs

```yaml
task_id: M05-T21
title: "Implement LearningSignal and UtlState Structs"
module: "Module 05: UTL Integration"
layer: "surface"
priority: "critical"
status: "pending"
estimated_hours: 3
created: "2026-01-04"
updated: "2026-01-04"

# VERIFIED PATHS - Audited 2026-01-04
implementation_file: "crates/context-graph-utl/src/lib.rs"
test_location: "crates/context-graph-utl/src/lib.rs (inline #[cfg(test)])"

dependencies:
  - task: "M05-T06"
    provides: "LifecycleLambdaWeights"
    location: "crates/context-graph-utl/src/lifecycle/lambda.rs:50"
    status: "COMPLETE"
  - task: "M05-T08"
    provides: "JohariQuadrant"
    location: "crates/context-graph-core/src/types/johari/quadrant.rs:23"
    re_exported: "crates/context-graph-utl/src/johari/mod.rs:42"
    status: "COMPLETE"
  - task: "M05-T08"
    provides: "SuggestedAction"
    location: "crates/context-graph-utl/src/johari/retrieval.rs:42"
    status: "COMPLETE"
    note: "REQUIRES adding Serialize, Deserialize derives - see Prerequisite section"
  - task: "M05-T23"
    provides: "UtlError"
    location: "crates/context-graph-utl/src/error.rs:11"
    status: "COMPLETE"

spec_refs:
  - "constitution.yaml lines 148-167 (UTL parameters)"
  - "contextprd.md Section 2.1 (UTL formula)"
  - "learntheory.md (Canonical form: L = f((ΔS × ΔC) · wₑ · cos φ))"
```

---

## ⚠️ PREREQUISITE: Fix SuggestedAction Serialization

**BEFORE implementing the main task, you MUST add Serialize/Deserialize to SuggestedAction.**

`SuggestedAction` at `crates/context-graph-utl/src/johari/retrieval.rs:41` currently derives:
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
```

It MUST be changed to:
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
```

And add the import at the top of `retrieval.rs`:
```rust
use serde::{Deserialize, Serialize};
```

**Verification after fix:**
```bash
cargo build -p context-graph-utl
# Should compile without errors
```

This is required because `LearningSignal` contains `SuggestedAction` as a field and derives `Serialize, Deserialize`.

---

## CRITICAL: Current Codebase State

**THESE STRUCTS DO NOT EXIST YET.** This task requires IMPLEMENTATION, not modification.

### Verified Codebase State (2026-01-04)

```bash
# Verification command - run this first to confirm state:
grep -r "pub struct LearningSignal\|pub struct UtlState\|pub enum LearningIntensity" crates/context-graph-utl/src/
# Expected: NO OUTPUT (structs don't exist yet)

# Verify tests pass before changes:
cargo test -p context-graph-utl --lib 2>&1 | tail -3
# Expected: test result: ok. 369 passed; 0 failed;
```

### Existing Infrastructure (Use These - DO NOT DUPLICATE)

| Type | Location | Import Path |
|------|----------|-------------|
| `JohariQuadrant` | `context-graph-core/src/types/johari/quadrant.rs:23` | `use crate::johari::JohariQuadrant;` |
| `SuggestedAction` | `context-graph-utl/src/johari/retrieval.rs:42` | `use crate::johari::SuggestedAction;` |
| `LifecycleLambdaWeights` | `context-graph-utl/src/lifecycle/lambda.rs:50` | `use crate::lifecycle::LifecycleLambdaWeights;` |
| `UtlError` | `context-graph-utl/src/error.rs:11` | `use crate::error::UtlError;` |
| `UtlResult` | `context-graph-utl/src/error.rs:124` | `use crate::error::UtlResult;` |

---

## Task Description

Implement two core structs in `crates/context-graph-utl/src/lib.rs`:

1. **`LearningSignal`** - Complete UTL computation output with all component values
2. **`UtlState`** - Compact persistent storage format for MemoryNode
3. **`LearningIntensity`** - Simple enum for categorizing learning magnitude

These structs bridge the computation layer (surprise, coherence, phase) with the storage layer (MemoryNode).

---

## Implementation Requirements

### 1. LearningSignal Struct

Add after line 102 in `crates/context-graph-utl/src/lib.rs` (after `compute_learning_magnitude` function):

```rust
use chrono::{DateTime, Utc};

/// Learning intensity category for quick classification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[repr(u8)]
pub enum LearningIntensity {
    /// Learning magnitude < 0.3
    Low = 0,
    /// Learning magnitude 0.3 - 0.7
    Medium = 1,
    /// Learning magnitude > 0.7
    High = 2,
}

/// Complete UTL computation output with all component values and derived decisions.
///
/// This struct captures the full result of a UTL computation including:
/// - Raw component values (delta_s, delta_c, w_e, phi)
/// - Computed learning magnitude
/// - Johari classification and suggested action
/// - Storage/consolidation recommendations
/// - Performance metrics (latency)
///
/// # Constitution Reference
/// - ΔS: [0,1] entropy/novelty (constitution.yaml:154)
/// - ΔC: [0,1] coherence/understanding (constitution.yaml:155)
/// - wₑ: [0.5,1.5] emotional weight (constitution.yaml:156)
/// - φ: [0,π] phase sync (constitution.yaml:157)
///
/// # Example
/// ```
/// use context_graph_utl::{LearningSignal, JohariQuadrant};
/// use context_graph_utl::johari::SuggestedAction;
///
/// let signal = LearningSignal::new(
///     0.7, 0.6, 0.8, 1.2, 0.5,
///     None,
///     JohariQuadrant::Open,
///     SuggestedAction::DirectRecall,
///     false, true, 1500,
/// ).expect("Valid signal");
///
/// assert!(signal.magnitude >= 0.0 && signal.magnitude <= 1.0);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningSignal {
    /// Learning magnitude L in [0, 1], computed from formula
    pub magnitude: f32,

    /// Surprise (entropy) value [0, 1]
    pub delta_s: f32,

    /// Coherence value [0, 1]
    pub delta_c: f32,

    /// Emotional weight [0.5, 1.5]
    pub w_e: f32,

    /// Phase angle [0, PI]
    pub phi: f32,

    /// Marblestone lambda weights if lifecycle-adjusted
    pub lambda_weights: Option<LifecycleLambdaWeights>,

    /// Classified Johari quadrant
    pub quadrant: JohariQuadrant,

    /// Recommended retrieval action based on quadrant
    pub suggested_action: SuggestedAction,

    /// Whether consolidation is recommended (magnitude > 0.6)
    pub should_consolidate: bool,

    /// Whether storage is recommended (magnitude > 0.3)
    pub should_store: bool,

    /// When computation was performed (UTC)
    pub timestamp: DateTime<Utc>,

    /// Computation time in microseconds for performance tracking
    pub latency_us: u64,
}

impl LearningSignal {
    /// Create a new LearningSignal with validation.
    ///
    /// # Arguments
    /// * `magnitude` - Pre-computed learning magnitude [0, 1]
    /// * `delta_s` - Surprise component [0, 1]
    /// * `delta_c` - Coherence component [0, 1]
    /// * `w_e` - Emotional weight [0.5, 1.5]
    /// * `phi` - Phase angle [0, π]
    /// * `lambda_weights` - Optional lifecycle weights
    /// * `quadrant` - Johari classification
    /// * `suggested_action` - Recommended action
    /// * `should_consolidate` - Consolidation flag
    /// * `should_store` - Storage flag
    /// * `latency_us` - Computation time in microseconds
    ///
    /// # Returns
    /// `Ok(LearningSignal)` if valid, `Err(UtlError)` if magnitude is NaN/Infinity
    ///
    /// # Errors
    /// Returns `UtlError::InvalidComputation` if magnitude is NaN or Infinity
    pub fn new(
        magnitude: f32,
        delta_s: f32,
        delta_c: f32,
        w_e: f32,
        phi: f32,
        lambda_weights: Option<LifecycleLambdaWeights>,
        quadrant: JohariQuadrant,
        suggested_action: SuggestedAction,
        should_consolidate: bool,
        should_store: bool,
        latency_us: u64,
    ) -> UtlResult<Self> {
        let signal = Self {
            magnitude,
            delta_s,
            delta_c,
            w_e,
            phi,
            lambda_weights,
            quadrant,
            suggested_action,
            should_consolidate,
            should_store,
            timestamp: Utc::now(),
            latency_us,
        };

        signal.validate()?;
        Ok(signal)
    }

    /// Validate that magnitude is finite (not NaN or Infinity).
    ///
    /// # Returns
    /// `Ok(())` if valid, `Err(UtlError::InvalidComputation)` otherwise
    pub fn validate(&self) -> UtlResult<()> {
        if self.magnitude.is_nan() {
            return Err(UtlError::InvalidComputation {
                delta_s: self.delta_s,
                delta_c: self.delta_c,
                w_e: self.w_e,
                phi: self.phi,
                reason: "magnitude is NaN".to_string(),
            });
        }

        if self.magnitude.is_infinite() {
            return Err(UtlError::InvalidComputation {
                delta_s: self.delta_s,
                delta_c: self.delta_c,
                w_e: self.w_e,
                phi: self.phi,
                reason: "magnitude is Infinity".to_string(),
            });
        }

        // Also check component values for NaN (fail fast)
        if self.delta_s.is_nan() || self.delta_c.is_nan()
           || self.w_e.is_nan() || self.phi.is_nan() {
            return Err(UtlError::InvalidComputation {
                delta_s: self.delta_s,
                delta_c: self.delta_c,
                w_e: self.w_e,
                phi: self.phi,
                reason: "component value is NaN".to_string(),
            });
        }

        Ok(())
    }

    /// Check if this signal indicates high learning potential (> 0.7)
    #[inline]
    pub fn is_high_learning(&self) -> bool {
        self.magnitude > 0.7
    }

    /// Check if this signal indicates low learning potential (< 0.3)
    #[inline]
    pub fn is_low_learning(&self) -> bool {
        self.magnitude < 0.3
    }

    /// Get the learning intensity category
    #[inline]
    pub fn intensity_category(&self) -> LearningIntensity {
        if self.magnitude < 0.3 {
            LearningIntensity::Low
        } else if self.magnitude < 0.7 {
            LearningIntensity::Medium
        } else {
            LearningIntensity::High
        }
    }
}
```

### 2. UtlState Struct

Add immediately after `LearningSignal`:

```rust
/// Compact UTL state for storage in MemoryNode.
///
/// This is the persistent representation stored with each memory node,
/// containing only the essential values needed for retrieval decisions.
/// Use `UtlState::from_signal()` to convert from a full `LearningSignal`.
///
/// # Example
/// ```
/// use context_graph_utl::{LearningSignal, UtlState, JohariQuadrant};
/// use context_graph_utl::johari::SuggestedAction;
///
/// let signal = LearningSignal::new(
///     0.7, 0.6, 0.8, 1.2, 0.5, None,
///     JohariQuadrant::Blind, SuggestedAction::TriggerDream,
///     true, true, 2000,
/// ).unwrap();
///
/// let state = UtlState::from_signal(&signal);
/// assert_eq!(state.learning_magnitude, 0.7);
/// assert_eq!(state.quadrant, JohariQuadrant::Blind);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlState {
    /// Last computed surprise value [0, 1]
    pub delta_s: f32,

    /// Last computed coherence value [0, 1]
    pub delta_c: f32,

    /// Last computed emotional weight [0.5, 1.5]
    pub w_e: f32,

    /// Phase angle at computation [0, PI]
    pub phi: f32,

    /// Computed learning magnitude [0, 1]
    pub learning_magnitude: f32,

    /// Classified Johari quadrant
    pub quadrant: JohariQuadrant,

    /// When state was last updated (UTC)
    pub last_computed: DateTime<Utc>,
}

impl UtlState {
    /// Create a new UtlState from a LearningSignal.
    ///
    /// Extracts the essential values for persistent storage.
    pub fn from_signal(signal: &LearningSignal) -> Self {
        Self {
            delta_s: signal.delta_s,
            delta_c: signal.delta_c,
            w_e: signal.w_e,
            phi: signal.phi,
            learning_magnitude: signal.magnitude,
            quadrant: signal.quadrant,
            last_computed: signal.timestamp,
        }
    }

    /// Create a default/empty UtlState for new nodes.
    ///
    /// Uses neutral defaults:
    /// - delta_s = 0.0 (no surprise)
    /// - delta_c = 0.0 (no coherence established)
    /// - w_e = 1.0 (neutral emotional state)
    /// - phi = 0.0 (synchronized)
    /// - learning_magnitude = 0.5 (medium baseline)
    /// - quadrant = Hidden (low surprise, low coherence)
    pub fn empty() -> Self {
        Self {
            delta_s: 0.0,
            delta_c: 0.0,
            w_e: 1.0,
            phi: 0.0,
            learning_magnitude: 0.5,
            quadrant: JohariQuadrant::Hidden,
            last_computed: Utc::now(),
        }
    }

    /// Validate that all values are finite (not NaN or Infinity).
    ///
    /// # Returns
    /// `Ok(())` if all values are finite, `Err(UtlError::InvalidComputation)` otherwise
    pub fn validate(&self) -> UtlResult<()> {
        let values = [
            ("delta_s", self.delta_s),
            ("delta_c", self.delta_c),
            ("w_e", self.w_e),
            ("phi", self.phi),
            ("learning_magnitude", self.learning_magnitude),
        ];

        for (name, value) in values {
            if value.is_nan() || value.is_infinite() {
                return Err(UtlError::InvalidComputation {
                    delta_s: self.delta_s,
                    delta_c: self.delta_c,
                    w_e: self.w_e,
                    phi: self.phi,
                    reason: format!("{} is NaN or Infinity", name),
                });
            }
        }

        Ok(())
    }

    /// Check if this state is stale (not computed recently).
    ///
    /// # Arguments
    /// * `max_age_seconds` - Maximum age in seconds before considered stale
    ///
    /// # Returns
    /// `true` if state is older than `max_age_seconds`
    pub fn is_stale(&self, max_age_seconds: i64) -> bool {
        let age = Utc::now() - self.last_computed;
        age.num_seconds() > max_age_seconds
    }

    /// Get the age of this state in seconds.
    pub fn age_seconds(&self) -> i64 {
        (Utc::now() - self.last_computed).num_seconds()
    }
}

impl Default for UtlState {
    fn default() -> Self {
        Self::empty()
    }
}
```

### 3. Required Imports

Add at the top of `lib.rs` (after existing imports):

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
```

### 4. Re-exports

Add to the public exports section (around line 60):

```rust
// Re-export signal types
pub use crate::johari::SuggestedAction;
```

---

## Acceptance Criteria

| # | Criterion | Verification |
|---|-----------|--------------|
| 1 | `LearningSignal` struct with all 12 fields | `grep "pub struct LearningSignal" crates/context-graph-utl/src/lib.rs` |
| 2 | `UtlState` struct with 7 fields | `grep "pub struct UtlState" crates/context-graph-utl/src/lib.rs` |
| 3 | `LearningIntensity` enum with Low/Medium/High | `grep "pub enum LearningIntensity" crates/context-graph-utl/src/lib.rs` |
| 4 | `validate()` returns `UtlError::InvalidComputation` for NaN | Unit test passes |
| 5 | `validate()` returns `UtlError::InvalidComputation` for Infinity | Unit test passes |
| 6 | `Clone`, `Debug`, `Serialize`, `Deserialize` derived | Compile succeeds |
| 7 | `from_signal()` correctly converts LearningSignal to UtlState | Unit test passes |
| 8 | `is_stale()` correctly detects old state | Unit test passes |
| 9 | `intensity_category()` returns correct category | Unit test passes |
| 10 | All 369+ existing tests still pass | `cargo test -p context-graph-utl --lib` |

---

## Test Cases

Add these tests to the `#[cfg(test)]` module in `lib.rs`:

```rust
// ============= LearningSignal Tests =============

#[test]
fn test_learning_signal_creation_valid() {
    use crate::johari::SuggestedAction;

    let signal = LearningSignal::new(
        0.7,                           // magnitude
        0.6,                           // delta_s
        0.8,                           // delta_c
        1.2,                           // w_e
        0.5,                           // phi
        None,                          // lambda_weights
        JohariQuadrant::Open,
        SuggestedAction::DirectRecall,
        false,                         // should_consolidate
        true,                          // should_store
        1500,                          // latency_us
    );

    assert!(signal.is_ok());
    let s = signal.unwrap();
    assert_eq!(s.magnitude, 0.7);
    assert_eq!(s.delta_s, 0.6);
    assert_eq!(s.quadrant, JohariQuadrant::Open);
}

#[test]
fn test_learning_signal_validation_nan_magnitude() {
    use crate::johari::SuggestedAction;

    let signal = LearningSignal::new(
        f32::NAN,  // Invalid magnitude
        0.6, 0.8, 1.2, 0.5, None,
        JohariQuadrant::Open,
        SuggestedAction::DirectRecall,
        false, true, 1500,
    );

    assert!(signal.is_err());
    match signal.unwrap_err() {
        UtlError::InvalidComputation { reason, .. } => {
            assert!(reason.contains("NaN"), "Error should mention NaN: {}", reason);
        }
        e => panic!("Expected InvalidComputation, got: {:?}", e),
    }
}

#[test]
fn test_learning_signal_validation_infinity_magnitude() {
    use crate::johari::SuggestedAction;

    let signal = LearningSignal::new(
        f32::INFINITY,  // Invalid magnitude
        0.6, 0.8, 1.2, 0.5, None,
        JohariQuadrant::Open,
        SuggestedAction::DirectRecall,
        false, true, 1500,
    );

    assert!(signal.is_err());
    match signal.unwrap_err() {
        UtlError::InvalidComputation { reason, .. } => {
            assert!(reason.contains("Infinity"), "Error should mention Infinity: {}", reason);
        }
        e => panic!("Expected InvalidComputation, got: {:?}", e),
    }
}

#[test]
fn test_learning_signal_validation_nan_component() {
    use crate::johari::SuggestedAction;

    let signal = LearningSignal::new(
        0.5,          // Valid magnitude
        f32::NAN,     // Invalid delta_s
        0.8, 1.2, 0.5, None,
        JohariQuadrant::Open,
        SuggestedAction::DirectRecall,
        false, true, 1500,
    );

    assert!(signal.is_err());
    match signal.unwrap_err() {
        UtlError::InvalidComputation { reason, .. } => {
            assert!(reason.contains("NaN"), "Error should mention NaN: {}", reason);
        }
        e => panic!("Expected InvalidComputation, got: {:?}", e),
    }
}

#[test]
fn test_learning_intensity_categories() {
    use crate::johari::SuggestedAction;

    // Low (< 0.3)
    let low = LearningSignal::new(
        0.2, 0.5, 0.5, 1.0, 0.5, None,
        JohariQuadrant::Open, SuggestedAction::DirectRecall,
        false, true, 100
    ).unwrap();
    assert_eq!(low.intensity_category(), LearningIntensity::Low);
    assert!(low.is_low_learning());
    assert!(!low.is_high_learning());

    // Medium (0.3 - 0.7)
    let medium = LearningSignal::new(
        0.5, 0.5, 0.5, 1.0, 0.5, None,
        JohariQuadrant::Open, SuggestedAction::DirectRecall,
        false, true, 100
    ).unwrap();
    assert_eq!(medium.intensity_category(), LearningIntensity::Medium);
    assert!(!medium.is_low_learning());
    assert!(!medium.is_high_learning());

    // High (> 0.7)
    let high = LearningSignal::new(
        0.8, 0.5, 0.5, 1.0, 0.5, None,
        JohariQuadrant::Open, SuggestedAction::DirectRecall,
        false, true, 100
    ).unwrap();
    assert_eq!(high.intensity_category(), LearningIntensity::High);
    assert!(!high.is_low_learning());
    assert!(high.is_high_learning());
}

#[test]
fn test_learning_intensity_boundary_values() {
    use crate::johari::SuggestedAction;

    // Exactly 0.3 should be Medium
    let at_low_boundary = LearningSignal::new(
        0.3, 0.5, 0.5, 1.0, 0.5, None,
        JohariQuadrant::Open, SuggestedAction::DirectRecall,
        false, true, 100
    ).unwrap();
    assert_eq!(at_low_boundary.intensity_category(), LearningIntensity::Medium);

    // Exactly 0.7 should be High
    let at_high_boundary = LearningSignal::new(
        0.7, 0.5, 0.5, 1.0, 0.5, None,
        JohariQuadrant::Open, SuggestedAction::DirectRecall,
        false, true, 100
    ).unwrap();
    assert_eq!(at_high_boundary.intensity_category(), LearningIntensity::High);
}

// ============= UtlState Tests =============

#[test]
fn test_utl_state_from_signal() {
    use crate::johari::SuggestedAction;

    let signal = LearningSignal::new(
        0.7, 0.6, 0.8, 1.2, 0.5, None,
        JohariQuadrant::Blind,
        SuggestedAction::TriggerDream,
        true, true, 2000,
    ).unwrap();

    let state = UtlState::from_signal(&signal);

    assert_eq!(state.delta_s, signal.delta_s);
    assert_eq!(state.delta_c, signal.delta_c);
    assert_eq!(state.w_e, signal.w_e);
    assert_eq!(state.phi, signal.phi);
    assert_eq!(state.learning_magnitude, signal.magnitude);
    assert_eq!(state.quadrant, JohariQuadrant::Blind);
    assert_eq!(state.last_computed, signal.timestamp);
}

#[test]
fn test_utl_state_empty() {
    let state = UtlState::empty();

    assert_eq!(state.delta_s, 0.0);
    assert_eq!(state.delta_c, 0.0);
    assert_eq!(state.w_e, 1.0);
    assert_eq!(state.phi, 0.0);
    assert_eq!(state.learning_magnitude, 0.5);
    assert_eq!(state.quadrant, JohariQuadrant::Hidden);
    assert!(state.validate().is_ok());
}

#[test]
fn test_utl_state_default_matches_empty() {
    let default_state = UtlState::default();
    let empty_state = UtlState::empty();

    assert_eq!(default_state.delta_s, empty_state.delta_s);
    assert_eq!(default_state.delta_c, empty_state.delta_c);
    assert_eq!(default_state.w_e, empty_state.w_e);
    assert_eq!(default_state.learning_magnitude, empty_state.learning_magnitude);
    assert_eq!(default_state.quadrant, empty_state.quadrant);
}

#[test]
fn test_utl_state_staleness() {
    use chrono::Duration;

    let mut state = UtlState::empty();

    // Fresh state should not be stale
    assert!(!state.is_stale(300), "Fresh state should not be stale");
    assert!(state.age_seconds() < 5, "Fresh state age should be < 5s");

    // Simulate old state by backdating
    state.last_computed = Utc::now() - Duration::seconds(400);
    assert!(state.is_stale(300), "400s old state should be stale with 300s threshold");
    assert!(!state.is_stale(500), "400s old state should not be stale with 500s threshold");
}

#[test]
fn test_utl_state_validation_success() {
    let state = UtlState {
        delta_s: 0.5,
        delta_c: 0.6,
        w_e: 1.2,
        phi: 0.3,
        learning_magnitude: 0.7,
        quadrant: JohariQuadrant::Open,
        last_computed: Utc::now(),
    };

    assert!(state.validate().is_ok());
}

#[test]
fn test_utl_state_validation_nan() {
    let state = UtlState {
        delta_s: f32::NAN,
        delta_c: 0.6,
        w_e: 1.2,
        phi: 0.3,
        learning_magnitude: 0.7,
        quadrant: JohariQuadrant::Open,
        last_computed: Utc::now(),
    };

    assert!(state.validate().is_err());
    match state.validate().unwrap_err() {
        UtlError::InvalidComputation { reason, .. } => {
            assert!(reason.contains("delta_s"), "Error should mention delta_s");
        }
        e => panic!("Expected InvalidComputation, got: {:?}", e),
    }
}

#[test]
fn test_utl_state_validation_infinity() {
    let state = UtlState {
        delta_s: 0.5,
        delta_c: 0.6,
        w_e: f32::INFINITY,
        phi: 0.3,
        learning_magnitude: 0.7,
        quadrant: JohariQuadrant::Open,
        last_computed: Utc::now(),
    };

    assert!(state.validate().is_err());
}

#[test]
fn test_utl_state_serialization_roundtrip() {
    let original = UtlState::empty();

    let json = serde_json::to_string(&original).expect("Serialization should succeed");
    let deserialized: UtlState = serde_json::from_str(&json).expect("Deserialization should succeed");

    assert_eq!(original.delta_s, deserialized.delta_s);
    assert_eq!(original.delta_c, deserialized.delta_c);
    assert_eq!(original.w_e, deserialized.w_e);
    assert_eq!(original.phi, deserialized.phi);
    assert_eq!(original.learning_magnitude, deserialized.learning_magnitude);
    assert_eq!(original.quadrant, deserialized.quadrant);
}

#[test]
fn test_learning_signal_serialization_roundtrip() {
    use crate::johari::SuggestedAction;

    let original = LearningSignal::new(
        0.65, 0.7, 0.8, 1.1, 0.2, None,
        JohariQuadrant::Unknown,
        SuggestedAction::TriggerDream,
        true, true, 500,
    ).unwrap();

    let json = serde_json::to_string(&original).expect("Serialization should succeed");
    let deserialized: LearningSignal = serde_json::from_str(&json).expect("Deserialization should succeed");

    assert_eq!(original.magnitude, deserialized.magnitude);
    assert_eq!(original.delta_s, deserialized.delta_s);
    assert_eq!(original.quadrant, deserialized.quadrant);
    assert_eq!(original.suggested_action, deserialized.suggested_action);
}

#[test]
fn test_learning_signal_with_lambda_weights() {
    use crate::johari::SuggestedAction;

    let weights = LifecycleLambdaWeights::for_stage(LifecycleStage::Growth);

    let signal = LearningSignal::new(
        0.6, 0.5, 0.5, 1.0, 0.0,
        Some(weights.clone()),
        JohariQuadrant::Open,
        SuggestedAction::DirectRecall,
        false, true, 100,
    ).unwrap();

    assert!(signal.lambda_weights.is_some());
    let stored_weights = signal.lambda_weights.unwrap();
    assert!((stored_weights.lambda_s() - 0.5).abs() < 0.001);
}
```

---

## Verification Commands

```bash
# 1. Pre-implementation check - structs should NOT exist
grep -r "pub struct LearningSignal\|pub struct UtlState" crates/context-graph-utl/src/
# Expected: NO OUTPUT

# 2. Run existing tests (should pass)
cargo test -p context-graph-utl --lib
# Expected: 369 passed

# 3. After implementation - compile check
cargo build -p context-graph-utl

# 4. Run all tests including new ones
cargo test -p context-graph-utl --lib
# Expected: ~385 passed (369 existing + ~16 new)

# 5. Check serialization works
cargo test -p context-graph-utl --lib -- serialization

# 6. Verify doc tests
cargo test -p context-graph-utl --doc
```

---

## Full State Verification Requirements

After completing implementation, you MUST perform these verification steps:

### 1. Source of Truth Verification

The source of truth is the compiled crate and test results. Verify:

```bash
# Verify structs exist in compiled output
cargo doc -p context-graph-utl --no-deps
ls target/doc/context_graph_utl/struct.LearningSignal.html
ls target/doc/context_graph_utl/struct.UtlState.html
ls target/doc/context_graph_utl/enum.LearningIntensity.html
# All three files MUST exist
```

### 2. Execute & Inspect

```bash
# Run all tests with output
cargo test -p context-graph-utl --lib -- --nocapture 2>&1 | tee test_output.log

# Grep for specific test results
grep -E "test_learning_signal|test_utl_state|test_learning_intensity" test_output.log
# All tests MUST show "ok"

# Verify test count increased
cargo test -p context-graph-utl --lib 2>&1 | grep "passed"
# Should show ~385 passed (was 369)
```

### 3. Edge Case Audit (Manual Tests)

Run these edge case scenarios and print before/after state:

#### Edge Case 1: Zero Magnitude
```rust
// Test: magnitude = 0.0 should be valid
let signal = LearningSignal::new(0.0, 0.0, 0.0, 1.0, 0.0, None,
    JohariQuadrant::Hidden, SuggestedAction::GetNeighborhood, false, false, 0);
println!("BEFORE: magnitude=0.0, creating signal");
println!("AFTER: {:?}", signal);
assert!(signal.is_ok());
```

#### Edge Case 2: Maximum Values
```rust
// Test: all values at maximum valid range
let signal = LearningSignal::new(1.0, 1.0, 1.0, 1.5, std::f32::consts::PI, None,
    JohariQuadrant::Unknown, SuggestedAction::TriggerDream, true, true, u64::MAX);
println!("BEFORE: all max values");
println!("AFTER: {:?}", signal);
assert!(signal.is_ok());
```

#### Edge Case 3: Negative Infinity
```rust
// Test: negative infinity should fail validation
let signal = LearningSignal::new(f32::NEG_INFINITY, 0.5, 0.5, 1.0, 0.5, None,
    JohariQuadrant::Open, SuggestedAction::DirectRecall, false, true, 100);
println!("BEFORE: NEG_INFINITY magnitude");
println!("AFTER: {:?}", signal);
assert!(signal.is_err());
```

### 4. Evidence of Success

Final verification log must show:

```bash
# Run and capture final state
cargo test -p context-graph-utl --lib 2>&1 | tail -5

# Expected output (MUST match this pattern):
# test result: ok. XXX passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
# Where XXX >= 385
```

---

## SHERLOCK VERIFICATION CHECKLIST

After implementation, the sherlock-holmes agent MUST verify:

- [ ] `LearningSignal` struct exists at expected location
- [ ] `UtlState` struct exists at expected location
- [ ] `LearningIntensity` enum exists with exactly 3 variants
- [ ] NaN validation produces `UtlError::InvalidComputation`
- [ ] Infinity validation produces `UtlError::InvalidComputation`
- [ ] Serialization roundtrip preserves all fields
- [ ] `from_signal()` correctly transfers all 7 fields
- [ ] `is_stale()` returns correct boolean for various ages
- [ ] All new tests pass
- [ ] No regression in existing 369 tests
- [ ] Doc tests pass
- [ ] No compiler warnings

---

## Related Tasks

| Task | Relationship | Status |
|------|--------------|--------|
| M05-T06 | Provides `LifecycleLambdaWeights` type | **COMPLETE** |
| M05-T08 | Provides `JohariQuadrant`, `SuggestedAction` | **COMPLETE** |
| M05-T20 | Computes magnitude stored in structs | **COMPLETE** |
| M05-T22 | UtlProcessor will produce `LearningSignal` | PARTIAL |
| M05-T23 | Uses `UtlError` for validation | **COMPLETE** |
| M05-T29 | MemoryNode will store `UtlState` | PENDING |

---

## Anti-Patterns to Avoid

1. **DO NOT** duplicate `JohariQuadrant` - it's in `context-graph-core`, re-exported via johari module
2. **DO NOT** use `unwrap()` in implementation - use `expect()` with context or propagate errors
3. **DO NOT** create mock data in tests - use real types and verify actual behavior
4. **DO NOT** suppress validation errors - fail fast with descriptive messages
5. **DO NOT** hardcode magic numbers - use constants (0.3, 0.7 for thresholds are intentional per UTL spec)

---

*Task updated: 2026-01-04*
*Audited against codebase commit: a00cce8*
*Structs verified as NOT YET IMPLEMENTED*
