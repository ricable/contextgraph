# M05-T59: Implement Priors Vibe Check UTL Integration

## Task Metadata
- **ID**: M05-T59
- **Title**: Implement Priors Vibe Check UTL Integration
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: medium
- **Estimated Hours**: 2.5
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement UTL integration for the Priors Vibe Check system per PRD Section 6.2.

The `priors_vibe_check` field in KnowledgeNode (128D vector) encodes agent assumptions at storage time. UTL must integrate with this for:
1. Computing compatibility during merges
2. Preventing memetic drift
3. Generating Relational Edges for incompatible priors

Per PRD:
- "128D vector encoding agent assumptions at storage time"
- "If compatible (sim > 0.7): Normal merge"
- "If incompatible: Create Relational Edge instead"

## File Paths

### Implementation
- `crates/context-graph-utl/src/priors/vibe_check.rs`
- `crates/context-graph-utl/src/priors/mod.rs`
- `crates/context-graph-utl/src/priors/compatibility.rs`

### Tests
- `crates/context-graph-utl/tests/priors_vibe_check_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T21 | Implement LearningSignal and UtlState | pending |
| M05-T22 | Implement UtlProcessor | pending |

## Acceptance Criteria

- [ ] PriorsVibeCheck struct with 128D vector
- [ ] Cosine similarity computation for compatibility
- [ ] Compatibility threshold configurable (default: 0.7)
- [ ] Integration with merge_concepts decision logic
- [ ] RelationalEdge suggestion for incompatible priors
- [ ] Priors extraction from content/context

## Specification References

- `contextgraphprd.md` Section 6.2 Priors Vibe Check
- `contextgraphprd.md` Section 3.4 Memory Curation Tools

## Implementation Notes

### Priors Vibe Check Structure

```rust
use serde::{Serialize, Deserialize};

/// Priors vibe check vector encoding agent assumptions
/// Per PRD: "128D vector encoding agent assumptions at storage time"
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriorsVibeCheck {
    /// 128-dimensional encoding of prior assumptions
    pub vector: [f32; 128],

    /// Agent ID that created these priors
    pub agent_id: String,

    /// Domain context for these priors
    pub domain: Option<PriorsDomain>,

    /// Confidence in these priors [0.0, 1.0]
    pub confidence: f32,

    /// Timestamp when priors were computed
    pub computed_at: DateTime<Utc>,
}

/// Domain context that affects priors interpretation
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PriorsDomain {
    /// General/default domain
    General,
    /// Code and programming
    Code,
    /// Legal documents
    Legal,
    /// Medical/health
    Medical,
    /// Creative writing
    Creative,
    /// Academic research
    Research,
}

impl PriorsVibeCheck {
    /// Create new priors from content and context
    pub fn from_content(
        content: &str,
        context: &[&str],
        agent_id: &str,
        domain: Option<PriorsDomain>,
    ) -> Self {
        let vector = Self::compute_priors_vector(content, context);

        Self {
            vector,
            agent_id: agent_id.to_string(),
            domain,
            confidence: Self::compute_confidence(&vector),
            computed_at: Utc::now(),
        }
    }

    /// Compute 128D priors vector from content
    /// Uses hash-based encoding for deterministic results
    fn compute_priors_vector(content: &str, context: &[&str]) -> [f32; 128] {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;

        let mut vector = [0.0f32; 128];

        // Content contribution (64 dimensions)
        let mut hasher = DefaultHasher::new();
        content.hash(&mut hasher);
        let content_hash = hasher.finish();

        for i in 0..64 {
            let bit = (content_hash >> i) & 1;
            vector[i] = if bit == 1 { 1.0 } else { -1.0 };
        }

        // Context contribution (64 dimensions)
        for (idx, ctx) in context.iter().enumerate() {
            let mut hasher = DefaultHasher::new();
            ctx.hash(&mut hasher);
            let ctx_hash = hasher.finish();

            for i in 0..64 {
                let bit = (ctx_hash >> i) & 1;
                let weight = 1.0 / (idx as f32 + 1.0);  // Decay with distance
                vector[64 + i] += if bit == 1 { weight } else { -weight };
            }
        }

        // Normalize
        let norm: f32 = vector.iter().map(|x| x * x).sum::<f32>().sqrt();
        if norm > 0.0 {
            for v in vector.iter_mut() {
                *v /= norm;
            }
        }

        vector
    }

    /// Compute confidence based on vector properties
    fn compute_confidence(vector: &[f32; 128]) -> f32 {
        // Higher variance = more confident priors
        let mean: f32 = vector.iter().sum::<f32>() / 128.0;
        let variance: f32 = vector.iter().map(|x| (x - mean).powi(2)).sum::<f32>() / 128.0;

        // Map variance to confidence [0.0, 1.0]
        (variance * 4.0).min(1.0)
    }
}
```

### Compatibility Checker

```rust
/// Configuration for priors compatibility checking
#[derive(Debug, Clone)]
pub struct PriorsCompatibilityConfig {
    /// Cosine similarity threshold for compatibility
    /// Per PRD: "If compatible (sim > 0.7): Normal merge"
    pub compatibility_threshold: f32,

    /// Whether to consider domain in compatibility
    pub domain_aware: bool,

    /// Weight reduction for cross-domain comparison
    pub cross_domain_penalty: f32,
}

impl Default for PriorsCompatibilityConfig {
    fn default() -> Self {
        Self {
            compatibility_threshold: 0.7,
            domain_aware: true,
            cross_domain_penalty: 0.2,
        }
    }
}

/// Result of compatibility check
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompatibilityResult {
    /// Whether priors are compatible for merge
    pub compatible: bool,

    /// Raw cosine similarity [-1.0, 1.0]
    pub similarity: f32,

    /// Adjusted similarity (after domain penalty)
    pub adjusted_similarity: f32,

    /// Suggested action based on compatibility
    pub suggestion: CompatibilitySuggestion,

    /// Explanation for the result
    pub explanation: String,
}

/// Suggested action based on compatibility result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CompatibilitySuggestion {
    /// Priors compatible - proceed with merge
    AllowMerge,

    /// Priors incompatible - create relational edge instead
    /// Per PRD: "If incompatible: Create Relational Edge instead"
    CreateRelationalEdge {
        edge_type: RelationalEdgeType,
        explanation: String,
    },

    /// Need human review
    RequireReview {
        reason: String,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RelationalEdgeType {
    /// Context-dependent difference
    /// e.g., "In Python, X; but in Java, Y"
    ContextDependent,

    /// Temporal difference (old vs new)
    TemporalVariation,

    /// Perspective difference (agent-specific)
    PerspectiveVariation,

    /// Conflicting information
    Contradiction,
}

/// Priors compatibility checker
pub struct PriorsCompatibilityChecker {
    config: PriorsCompatibilityConfig,
}

impl PriorsCompatibilityChecker {
    pub fn new(config: PriorsCompatibilityConfig) -> Self {
        Self { config }
    }

    /// Check compatibility between two priors
    pub fn check_compatibility(
        &self,
        priors_a: &PriorsVibeCheck,
        priors_b: &PriorsVibeCheck,
    ) -> CompatibilityResult {
        // Compute cosine similarity
        let similarity = self.cosine_similarity(&priors_a.vector, &priors_b.vector);

        // Apply domain penalty if cross-domain
        let adjusted_similarity = if self.config.domain_aware {
            self.apply_domain_adjustment(similarity, priors_a.domain, priors_b.domain)
        } else {
            similarity
        };

        // Determine compatibility
        let compatible = adjusted_similarity >= self.config.compatibility_threshold;

        // Generate suggestion
        let suggestion = if compatible {
            CompatibilitySuggestion::AllowMerge
        } else if adjusted_similarity >= 0.4 {
            // Borderline - create relational edge
            let edge_type = self.determine_edge_type(priors_a, priors_b);
            CompatibilitySuggestion::CreateRelationalEdge {
                edge_type,
                explanation: format!(
                    "Priors differ (sim={:.2}) - creating relational edge",
                    adjusted_similarity
                ),
            }
        } else if adjusted_similarity >= 0.0 {
            // Very different - may need review
            CompatibilitySuggestion::RequireReview {
                reason: format!(
                    "Low similarity ({:.2}) between priors from agents '{}' and '{}'",
                    adjusted_similarity, priors_a.agent_id, priors_b.agent_id
                ),
            }
        } else {
            // Negative similarity - likely contradiction
            CompatibilitySuggestion::CreateRelationalEdge {
                edge_type: RelationalEdgeType::Contradiction,
                explanation: format!(
                    "Contradicting priors (sim={:.2}) - creating contradiction edge",
                    adjusted_similarity
                ),
            }
        };

        let explanation = self.generate_explanation(
            priors_a, priors_b, similarity, adjusted_similarity, compatible
        );

        CompatibilityResult {
            compatible,
            similarity,
            adjusted_similarity,
            suggestion,
            explanation,
        }
    }

    /// Compute cosine similarity between two vectors
    fn cosine_similarity(&self, a: &[f32; 128], b: &[f32; 128]) -> f32 {
        let dot: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
        let norm_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();
        let norm_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();

        if norm_a > 0.0 && norm_b > 0.0 {
            dot / (norm_a * norm_b)
        } else {
            0.0
        }
    }

    /// Apply domain-aware adjustment to similarity
    fn apply_domain_adjustment(
        &self,
        similarity: f32,
        domain_a: Option<PriorsDomain>,
        domain_b: Option<PriorsDomain>,
    ) -> f32 {
        match (domain_a, domain_b) {
            (Some(a), Some(b)) if a != b => {
                // Cross-domain penalty
                similarity - self.config.cross_domain_penalty
            }
            _ => similarity,
        }
    }

    /// Determine appropriate edge type for incompatible priors
    fn determine_edge_type(
        &self,
        priors_a: &PriorsVibeCheck,
        priors_b: &PriorsVibeCheck,
    ) -> RelationalEdgeType {
        // Check for domain difference
        if priors_a.domain != priors_b.domain {
            return RelationalEdgeType::ContextDependent;
        }

        // Check for temporal difference
        let time_diff = (priors_a.computed_at - priors_b.computed_at).num_hours().abs();
        if time_diff > 24 {
            return RelationalEdgeType::TemporalVariation;
        }

        // Check for agent difference
        if priors_a.agent_id != priors_b.agent_id {
            return RelationalEdgeType::PerspectiveVariation;
        }

        // Default to context-dependent
        RelationalEdgeType::ContextDependent
    }

    fn generate_explanation(
        &self,
        priors_a: &PriorsVibeCheck,
        priors_b: &PriorsVibeCheck,
        raw_sim: f32,
        adj_sim: f32,
        compatible: bool,
    ) -> String {
        if compatible {
            format!(
                "Priors compatible (similarity={:.2}). Safe to merge.",
                adj_sim
            )
        } else {
            let mut reasons = Vec::new();

            if priors_a.domain != priors_b.domain {
                reasons.push(format!(
                    "different domains ({:?} vs {:?})",
                    priors_a.domain, priors_b.domain
                ));
            }

            if priors_a.agent_id != priors_b.agent_id {
                reasons.push(format!(
                    "different agents ('{}' vs '{}')",
                    priors_a.agent_id, priors_b.agent_id
                ));
            }

            if raw_sim < 0.5 {
                reasons.push(format!("low semantic overlap (sim={:.2})", raw_sim));
            }

            format!(
                "Priors incompatible: {}. Consider relational edge instead of merge.",
                reasons.join(", ")
            )
        }
    }
}
```

### UTL Integration

```rust
impl UtlProcessor {
    /// Check priors compatibility for merge operation
    pub fn check_merge_compatibility(
        &self,
        node_a: &MemoryNode,
        node_b: &MemoryNode,
    ) -> CompatibilityResult {
        let checker = PriorsCompatibilityChecker::new(
            self.config.priors_config.clone()
        );

        checker.check_compatibility(
            &node_a.priors_vibe_check,
            &node_b.priors_vibe_check,
        )
    }

    /// Extract priors from content during store_memory
    pub fn compute_priors_for_storage(
        &self,
        content: &str,
        context: &SessionContext,
        agent_id: &str,
    ) -> PriorsVibeCheck {
        let recent_content: Vec<&str> = context.recent_content
            .iter()
            .map(|s| s.as_str())
            .collect();

        PriorsVibeCheck::from_content(
            content,
            &recent_content,
            agent_id,
            context.current_domain,
        )
    }
}
```

## Testing Requirements

1. **Similarity Tests**
   - Identical vectors -> similarity = 1.0
   - Orthogonal vectors -> similarity = 0.0
   - Opposite vectors -> similarity = -1.0
   - Boundary threshold (0.7) correctly evaluated

2. **Compatibility Tests**
   - Compatible priors allow merge
   - Incompatible priors suggest relational edge
   - Very low similarity triggers review
   - Negative similarity creates contradiction edge

3. **Domain Tests**
   - Same domain: no penalty
   - Different domain: penalty applied
   - Cross-domain penalty configurable

4. **Integration Tests**
   - Priors extracted from content correctly
   - Merge compatibility check integrates with UtlProcessor
   - RelationalEdgeType suggestions are appropriate

---

*Task specification generated for Module 05 - UTL Integration*
