# M05-T14: Implement Structural Coherence and Contradiction Detection

| Field | Value |
|-------|-------|
| **Task ID** | M05-T14 |
| **Module** | context-graph-utl |
| **Status** | COMPLETE (stub) - Needs Extension |
| **Priority** | P1 (High) |
| **Depends On** | M05-T13 (CoherenceTracker), M05-T03 (CoherenceConfig) |
| **Estimated Hours** | 3 |
| **Constitution Refs** | constitution.yaml lines 148-167 (UTL params), contextprd.md Section 6.3 (Conflict Detection) |

---

## CRITICAL: Current State Audit (2026-01-04)

### What ACTUALLY Exists

The structural coherence module exists as a **stub implementation** at:
- **File**: `crates/context-graph-utl/src/coherence/structural.rs` (523 lines)
- **Tests**: 23 passing tests in same file

**Current Implementation:**
```rust
// Exports from crates/context-graph-utl/src/coherence/mod.rs:38
pub use structural::{compute_structural_coherence, StructuralCoherenceCalculator};
```

**StructuralCoherenceCalculator Fields (lines 44-53):**
```rust
pub struct StructuralCoherenceCalculator {
    min_similarity: f32,    // Default: 0.3
    hop_decay: f32,         // Default: 0.5
    max_hops: usize,        // Default: 2
}
```

### What Does NOT Exist (Must Be Implemented)

1. **ContradictionDetector** - Does not exist
2. **ContradictionResult** struct - Does not exist
3. **CoherenceResult** struct - Does not exist
4. **KnowledgeGraphRef** trait - Does not exist in UTL crate
5. **CoherenceConfig contradiction fields** - Not present:
   - No `contradiction_search_k`
   - No `contradiction_similarity_threshold`
   - No `max_contradiction_penalty`
   - No `semantic_weight` / `structural_weight`
   - No `default_coherence_empty` / `default_coherence_no_concepts`

### Current CoherenceConfig (lines 230-260 of config.rs)

```rust
pub struct CoherenceConfig {
    pub similarity_weight: f32,        // 0.5 - For similarity contribution
    pub consistency_weight: f32,       // 0.7 - For consistency contribution
    pub min_threshold: f32,            // 0.1 - Minimum coherence
    pub decay_rate: f32,               // 0.05 - Decay over time
    pub neighbor_count: usize,         // 10 - Neighbors for calculation
    pub neighbor_similarity_min: f32,  // 0.3 - Min neighbor similarity
    pub use_graph_coherence: bool,     // true - Enable graph coherence
    pub graph_weight: f32,             // 0.4 - Weight for graph coherence
}
```

---

## Implementation Requirements

### Phase 1: Extend CoherenceConfig (Required First)

Add contradiction-related fields to `crates/context-graph-utl/src/config.rs`:

```rust
// Add to CoherenceConfig struct after line 260
pub struct CoherenceConfig {
    // ... existing fields ...

    /// Number of similar nodes to search for contradiction detection.
    /// Range: [5, 50], Default: 20
    pub contradiction_search_k: usize,

    /// Similarity threshold above which nodes may conflict.
    /// Range: [0.7, 0.95], Default: 0.85
    pub contradiction_similarity_threshold: f32,

    /// Maximum penalty to apply for detected contradictions.
    /// Range: [0.0, 1.0], Default: 0.5
    pub max_contradiction_penalty: f32,

    /// Weight for semantic coherence in combined score.
    /// Range: [0.0, 1.0], Default: 0.6
    pub semantic_weight: f32,

    /// Weight for structural coherence in combined score.
    /// Range: [0.0, 1.0], Default: 0.4
    pub structural_weight: f32,

    /// Default coherence when graph is empty/unavailable.
    /// Range: [0.0, 1.0], Default: 0.5
    pub default_coherence_empty: f32,

    /// Default coherence when no related concepts found.
    /// Range: [0.0, 1.0], Default: 0.4
    pub default_coherence_no_concepts: f32,
}
```

**Update Default impl** (after line 274):
```rust
impl Default for CoherenceConfig {
    fn default() -> Self {
        Self {
            // ... existing defaults ...
            contradiction_search_k: 20,
            contradiction_similarity_threshold: 0.85,
            max_contradiction_penalty: 0.5,
            semantic_weight: 0.6,
            structural_weight: 0.4,
            default_coherence_empty: 0.5,
            default_coherence_no_concepts: 0.4,
        }
    }
}
```

**Update validate() method** (after line 280):
```rust
// Add these validations
if !(5..=50).contains(&self.contradiction_search_k) {
    return Err("contradiction_search_k must be in [5, 50]".to_string());
}
if !(0.7..=0.95).contains(&self.contradiction_similarity_threshold) {
    return Err("contradiction_similarity_threshold must be in [0.7, 0.95]".to_string());
}
if !(0.0..=1.0).contains(&self.max_contradiction_penalty) {
    return Err("max_contradiction_penalty must be in [0.0, 1.0]".to_string());
}
let weight_sum = self.semantic_weight + self.structural_weight;
if (weight_sum - 1.0).abs() > 0.001 {
    return Err("semantic_weight + structural_weight must equal 1.0".to_string());
}
```

### Phase 2: Implement ContradictionDetector

Create new types in `crates/context-graph-utl/src/coherence/structural.rs`:

```rust
/// Result of contradiction detection.
#[derive(Debug, Clone, Default)]
pub struct ContradictionResult {
    /// Whether a contradiction was detected.
    pub has_contradiction: bool,
    /// Penalty to apply to coherence (0.0 = no penalty).
    pub penalty: f32,
    /// IDs of conflicting nodes (if any).
    pub conflicting_nodes: Vec<uuid::Uuid>,
    /// Similarity scores to conflicting nodes.
    pub conflict_scores: Vec<f32>,
    /// Human-readable explanation.
    pub explanation: Option<String>,
}

impl ContradictionResult {
    /// Create a result indicating no contradiction.
    pub fn none() -> Self {
        Self::default()
    }

    /// Create a result with detected contradiction.
    pub fn detected(
        penalty: f32,
        conflicting_nodes: Vec<uuid::Uuid>,
        conflict_scores: Vec<f32>,
        explanation: String,
    ) -> Self {
        Self {
            has_contradiction: true,
            penalty: penalty.clamp(0.0, 1.0),
            conflicting_nodes,
            conflict_scores,
            explanation: Some(explanation),
        }
    }
}

/// Detector for contradictions with existing knowledge.
///
/// STUB: Currently returns no contradictions. Will integrate with
/// KnowledgeGraph in M05-T35.
#[derive(Debug, Clone)]
pub struct ContradictionDetector {
    /// Similarity threshold for potential conflicts.
    threshold: f32,
    /// Maximum penalty to apply.
    max_penalty: f32,
    /// Number of neighbors to search.
    search_k: usize,
}

impl Default for ContradictionDetector {
    fn default() -> Self {
        Self {
            threshold: 0.85,
            max_penalty: 0.5,
            search_k: 20,
        }
    }
}

impl ContradictionDetector {
    /// Create from CoherenceConfig.
    pub fn from_config(config: &crate::config::CoherenceConfig) -> Self {
        Self {
            threshold: config.contradiction_similarity_threshold,
            max_penalty: config.max_contradiction_penalty,
            search_k: config.contradiction_search_k,
        }
    }

    /// Detect contradictions (STUB - returns none).
    ///
    /// In M05-T35, this will query the KnowledgeGraph for similar nodes
    /// and check for semantic conflicts.
    pub fn detect(&self, _embedding: &[f32], _content: Option<&str>) -> ContradictionResult {
        // STUB: No graph integration yet
        ContradictionResult::none()
    }

    /// Detect with explicit neighbor data (for testing).
    pub fn detect_with_neighbors(
        &self,
        embedding: &[f32],
        neighbors: &[(uuid::Uuid, Vec<f32>, f32)], // (id, embedding, similarity)
    ) -> ContradictionResult {
        if neighbors.is_empty() {
            return ContradictionResult::none();
        }

        // Find potential conflicts (high similarity but not identical)
        let potential: Vec<_> = neighbors.iter()
            .filter(|(_, _, sim)| *sim >= self.threshold && *sim < 0.98)
            .collect();

        if potential.is_empty() {
            return ContradictionResult::none();
        }

        let avg_score: f32 = potential.iter().map(|(_, _, s)| s).sum::<f32>()
            / potential.len() as f32;

        let penalty = ((avg_score - self.threshold) / (1.0 - self.threshold))
            * self.max_penalty;

        let (ids, scores): (Vec<_>, Vec<_>) = potential.iter()
            .map(|(id, _, score)| (*id, *score))
            .unzip();

        ContradictionResult::detected(
            penalty.clamp(0.0, self.max_penalty),
            ids,
            scores,
            format!("High similarity ({:.2}) to {} nodes suggests potential conflict",
                avg_score, potential.len()),
        )
    }

    pub fn threshold(&self) -> f32 { self.threshold }
    pub fn max_penalty(&self) -> f32 { self.max_penalty }
    pub fn search_k(&self) -> usize { self.search_k }
}
```

### Phase 3: Implement CoherenceResult

```rust
/// Complete result of coherence computation.
#[derive(Debug, Clone)]
pub struct CoherenceResult {
    /// Final combined coherence score [0, 1].
    pub coherence: f32,
    /// Semantic coherence component.
    pub semantic_coherence: f32,
    /// Structural coherence component.
    pub structural_coherence: f32,
    /// Contradiction detection result.
    pub contradiction: ContradictionResult,
}

impl CoherenceResult {
    /// Create a new coherence result.
    pub fn new(semantic: f32, structural: f32, contradiction: ContradictionResult) -> Self {
        let base = semantic * 0.6 + structural * 0.4;
        let final_coherence = base * (1.0 - contradiction.penalty);

        Self {
            coherence: final_coherence.clamp(0.0, 1.0),
            semantic_coherence: semantic,
            structural_coherence: structural,
            contradiction,
        }
    }

    pub fn has_contradiction(&self) -> bool {
        self.contradiction.has_contradiction
    }

    pub fn contradiction_penalty(&self) -> f32 {
        self.contradiction.penalty
    }
}
```

### Phase 4: Update Module Exports

Update `crates/context-graph-utl/src/coherence/mod.rs`:

```rust
pub use structural::{
    compute_structural_coherence,
    StructuralCoherenceCalculator,
    ContradictionDetector,
    ContradictionResult,
    CoherenceResult,
};
```

---

## Test Cases (Required)

Add to `crates/context-graph-utl/src/coherence/structural.rs`:

```rust
#[cfg(test)]
mod contradiction_tests {
    use super::*;

    #[test]
    fn test_contradiction_result_none() {
        let result = ContradictionResult::none();
        assert!(!result.has_contradiction);
        assert_eq!(result.penalty, 0.0);
        assert!(result.conflicting_nodes.is_empty());
    }

    #[test]
    fn test_contradiction_result_detected() {
        let ids = vec![uuid::Uuid::new_v4()];
        let scores = vec![0.9];
        let result = ContradictionResult::detected(
            0.3, ids.clone(), scores.clone(), "Test conflict".to_string()
        );

        assert!(result.has_contradiction);
        assert_eq!(result.penalty, 0.3);
        assert_eq!(result.conflicting_nodes.len(), 1);
    }

    #[test]
    fn test_contradiction_detector_default() {
        let detector = ContradictionDetector::default();
        assert_eq!(detector.threshold(), 0.85);
        assert_eq!(detector.max_penalty(), 0.5);
        assert_eq!(detector.search_k(), 20);
    }

    #[test]
    fn test_contradiction_detector_stub() {
        let detector = ContradictionDetector::default();
        let embedding = vec![0.1, 0.2, 0.3];
        let result = detector.detect(&embedding, None);

        // Stub always returns no contradiction
        assert!(!result.has_contradiction);
    }

    #[test]
    fn test_contradiction_detector_with_neighbors() {
        let detector = ContradictionDetector::default();
        let embedding = vec![0.1, 0.2, 0.3];
        let neighbors = vec![
            (uuid::Uuid::new_v4(), vec![0.1, 0.2, 0.3], 0.92), // High similarity
        ];

        let result = detector.detect_with_neighbors(&embedding, &neighbors);
        assert!(result.has_contradiction);
        assert!(result.penalty > 0.0);
    }

    #[test]
    fn test_contradiction_detector_no_conflicts() {
        let detector = ContradictionDetector::default();
        let embedding = vec![0.1, 0.2, 0.3];
        let neighbors = vec![
            (uuid::Uuid::new_v4(), vec![0.5, 0.5, 0.0], 0.6), // Low similarity
        ];

        let result = detector.detect_with_neighbors(&embedding, &neighbors);
        assert!(!result.has_contradiction);
    }

    #[test]
    fn test_coherence_result_new() {
        let contradiction = ContradictionResult::none();
        let result = CoherenceResult::new(0.8, 0.6, contradiction);

        // Expected: 0.8 * 0.6 + 0.6 * 0.4 = 0.48 + 0.24 = 0.72
        assert!((result.coherence - 0.72).abs() < 0.001);
        assert_eq!(result.semantic_coherence, 0.8);
        assert_eq!(result.structural_coherence, 0.6);
    }

    #[test]
    fn test_coherence_result_with_penalty() {
        let contradiction = ContradictionResult::detected(
            0.3, vec![], vec![], "Test".to_string()
        );
        let result = CoherenceResult::new(0.8, 0.6, contradiction);

        // Base: 0.72, with 0.3 penalty: 0.72 * 0.7 = 0.504
        assert!((result.coherence - 0.504).abs() < 0.001);
        assert!(result.has_contradiction());
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `CoherenceConfig` has all 7 new fields with correct defaults
- [ ] `CoherenceConfig::validate()` checks all new field ranges
- [ ] `semantic_weight + structural_weight == 1.0` invariant enforced
- [ ] `ContradictionResult::none()` returns zero penalty
- [ ] `ContradictionResult::detected()` clamps penalty to [0, max_penalty]
- [ ] `ContradictionDetector::detect()` returns stub (no contradiction)
- [ ] `ContradictionDetector::detect_with_neighbors()` computes real penalties
- [ ] `CoherenceResult::new()` applies formula: `(sem*w_s + struct*w_st) * (1-penalty)`
- [ ] All types exported from `coherence` module

### Performance Requirements

- [ ] `ContradictionDetector::detect()` < 100μs (stub)
- [ ] `ContradictionDetector::detect_with_neighbors()` < 1ms for 50 neighbors
- [ ] `CoherenceResult::new()` < 10μs

### Code Quality Requirements

- [ ] No `unwrap()` in production code - use `clamp()` or return defaults
- [ ] All public types have rustdoc with examples
- [ ] All new structs derive `Debug, Clone`
- [ ] `ContradictionResult` derives `Default`
- [ ] All tests pass: `cargo test -p context-graph-utl --lib`

---

## Full State Verification Protocol

After completing the implementation, you MUST perform the following verification:

### 1. Source of Truth Identification

The source of truth is:
- `crates/context-graph-utl/src/config.rs` - CoherenceConfig struct
- `crates/context-graph-utl/src/coherence/structural.rs` - New types
- `crates/context-graph-utl/src/coherence/mod.rs` - Module exports

### 2. Execute & Inspect

```bash
# Build the crate
cargo build -p context-graph-utl 2>&1 | head -50

# Run all tests
cargo test -p context-graph-utl --lib 2>&1 | tail -10

# Verify new types are exported
cargo doc -p context-graph-utl --no-deps 2>&1 | grep -E "(ContradictionResult|ContradictionDetector|CoherenceResult)"
```

### 3. Boundary & Edge Case Audit

You MUST manually test these 3 edge cases and print before/after state:

**Edge Case 1: Empty Neighbors**
```rust
let detector = ContradictionDetector::default();
let result = detector.detect_with_neighbors(&[0.1, 0.2], &[]);
// BEFORE: Empty neighbors vec
// AFTER: ContradictionResult { has_contradiction: false, penalty: 0.0, ... }
```

**Edge Case 2: Similarity at Exact Threshold (0.85)**
```rust
let detector = ContradictionDetector::default();
let neighbors = vec![(Uuid::new_v4(), vec![0.1], 0.85)];
let result = detector.detect_with_neighbors(&[0.1], &neighbors);
// BEFORE: similarity == threshold (0.85)
// AFTER: Should be detected (>= threshold)
```

**Edge Case 3: Maximum Penalty Clamping**
```rust
let detector = ContradictionDetector::default();
let neighbors = vec![
    (Uuid::new_v4(), vec![0.1], 0.97),
    (Uuid::new_v4(), vec![0.1], 0.96),
];
let result = detector.detect_with_neighbors(&[0.1], &neighbors);
// BEFORE: Very high similarities
// AFTER: penalty should be clamped to max_penalty (0.5)
```

### 4. Evidence of Success

After implementation, provide a log showing:
```
=== M05-T14 Verification Log ===
CoherenceConfig fields:
  - contradiction_search_k: 20 ✓
  - contradiction_similarity_threshold: 0.85 ✓
  - max_contradiction_penalty: 0.5 ✓
  - semantic_weight: 0.6 ✓
  - structural_weight: 0.4 ✓
  - default_coherence_empty: 0.5 ✓
  - default_coherence_no_concepts: 0.4 ✓

New types exported:
  - ContradictionResult ✓
  - ContradictionDetector ✓
  - CoherenceResult ✓

Test results: X passed, 0 failed

Edge case verification:
  - Empty neighbors: ✓
  - Threshold boundary: ✓
  - Max penalty clamp: ✓
```

---

## Integration Notes

### Upstream Dependencies

- **M05-T03**: `CoherenceConfig` struct (EXTEND, do not replace)
- **M05-T13**: `CoherenceTracker` (no changes needed)
- Existing `structural.rs` implementation (EXTEND)

### Downstream Consumers

- **M05-T22**: `UtlProcessor` will use `CoherenceResult` for full coherence
- **M05-T35**: Real KnowledgeGraph integration replaces stub `detect()`
- **M05-T61**: `Conflict Alert Detection` uses `ContradictionResult`

### Stub vs Real Implementation

This task implements **stubs** for graph integration:
1. `ContradictionDetector::detect()` always returns `ContradictionResult::none()`
2. `detect_with_neighbors()` is testable with explicit neighbor data
3. M05-T35 will inject real graph queries

### NO BACKWARDS COMPATIBILITY

- Do NOT add deprecated fields
- Do NOT add migration code
- If validation fails, return `Err` immediately
- If computation fails, return error or use safe defaults

---

## Final Verification: Sherlock Holmes Audit

After implementation is complete, spawn the `sherlock-holmes` subagent with:

```
Investigate M05-T14 implementation:

1. Verify all 7 new CoherenceConfig fields exist with correct types
2. Verify validate() checks all new field constraints
3. Verify ContradictionResult, ContradictionDetector, CoherenceResult exist
4. Verify all types exported from coherence::mod.rs
5. Verify all tests pass
6. Verify no unwrap() in production code
7. Verify edge cases are handled correctly

Report any discrepancies immediately.
```

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-04 | AI Agent | Complete rewrite based on codebase audit |
| 2026-01-04 | AI Agent | Added verification protocol and edge cases |
| 2026-01-04 | AI Agent | Identified missing fields in CoherenceConfig |
