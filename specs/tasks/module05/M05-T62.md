# M05-T62: Implement Dynamic UTL Thresholds by Lifecycle Stage

## Task Metadata
- **ID**: M05-T62
- **Title**: Implement Dynamic UTL Thresholds by Lifecycle Stage
- **Module**: 05 - UTL Integration
- **Layer**: logic
- **Priority**: high
- **Estimated Hours**: 2
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement dynamic entropy and coherence thresholds based on lifecycle stage per PRD Section 5.

Per PRD System Lifecycle table:
| Stage | Interactions | Entropy Threshold | Coherence Threshold | Lambda Weights |
|-------|--------------|-------------------|---------------------|----------------|
| Infancy | 0-50 | 0.9 | 0.2 | λ_ΔS: 0.7, λ_ΔC: 0.3 |
| Growth | 50-500 | 0.7 | 0.4 | λ_ΔS: 0.5, λ_ΔC: 0.5 |
| Maturity | 500+ | 0.6 | 0.5 | λ_ΔS: 0.3, λ_ΔC: 0.7 |

These thresholds affect:
1. When to trigger warnings/gating
2. How to weight learning signals
3. Tool behavior recommendations

## File Paths

### Implementation
- `crates/context-graph-utl/src/lifecycle/thresholds.rs`
- `crates/context-graph-utl/src/lifecycle/mod.rs`

### Tests
- `crates/context-graph-utl/tests/lifecycle_threshold_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T05 | Implement LifecycleStage Enum | pending |
| M05-T07 | Implement LifecycleConfig | pending |
| M05-T19 | Implement LifecycleManager | pending |

## Acceptance Criteria

- [ ] LifecycleThresholds struct with entropy/coherence/lambda
- [ ] Thresholds change dynamically based on stage
- [ ] Stage transitions update thresholds
- [ ] Thresholds accessible from UtlProcessor
- [ ] Configuration override support

## Specification References

- `contextgraphprd.md` Section 5 System Lifecycle
- `implementationplan.md` Module 5 Components

## Implementation Notes

### Lifecycle Thresholds Structure

```rust
use serde::{Serialize, Deserialize};

/// Dynamic thresholds based on lifecycle stage
/// Per PRD Section 5 System Lifecycle table
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LifecycleThresholds {
    /// Entropy threshold for this stage
    /// Above this triggers exploration/capture behavior
    pub entropy_threshold: f32,

    /// Coherence threshold for this stage
    /// Below this triggers consolidation/curation behavior
    pub coherence_threshold: f32,

    /// Lambda weight for novelty (surprise)
    pub lambda_novelty: f32,

    /// Lambda weight for consolidation (coherence)
    pub lambda_consolidation: f32,

    /// Current lifecycle stage
    pub stage: LifecycleStage,

    /// Interaction count when thresholds were computed
    pub interaction_count: u64,
}

impl LifecycleThresholds {
    /// Create thresholds for given lifecycle stage
    /// Per PRD Section 5 table
    pub fn for_stage(stage: LifecycleStage, interaction_count: u64) -> Self {
        match stage {
            LifecycleStage::Infancy => Self {
                entropy_threshold: 0.9,      // High tolerance for entropy
                coherence_threshold: 0.2,    // Low requirement for coherence
                lambda_novelty: 0.7,         // Favor exploration
                lambda_consolidation: 0.3,
                stage,
                interaction_count,
            },
            LifecycleStage::Growth => Self {
                entropy_threshold: 0.7,      // Balanced tolerance
                coherence_threshold: 0.4,    // Moderate coherence needed
                lambda_novelty: 0.5,         // Balanced weights
                lambda_consolidation: 0.5,
                stage,
                interaction_count,
            },
            LifecycleStage::Maturity => Self {
                entropy_threshold: 0.6,      // Lower entropy tolerance
                coherence_threshold: 0.5,    // Higher coherence needed
                lambda_novelty: 0.3,         // Favor consolidation
                lambda_consolidation: 0.7,
                stage,
                interaction_count,
            },
        }
    }

    /// Update thresholds based on new interaction count
    pub fn update(&mut self, interaction_count: u64) {
        let new_stage = LifecycleStage::from_interaction_count(interaction_count);

        if new_stage != self.stage {
            *self = Self::for_stage(new_stage, interaction_count);
        } else {
            self.interaction_count = interaction_count;
        }
    }

    /// Check if entropy is above threshold (triggering exploration)
    pub fn entropy_above_threshold(&self, entropy: f32) -> bool {
        entropy > self.entropy_threshold
    }

    /// Check if coherence is below threshold (triggering consolidation)
    pub fn coherence_below_threshold(&self, coherence: f32) -> bool {
        coherence < self.coherence_threshold
    }

    /// Apply lifecycle-weighted learning formula
    /// L = (ΔS * λ_n + ΔC * λ_c) * w_e * cos(φ)
    pub fn apply_weights(
        &self,
        surprise: f32,
        coherence: f32,
        emotional_weight: f32,
        phase_modulation: f32,
    ) -> f32 {
        let weighted_surprise = surprise * self.lambda_novelty;
        let weighted_coherence = coherence * self.lambda_consolidation;
        let combined = weighted_surprise + weighted_coherence;

        combined * emotional_weight * phase_modulation
    }

    /// Get stance description for this stage
    pub fn stance(&self) -> &'static str {
        match self.stage {
            LifecycleStage::Infancy => "Capture-heavy",
            LifecycleStage::Growth => "Balanced",
            LifecycleStage::Maturity => "Curation-heavy",
        }
    }

    /// Validate lambda weight invariant
    /// Per constitution.yaml: lambda_novelty + lambda_consolidation = 1.0
    pub fn validate_invariant(&self) -> bool {
        (self.lambda_novelty + self.lambda_consolidation - 1.0).abs() < 0.001
    }
}

impl Default for LifecycleThresholds {
    fn default() -> Self {
        Self::for_stage(LifecycleStage::Infancy, 0)
    }
}
```

### Threshold Manager

```rust
/// Manages dynamic threshold updates across the system
pub struct ThresholdManager {
    /// Current thresholds
    thresholds: RwLock<LifecycleThresholds>,

    /// Configuration overrides
    config: ThresholdConfig,

    /// Callback for threshold changes
    on_change: Option<Box<dyn Fn(&LifecycleThresholds) + Send + Sync>>,
}

/// Configuration for threshold overrides
#[derive(Debug, Clone)]
pub struct ThresholdConfig {
    /// Override entropy threshold (if set)
    pub entropy_override: Option<f32>,

    /// Override coherence threshold (if set)
    pub coherence_override: Option<f32>,

    /// Override lambda novelty (if set)
    pub lambda_novelty_override: Option<f32>,

    /// Custom stage transition boundaries
    pub stage_boundaries: StageBoundaries,
}

#[derive(Debug, Clone)]
pub struct StageBoundaries {
    /// Infancy -> Growth transition
    pub infancy_to_growth: u64,  // Default: 50

    /// Growth -> Maturity transition
    pub growth_to_maturity: u64,  // Default: 500
}

impl Default for StageBoundaries {
    fn default() -> Self {
        Self {
            infancy_to_growth: 50,
            growth_to_maturity: 500,
        }
    }
}

impl ThresholdManager {
    pub fn new(config: ThresholdConfig) -> Self {
        Self {
            thresholds: RwLock::new(LifecycleThresholds::default()),
            config,
            on_change: None,
        }
    }

    /// Set callback for threshold changes
    pub fn on_threshold_change<F>(&mut self, callback: F)
    where
        F: Fn(&LifecycleThresholds) + Send + Sync + 'static,
    {
        self.on_change = Some(Box::new(callback));
    }

    /// Update thresholds based on interaction count
    pub async fn update(&self, interaction_count: u64) {
        let mut thresholds = self.thresholds.write().await;
        let old_stage = thresholds.stage;

        thresholds.update(interaction_count);

        // Apply overrides
        if let Some(entropy) = self.config.entropy_override {
            thresholds.entropy_threshold = entropy;
        }
        if let Some(coherence) = self.config.coherence_override {
            thresholds.coherence_threshold = coherence;
        }
        if let Some(lambda_n) = self.config.lambda_novelty_override {
            thresholds.lambda_novelty = lambda_n;
            thresholds.lambda_consolidation = 1.0 - lambda_n;
        }

        // Notify if stage changed
        if thresholds.stage != old_stage {
            tracing::info!(
                old_stage = ?old_stage,
                new_stage = ?thresholds.stage,
                interaction_count,
                "Lifecycle stage transition"
            );

            if let Some(ref callback) = self.on_change {
                callback(&thresholds);
            }
        }
    }

    /// Get current thresholds (read-only snapshot)
    pub async fn get(&self) -> LifecycleThresholds {
        self.thresholds.read().await.clone()
    }

    /// Check if should trigger exploration based on current entropy
    pub async fn should_explore(&self, entropy: f32) -> bool {
        let thresholds = self.thresholds.read().await;
        thresholds.entropy_above_threshold(entropy)
    }

    /// Check if should trigger consolidation based on current coherence
    pub async fn should_consolidate(&self, coherence: f32) -> bool {
        let thresholds = self.thresholds.read().await;
        thresholds.coherence_below_threshold(coherence)
    }

    /// Get behavior recommendation based on UTL state
    pub async fn get_recommendation(
        &self,
        entropy: f32,
        coherence: f32,
    ) -> BehaviorRecommendation {
        let thresholds = self.thresholds.read().await;

        let above_entropy = entropy > thresholds.entropy_threshold;
        let below_coherence = coherence < thresholds.coherence_threshold;

        match (above_entropy, below_coherence, thresholds.stage) {
            // High entropy in infancy: expected, continue exploring
            (true, _, LifecycleStage::Infancy) => BehaviorRecommendation::ContinueExploring,

            // High entropy in maturity: concerning, need consolidation
            (true, _, LifecycleStage::Maturity) => BehaviorRecommendation::TriggerConsolidation,

            // Low coherence: need to build structure
            (_, true, _) => BehaviorRecommendation::BuildCoherence,

            // Balanced state: continue normally
            (false, false, _) => BehaviorRecommendation::Continue,

            // Growth stage with high entropy
            (true, false, LifecycleStage::Growth) => BehaviorRecommendation::BalanceExploration,
        }
    }
}

/// Behavior recommendation based on lifecycle and UTL state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum BehaviorRecommendation {
    /// Continue normal operation
    Continue,

    /// Continue exploring (infancy with high entropy)
    ContinueExploring,

    /// Balance exploration and consolidation (growth)
    BalanceExploration,

    /// Trigger consolidation (maturity with high entropy)
    TriggerConsolidation,

    /// Build coherence (low coherence state)
    BuildCoherence,
}
```

### Integration with UtlProcessor

```rust
impl UtlProcessor {
    /// Get current lifecycle thresholds
    pub async fn get_thresholds(&self) -> LifecycleThresholds {
        self.threshold_manager.get().await
    }

    /// Compute learning with lifecycle-aware weights
    pub async fn compute_with_lifecycle(
        &self,
        context: &UtlContext,
    ) -> Result<LearningSignal, UtlError> {
        let thresholds = self.threshold_manager.get().await;

        // Compute raw components
        let surprise = self.surprise_calculator.compute(&context)?;
        let coherence = self.coherence_tracker.compute(&context)?;
        let emotional_weight = self.emotional_calculator.compute(&context)?;
        let phase = self.phase_oscillator.current_phase();

        // Apply lifecycle-weighted formula
        let learning_magnitude = thresholds.apply_weights(
            surprise,
            coherence,
            emotional_weight,
            phase.cos(),
        );

        // Classify Johari quadrant using lifecycle thresholds
        let johari_quadrant = self.johari_classifier.classify_with_thresholds(
            surprise,
            coherence,
            &thresholds,
        );

        Ok(LearningSignal {
            learning_magnitude,
            surprise,
            coherence,
            emotional_weight,
            phase_modulation: phase.cos(),
            johari_quadrant,
            lambda_weights: LambdaWeights {
                lambda_novelty: thresholds.lambda_novelty,
                lambda_consolidation: thresholds.lambda_consolidation,
            },
            lifecycle_stage: thresholds.stage,
            suggested_action: self.compute_suggested_action(&thresholds, surprise, coherence),
            computed_at: Utc::now(),
            latency_us: 0,  // Filled by caller
        })
    }

    fn compute_suggested_action(
        &self,
        thresholds: &LifecycleThresholds,
        entropy: f32,
        coherence: f32,
    ) -> Option<SuggestedAction> {
        // Per PRD Section 3.2 Cognitive Pulse table
        match (entropy > 0.7, coherence > 0.5) {
            (true, true) => Some(SuggestedAction::EpistemicAction),
            (true, false) => Some(SuggestedAction::TriggerDream),
            (false, false) => Some(SuggestedAction::GetNeighborhood),
            (false, true) => None,  // Continue working
        }
    }
}
```

## Testing Requirements

1. **Stage Threshold Tests**
   - Infancy thresholds correct (0.9/0.2)
   - Growth thresholds correct (0.7/0.4)
   - Maturity thresholds correct (0.6/0.5)

2. **Lambda Weight Tests**
   - Infancy weights: 0.7/0.3
   - Growth weights: 0.5/0.5
   - Maturity weights: 0.3/0.7
   - Invariant: lambda_novelty + lambda_consolidation = 1.0

3. **Transition Tests**
   - Infancy -> Growth at 50 interactions
   - Growth -> Maturity at 500 interactions
   - Thresholds update on transition

4. **Override Tests**
   - Configuration overrides applied
   - Partial overrides work correctly
   - Custom boundaries respected

5. **Integration Tests**
   - UtlProcessor uses correct thresholds
   - Learning magnitude weighted correctly
   - Recommendations match expected behavior

---

*Task specification generated for Module 05 - UTL Integration*
