# M05-T58: Implement UTL Subscribable Pulse Resource

## Task Metadata
- **ID**: M05-T58
- **Title**: Implement UTL Subscribable Pulse Resource
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: medium
- **Estimated Hours**: 2.5
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement the `utl://current_session/pulse` subscribable resource per PRD Section 4.6.

This resource enables clients to subscribe to real-time cognitive pulse updates, receiving:
- Entropy changes
- Coherence changes
- Johari quadrant transitions
- Suggested action updates

Per PRD: "utl://current_session/pulse - Subscribable cognitive pulse"

The subscription should emit events when:
1. UTL state changes significantly (delta > threshold)
2. Johari quadrant transitions
3. Suggested action changes
4. Lifecycle stage transitions

## File Paths

### Implementation
- `crates/context-graph-mcp/src/resources/utl_pulse.rs`
- `crates/context-graph-mcp/src/resources/mod.rs`

### Tests
- `crates/context-graph-mcp/tests/utl_pulse_resource_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T22 | Implement UtlProcessor | pending |
| M05-T28 | Implement CognitivePulse Header | pending |
| M05-T44 | Implement UTL Resource Endpoints | pending |

## Acceptance Criteria

- [ ] Resource URI `utl://current_session/pulse` registered
- [ ] Subscription emits PulseUpdate events
- [ ] Delta threshold configurable (default: 0.1)
- [ ] Johari transitions trigger updates
- [ ] Backpressure handling for slow subscribers
- [ ] Resource compatible with MCP 2024-11-05 spec

## Specification References

- `contextgraphprd.md` Section 4.6 Resources
- MCP Resource Subscription Protocol

## Implementation Notes

### PulseUpdate Event Structure

```rust
use serde::{Serialize, Deserialize};

/// Event emitted when cognitive pulse changes significantly
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PulseUpdate {
    /// Current entropy value [0.0, 1.0]
    pub entropy: f32,

    /// Current coherence value [0.0, 1.0]
    pub coherence: f32,

    /// Current Johari quadrant
    pub johari_quadrant: JohariQuadrant,

    /// Suggested action (if any)
    pub suggested_action: Option<SuggestedAction>,

    /// Current lifecycle stage
    pub lifecycle_stage: LifecycleStage,

    /// Timestamp of this update
    pub timestamp: DateTime<Utc>,

    /// Session ID this pulse belongs to
    pub session_id: String,

    /// Change type that triggered this update
    pub trigger: PulseTrigger,
}

/// What triggered this pulse update
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PulseTrigger {
    /// Entropy changed by more than threshold
    EntropyChange { delta: f32 },

    /// Coherence changed by more than threshold
    CoherenceChange { delta: f32 },

    /// Johari quadrant transitioned
    JohariTransition { from: JohariQuadrant, to: JohariQuadrant },

    /// Suggested action changed
    ActionChange { previous: Option<SuggestedAction>, current: Option<SuggestedAction> },

    /// Lifecycle stage transitioned
    LifecycleTransition { from: LifecycleStage, to: LifecycleStage },

    /// Periodic heartbeat (configurable interval)
    Heartbeat,
}
```

### Subscription Manager

```rust
use tokio::sync::broadcast;
use std::sync::Arc;

/// Configuration for pulse subscriptions
#[derive(Debug, Clone)]
pub struct PulseSubscriptionConfig {
    /// Minimum change in entropy to trigger update
    pub entropy_threshold: f32,  // Default: 0.1

    /// Minimum change in coherence to trigger update
    pub coherence_threshold: f32,  // Default: 0.1

    /// Whether to send heartbeats
    pub enable_heartbeat: bool,  // Default: true

    /// Heartbeat interval in seconds
    pub heartbeat_interval_secs: u64,  // Default: 30

    /// Maximum pending updates before backpressure
    pub max_pending: usize,  // Default: 100
}

impl Default for PulseSubscriptionConfig {
    fn default() -> Self {
        Self {
            entropy_threshold: 0.1,
            coherence_threshold: 0.1,
            enable_heartbeat: true,
            heartbeat_interval_secs: 30,
            max_pending: 100,
        }
    }
}

/// Manages pulse subscriptions for a session
pub struct PulseSubscriptionManager {
    /// Broadcast sender for pulse updates
    sender: broadcast::Sender<PulseUpdate>,

    /// Last emitted state for delta calculation
    last_state: Arc<RwLock<Option<PulseState>>>,

    /// Configuration
    config: PulseSubscriptionConfig,
}

impl PulseSubscriptionManager {
    pub fn new(config: PulseSubscriptionConfig) -> Self {
        let (sender, _) = broadcast::channel(config.max_pending);
        Self {
            sender,
            last_state: Arc::new(RwLock::new(None)),
            config,
        }
    }

    /// Subscribe to pulse updates
    pub fn subscribe(&self) -> broadcast::Receiver<PulseUpdate> {
        self.sender.subscribe()
    }

    /// Called when UTL state changes - emits update if significant
    pub async fn on_utl_update(&self, signal: &LearningSignal) {
        let should_emit = self.check_should_emit(signal).await;

        if let Some(trigger) = should_emit {
            let update = PulseUpdate {
                entropy: signal.surprise,  // Entropy maps to surprise
                coherence: signal.coherence,
                johari_quadrant: signal.johari_quadrant,
                suggested_action: signal.suggested_action.clone(),
                lifecycle_stage: signal.lifecycle_stage,
                timestamp: Utc::now(),
                session_id: signal.session_id.clone(),
                trigger,
            };

            // Best-effort broadcast - don't block on slow subscribers
            let _ = self.sender.send(update);

            // Update last state
            self.update_last_state(signal).await;
        }
    }

    async fn check_should_emit(&self, signal: &LearningSignal) -> Option<PulseTrigger> {
        let last = self.last_state.read().await;

        match &*last {
            None => Some(PulseTrigger::Heartbeat),  // First update
            Some(prev) => {
                // Check entropy change
                let entropy_delta = (signal.surprise - prev.entropy).abs();
                if entropy_delta >= self.config.entropy_threshold {
                    return Some(PulseTrigger::EntropyChange { delta: entropy_delta });
                }

                // Check coherence change
                let coherence_delta = (signal.coherence - prev.coherence).abs();
                if coherence_delta >= self.config.coherence_threshold {
                    return Some(PulseTrigger::CoherenceChange { delta: coherence_delta });
                }

                // Check Johari transition
                if signal.johari_quadrant != prev.johari_quadrant {
                    return Some(PulseTrigger::JohariTransition {
                        from: prev.johari_quadrant,
                        to: signal.johari_quadrant,
                    });
                }

                // Check lifecycle transition
                if signal.lifecycle_stage != prev.lifecycle_stage {
                    return Some(PulseTrigger::LifecycleTransition {
                        from: prev.lifecycle_stage,
                        to: signal.lifecycle_stage,
                    });
                }

                // Check action change
                if signal.suggested_action != prev.suggested_action {
                    return Some(PulseTrigger::ActionChange {
                        previous: prev.suggested_action.clone(),
                        current: signal.suggested_action.clone(),
                    });
                }

                None
            }
        }
    }
}
```

### MCP Resource Handler

```rust
use mcp_sdk::resource::{Resource, ResourceHandler};

/// MCP resource handler for utl://current_session/pulse
pub struct UtlPulseResource {
    subscription_manager: Arc<PulseSubscriptionManager>,
}

impl ResourceHandler for UtlPulseResource {
    fn uri_pattern(&self) -> &str {
        "utl://current_session/pulse"
    }

    fn supports_subscription(&self) -> bool {
        true
    }

    async fn read(&self, uri: &str) -> Result<Resource, ResourceError> {
        // Return current pulse state as snapshot
        let state = self.subscription_manager.get_current_state().await;

        Ok(Resource {
            uri: uri.to_string(),
            mime_type: Some("application/json".to_string()),
            contents: serde_json::to_string(&state)?,
        })
    }

    async fn subscribe(&self, uri: &str) -> Result<impl Stream<Item = Resource>, ResourceError> {
        let receiver = self.subscription_manager.subscribe();

        let stream = tokio_stream::wrappers::BroadcastStream::new(receiver)
            .filter_map(|result| async move {
                match result {
                    Ok(update) => Some(Resource {
                        uri: uri.to_string(),
                        mime_type: Some("application/json".to_string()),
                        contents: serde_json::to_string(&update).ok()?,
                    }),
                    Err(_) => None,  // Lagged - skip
                }
            });

        Ok(stream)
    }
}
```

## Testing Requirements

1. **Subscription Tests**
   - Subscribe successfully
   - Receive updates on significant changes
   - Backpressure handling (slow subscriber)
   - Multiple subscribers receive same updates

2. **Threshold Tests**
   - Entropy threshold triggers correctly
   - Coherence threshold triggers correctly
   - Below-threshold changes don't emit

3. **Transition Tests**
   - Johari quadrant transitions emit
   - Lifecycle transitions emit
   - Action changes emit

4. **Integration Tests**
   - Full MCP resource subscription flow
   - JSON serialization correct
   - URI pattern matching

---

*Task specification generated for Module 05 - UTL Integration*
