# M05-T61: Implement Conflict Alert Detection

## Task Metadata
- **ID**: M05-T61
- **Title**: Implement Conflict Alert Detection
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: high
- **Estimated Hours**: 3
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement semantic conflict detection for inject_context responses per PRD Section 3.1.

Per PRD:
- "`conflict_alert`: Semantic conflict detection"
- Part of inject_context response

Conflict detection identifies when retrieved context contains:
1. Contradictory information
2. Temporal inconsistencies (old vs new)
3. Domain mismatches
4. Perspective conflicts (different agent priors)

## File Paths

### Implementation
- `crates/context-graph-utl/src/conflict/detector.rs`
- `crates/context-graph-utl/src/conflict/mod.rs`
- `crates/context-graph-utl/src/conflict/types.rs`

### Tests
- `crates/context-graph-utl/tests/conflict_detection_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T22 | Implement UtlProcessor | pending |
| M05-T59 | Implement Priors Vibe Check | pending |

## Acceptance Criteria

- [ ] ConflictAlert struct with conflict details
- [ ] Semantic contradiction detection
- [ ] Temporal conflict detection
- [ ] Priors/perspective conflict detection
- [ ] Conflict severity scoring
- [ ] Resolution suggestions

## Specification References

- `contextgraphprd.md` Section 3.1 Context Injection
- `contextgraphprd.md` Section 7.2 Homeostatic Plasticity

## Implementation Notes

### Conflict Alert Structure

```rust
use serde::{Serialize, Deserialize};

/// Alert for detected conflicts in retrieved context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConflictAlert {
    /// Whether any conflicts were detected
    pub has_conflicts: bool,

    /// Severity of worst conflict
    pub max_severity: ConflictSeverity,

    /// List of detected conflicts
    pub conflicts: Vec<Conflict>,

    /// Overall confidence in conflict detection
    pub detection_confidence: f32,

    /// Suggested resolution actions
    pub resolutions: Vec<ConflictResolution>,
}

/// Severity levels for conflicts
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum ConflictSeverity {
    /// Minor inconsistency - may not matter
    Low,

    /// Notable conflict - should be aware
    Medium,

    /// Significant conflict - needs attention
    High,

    /// Direct contradiction - must resolve
    Critical,
}

/// A detected conflict between context items
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Conflict {
    /// Type of conflict
    pub conflict_type: ConflictType,

    /// Severity of this conflict
    pub severity: ConflictSeverity,

    /// First conflicting item
    pub item_a: ConflictItem,

    /// Second conflicting item
    pub item_b: ConflictItem,

    /// Confidence in this conflict detection [0.0, 1.0]
    pub confidence: f32,

    /// Human-readable explanation
    pub explanation: String,
}

/// Types of conflicts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConflictType {
    /// Direct logical contradiction
    /// e.g., "X is true" vs "X is false"
    Contradiction,

    /// Temporal inconsistency
    /// e.g., "X was implemented" (old) vs "X not yet implemented" (new)
    TemporalInconsistency,

    /// Domain mismatch
    /// e.g., Python advice applied to Java code
    DomainMismatch,

    /// Perspective conflict from different agents/priors
    /// e.g., "X is best practice" vs "X is anti-pattern"
    PerspectiveConflict,

    /// Numerical/value discrepancy
    /// e.g., "timeout is 30s" vs "timeout is 60s"
    ValueDiscrepancy,

    /// Implicit conflict (inferred contradiction)
    ImplicitContradiction,
}

/// A conflicting item in the context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConflictItem {
    /// Node ID if from graph
    pub node_id: Option<String>,

    /// Content snippet
    pub content: String,

    /// Source/provenance
    pub source: String,

    /// Timestamp if available
    pub timestamp: Option<DateTime<Utc>>,

    /// Agent ID if from multi-agent context
    pub agent_id: Option<String>,

    /// Domain context
    pub domain: Option<String>,
}

/// Suggested resolution for a conflict
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConflictResolution {
    /// Resolution action
    pub action: ResolutionAction,

    /// Which item to prefer (if applicable)
    pub preferred_item: Option<ConflictItem>,

    /// Reason for this resolution
    pub reason: String,

    /// Confidence in this resolution [0.0, 1.0]
    pub confidence: f32,
}

/// Resolution actions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResolutionAction {
    /// Prefer newer information
    PreferNewer,

    /// Prefer higher confidence source
    PreferHigherConfidence,

    /// Ask user to resolve
    AskUser { question: String },

    /// Create relational edge showing both
    CreateRelationalEdge,

    /// Mark both as uncertain
    MarkUncertain,

    /// Merge with context qualification
    /// e.g., "In context A, X; in context B, Y"
    MergeWithQualification,
}
```

### Conflict Detector

```rust
/// Configuration for conflict detection
#[derive(Debug, Clone)]
pub struct ConflictDetectionConfig {
    /// Cosine similarity threshold for contradiction (higher = more similar required)
    pub contradiction_threshold: f32,  // Default: 0.85

    /// Time threshold for temporal conflicts (seconds)
    pub temporal_threshold_secs: i64,  // Default: 86400 (24 hours)

    /// Whether to detect implicit contradictions
    pub detect_implicit: bool,  // Default: true

    /// Minimum confidence to report conflict
    pub min_confidence: f32,  // Default: 0.6

    /// Use priors for perspective conflict detection
    pub use_priors: bool,  // Default: true
}

impl Default for ConflictDetectionConfig {
    fn default() -> Self {
        Self {
            contradiction_threshold: 0.85,
            temporal_threshold_secs: 86400,
            detect_implicit: true,
            min_confidence: 0.6,
            use_priors: true,
        }
    }
}

/// Detects conflicts in retrieved context
pub struct ConflictDetector {
    config: ConflictDetectionConfig,
}

impl ConflictDetector {
    pub fn new(config: ConflictDetectionConfig) -> Self {
        Self { config }
    }

    /// Detect conflicts in retrieved nodes
    pub fn detect_conflicts(
        &self,
        nodes: &[MemoryNode],
    ) -> ConflictAlert {
        let mut conflicts = Vec::new();

        // Compare all pairs of nodes
        for i in 0..nodes.len() {
            for j in (i + 1)..nodes.len() {
                if let Some(conflict) = self.check_pair(&nodes[i], &nodes[j]) {
                    if conflict.confidence >= self.config.min_confidence {
                        conflicts.push(conflict);
                    }
                }
            }
        }

        // Sort by severity
        conflicts.sort_by_key(|c| std::cmp::Reverse(c.severity));

        // Generate resolutions
        let resolutions = self.generate_resolutions(&conflicts);

        let max_severity = conflicts.first()
            .map(|c| c.severity)
            .unwrap_or(ConflictSeverity::Low);

        let detection_confidence = if conflicts.is_empty() {
            1.0
        } else {
            conflicts.iter().map(|c| c.confidence).sum::<f32>() / conflicts.len() as f32
        };

        ConflictAlert {
            has_conflicts: !conflicts.is_empty(),
            max_severity,
            conflicts,
            detection_confidence,
            resolutions,
        }
    }

    /// Check a pair of nodes for conflicts
    fn check_pair(&self, a: &MemoryNode, b: &MemoryNode) -> Option<Conflict> {
        // Check direct contradiction first
        if let Some(contradiction) = self.check_contradiction(a, b) {
            return Some(contradiction);
        }

        // Check temporal inconsistency
        if let Some(temporal) = self.check_temporal(a, b) {
            return Some(temporal);
        }

        // Check domain mismatch
        if let Some(domain) = self.check_domain_mismatch(a, b) {
            return Some(domain);
        }

        // Check perspective conflict (if priors enabled)
        if self.config.use_priors {
            if let Some(perspective) = self.check_perspective_conflict(a, b) {
                return Some(perspective);
            }
        }

        None
    }

    /// Check for direct contradiction
    fn check_contradiction(&self, a: &MemoryNode, b: &MemoryNode) -> Option<Conflict> {
        // Check for negation patterns
        let negation_patterns = [
            ("is", "is not"),
            ("true", "false"),
            ("enabled", "disabled"),
            ("should", "should not"),
            ("can", "cannot"),
            ("will", "will not"),
            ("exists", "does not exist"),
        ];

        let a_lower = a.content.to_lowercase();
        let b_lower = b.content.to_lowercase();

        for (pos, neg) in negation_patterns {
            let a_has_pos = a_lower.contains(pos) && !a_lower.contains(neg);
            let b_has_neg = b_lower.contains(neg);
            let a_has_neg = a_lower.contains(neg);
            let b_has_pos = b_lower.contains(pos) && !b_lower.contains(neg);

            // Check if discussing same subject with opposite claims
            if (a_has_pos && b_has_neg) || (a_has_neg && b_has_pos) {
                // Verify they're discussing same subject via embedding similarity
                let similarity = self.cosine_similarity(&a.embedding, &b.embedding);
                if similarity > self.config.contradiction_threshold {
                    return Some(Conflict {
                        conflict_type: ConflictType::Contradiction,
                        severity: ConflictSeverity::Critical,
                        item_a: self.node_to_item(a),
                        item_b: self.node_to_item(b),
                        confidence: similarity,
                        explanation: format!(
                            "Direct contradiction detected: similar content (sim={:.2}) \
                             with opposing claims",
                            similarity
                        ),
                    });
                }
            }
        }

        None
    }

    /// Check for temporal inconsistency
    fn check_temporal(&self, a: &MemoryNode, b: &MemoryNode) -> Option<Conflict> {
        let time_diff = (a.timestamp - b.timestamp).num_seconds().abs();

        if time_diff >= self.config.temporal_threshold_secs {
            // Check if content is similar but might be outdated
            let similarity = self.cosine_similarity(&a.embedding, &b.embedding);
            if similarity > 0.7 {
                let (older, newer) = if a.timestamp < b.timestamp { (a, b) } else { (b, a) };

                return Some(Conflict {
                    conflict_type: ConflictType::TemporalInconsistency,
                    severity: ConflictSeverity::Medium,
                    item_a: self.node_to_item(older),
                    item_b: self.node_to_item(newer),
                    confidence: similarity * 0.8,
                    explanation: format!(
                        "Temporal inconsistency: similar content with {} hours age difference",
                        time_diff / 3600
                    ),
                });
            }
        }

        None
    }

    /// Check for domain mismatch
    fn check_domain_mismatch(&self, a: &MemoryNode, b: &MemoryNode) -> Option<Conflict> {
        let domain_a = a.metadata.get("domain");
        let domain_b = b.metadata.get("domain");

        match (domain_a, domain_b) {
            (Some(da), Some(db)) if da != db => {
                let similarity = self.cosine_similarity(&a.embedding, &b.embedding);
                if similarity > 0.6 {
                    return Some(Conflict {
                        conflict_type: ConflictType::DomainMismatch,
                        severity: ConflictSeverity::Low,
                        item_a: self.node_to_item(a),
                        item_b: self.node_to_item(b),
                        confidence: 0.7,
                        explanation: format!(
                            "Domain mismatch: {} vs {}",
                            da.as_str().unwrap_or("unknown"),
                            db.as_str().unwrap_or("unknown")
                        ),
                    });
                }
            }
            _ => {}
        }

        None
    }

    /// Check for perspective conflict via priors
    fn check_perspective_conflict(&self, a: &MemoryNode, b: &MemoryNode) -> Option<Conflict> {
        let priors_a = &a.priors_vibe_check;
        let priors_b = &b.priors_vibe_check;

        let priors_similarity = self.cosine_similarity_128(
            &priors_a.vector,
            &priors_b.vector
        );

        // Low priors similarity + high content similarity = perspective conflict
        let content_similarity = self.cosine_similarity(&a.embedding, &b.embedding);

        if priors_similarity < 0.5 && content_similarity > 0.7 {
            return Some(Conflict {
                conflict_type: ConflictType::PerspectiveConflict,
                severity: ConflictSeverity::Medium,
                item_a: self.node_to_item(a),
                item_b: self.node_to_item(b),
                confidence: content_similarity * (1.0 - priors_similarity),
                explanation: format!(
                    "Perspective conflict: similar content (sim={:.2}) from \
                     different viewpoints (priors_sim={:.2})",
                    content_similarity, priors_similarity
                ),
            });
        }

        None
    }

    /// Generate resolution suggestions
    fn generate_resolutions(&self, conflicts: &[Conflict]) -> Vec<ConflictResolution> {
        let mut resolutions = Vec::new();

        for conflict in conflicts {
            let resolution = match conflict.conflict_type {
                ConflictType::Contradiction => ConflictResolution {
                    action: ResolutionAction::AskUser {
                        question: format!(
                            "Contradiction detected: '{}' vs '{}'. Which is correct?",
                            truncate(&conflict.item_a.content, 50),
                            truncate(&conflict.item_b.content, 50)
                        ),
                    },
                    preferred_item: None,
                    reason: "Direct contradiction requires user resolution".to_string(),
                    confidence: 0.9,
                },

                ConflictType::TemporalInconsistency => ConflictResolution {
                    action: ResolutionAction::PreferNewer,
                    preferred_item: Some(
                        if conflict.item_a.timestamp > conflict.item_b.timestamp {
                            conflict.item_a.clone()
                        } else {
                            conflict.item_b.clone()
                        }
                    ),
                    reason: "Newer information likely more accurate".to_string(),
                    confidence: 0.7,
                },

                ConflictType::DomainMismatch => ConflictResolution {
                    action: ResolutionAction::MergeWithQualification,
                    preferred_item: None,
                    reason: format!(
                        "Both valid in their domains: {} and {}",
                        conflict.item_a.domain.as_deref().unwrap_or("unknown"),
                        conflict.item_b.domain.as_deref().unwrap_or("unknown")
                    ),
                    confidence: 0.8,
                },

                ConflictType::PerspectiveConflict => ConflictResolution {
                    action: ResolutionAction::CreateRelationalEdge,
                    preferred_item: None,
                    reason: "Different perspectives can coexist".to_string(),
                    confidence: 0.75,
                },

                _ => ConflictResolution {
                    action: ResolutionAction::MarkUncertain,
                    preferred_item: None,
                    reason: "Cannot automatically resolve".to_string(),
                    confidence: 0.5,
                },
            };

            resolutions.push(resolution);
        }

        resolutions
    }

    fn node_to_item(&self, node: &MemoryNode) -> ConflictItem {
        ConflictItem {
            node_id: Some(node.id.to_string()),
            content: node.content.clone(),
            source: node.metadata.get("source")
                .and_then(|v| v.as_str())
                .unwrap_or("unknown")
                .to_string(),
            timestamp: Some(node.timestamp),
            agent_id: node.agent_id.clone(),
            domain: node.metadata.get("domain")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
        }
    }

    fn cosine_similarity(&self, a: &[f32], b: &[f32]) -> f32 {
        let dot: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
        let norm_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();
        let norm_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();

        if norm_a > 0.0 && norm_b > 0.0 {
            dot / (norm_a * norm_b)
        } else {
            0.0
        }
    }

    fn cosine_similarity_128(&self, a: &[f32; 128], b: &[f32; 128]) -> f32 {
        self.cosine_similarity(a.as_slice(), b.as_slice())
    }
}

fn truncate(s: &str, max_len: usize) -> &str {
    if s.len() <= max_len {
        s
    } else {
        &s[..max_len]
    }
}
```

## Testing Requirements

1. **Contradiction Tests**
   - Detect "X is true" vs "X is not true"
   - Detect "enabled" vs "disabled"
   - High similarity required for contradiction

2. **Temporal Tests**
   - Detect outdated vs current information
   - Time threshold configurable
   - Prefer newer information in resolution

3. **Domain Tests**
   - Detect Python advice for Java question
   - Low severity for domain mismatches
   - Merge with qualification resolution

4. **Perspective Tests**
   - Detect different agent viewpoints
   - Use priors similarity
   - Create relational edge resolution

5. **Integration Tests**
   - ConflictAlert in inject_context response
   - Resolutions generated correctly
   - Serialization to JSON

---

*Task specification generated for Module 05 - UTL Integration*
