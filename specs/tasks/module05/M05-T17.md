# M05-T17: Implement PhaseOscillator for Phase Synchronization

```yaml
metadata:
  id: "M05-T17"
  title: "Implement PhaseOscillator for Phase Synchronization"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "logic"
  priority: "high"
  estimated_hours: 2
  created: "2026-01-04"
  updated: "2026-01-04"
  status: "COMPLETE"
  dependencies:
    - M05-T32  # PhaseConfig struct
  verified_by: "cargo test -p context-graph-utl --lib -- phase::oscillator"
  test_count: 24
  spec_refs:
    - "constitution.yaml lines 148-167 (UTL formula: L = f((ΔS × ΔC) · wₑ · cos φ))"
    - "constitution.yaml lines 189-194 (L4 Learning layer: 100Hz frequency)"
    - "learntheory.md (φ = phase difference between ΔS and ΔC, range 0→π)"
```

---

## STATUS: COMPLETE ✓

**This task is fully implemented and verified.**

```bash
# Verification command
cargo test -p context-graph-utl --lib -- phase::oscillator 2>&1 | grep -E "(test|passed|failed)"
# Expected: test result: ok. 24 passed; 0 failed;
```

---

## What Exists

### File Location
```
crates/context-graph-utl/src/phase/oscillator.rs  (727 lines)
crates/context-graph-utl/src/phase/mod.rs         (45 lines)
crates/context-graph-utl/src/config.rs            (PhaseConfig at lines 436-466)
```

### Implemented Structs

**PhaseOscillator** (`oscillator.rs:45-78`):
```rust
pub struct PhaseOscillator {
    current_phase: f32,       // [0, π] radians
    frequency_hz: f32,        // Oscillation frequency (default: 100Hz)
    angular_velocity: f32,    // π * frequency_hz
    min_phase: f32,           // 0.0
    max_phase: f32,           // π
    coupling_strength: f32,   // [0, 1] for phase synchronization
    adaptive: bool,           // Enable adaptive adjustment
    adaptation_rate: f32,     // Rate of adaptive adjustment
    direction: f32,           // 1.0 or -1.0 (oscillation direction)
    target_phase: Option<f32>,// For adaptive synchronization
    elapsed_total: f32,       // Total elapsed time
}
```

**PhaseConfig** (`config.rs:436-466`):
```rust
pub struct PhaseConfig {
    pub min_phase: f32,        // 0.0
    pub max_phase: f32,        // π
    pub default_phase: f32,    // 0.0
    pub frequency_hz: f32,     // 100.0 (L4 reference)
    pub coupling_strength: f32,// 0.5
    pub adaptive: bool,        // true
    pub adaptation_rate: f32,  // 0.1
    pub sync_threshold: f32,   // 0.8
}
```

### Key Methods

| Method | Purpose | Returns |
|--------|---------|---------|
| `new(&PhaseConfig)` | Create from config | `PhaseOscillator` |
| `synchronized(&PhaseConfig)` | Create at φ=0 (cos=1) | `PhaseOscillator` |
| `anti_phase(&PhaseConfig)` | Create at φ=π (cos=-1) | `PhaseOscillator` |
| `update(Duration)` | Advance phase by elapsed time | `()` |
| `phase()` | Get current φ in [0, π] | `f32` |
| `cos_phase()` | Get cos(φ) for UTL formula | `f32` in [-1, 1] |
| `sin_phase()` | Get sin(φ) | `f32` in [0, 1] |
| `set_phase(f32)` | Set phase directly (clamped) | `()` |
| `reset()` | Reset to φ=0 | `()` |
| `set_frequency(f32)` | Change oscillation frequency | `Result<(), UtlError>` |
| `is_synchronized(threshold)` | Check if φ < threshold | `bool` |
| `is_anti_phase(threshold)` | Check if φ near π | `bool` |
| `normalized_phase()` | Get φ in [0, 1] | `f32` |
| `compute_coupling(&PhaseOscillator)` | Phase alignment with another | `f32` |

---

## UTL Formula Context

The phase oscillator implements the `cos φ` term in the UTL equation:

```
L = f((ΔS × ΔC) · wₑ · cos φ)
```

**Phase Semantics:**
- `φ = 0` → `cos(φ) = 1.0` → Fully synchronized (maximum learning)
- `φ = π/2` → `cos(φ) = 0.0` → Orthogonal (neutral)
- `φ = π` → `cos(φ) = -1.0` → Anti-phase (learning inhibition)

**Constitution Reference:**
- Phase range: `[0, π]` (constitution.yaml line 157)
- L4 Learning layer operates at 100Hz (constitution.yaml line 193)
- Phase modulates learning magnitude based on synchronization

---

## How Phase Integrates with UTL

The `compute_learning_magnitude()` function in `lib.rs:99-102` takes `phi` as a raw `f32` parameter:

```rust
pub fn compute_learning_magnitude(delta_s: f32, delta_c: f32, w_e: f32, phi: f32) -> f32 {
    let raw = (delta_s * delta_c) * w_e * phi.cos();
    raw.clamp(0.0, 1.0)
}
```

**Usage Pattern:**
```rust
let oscillator = PhaseOscillator::new(&config);
// ... oscillator.update(elapsed) to advance phase ...
let phi = oscillator.phase();  // Get current phase angle
let learning = compute_learning_magnitude(delta_s, delta_c, w_e, phi);
```

The PhaseOscillator provides the `phi` value; `compute_learning_magnitude()` calls `phi.cos()` directly.

---

## Test Coverage (24 Tests)

All tests pass in `oscillator.rs:423-727`:

```
test_oscillator_creation          - Verify new() sets correct defaults
test_synchronized_oscillator      - Verify φ=0, cos=1
test_anti_phase_oscillator        - Verify φ=π, cos=-1
test_with_initial_phase_valid     - Accept valid initial phase
test_with_initial_phase_invalid   - Reject out-of-range phase
test_update_changes_phase         - Phase advances with time
test_phase_stays_in_bounds        - 1000 iterations stay in [0, π]
test_cos_phase_range              - cos(φ) stays in [-1, 1]
test_sin_phase_range              - sin(φ) stays in [0, 1]
test_set_phase                    - Direct phase setting with clamping
test_reset                        - Reset clears state
test_target_phase                 - Adaptive target setting
test_set_frequency_valid          - Positive frequency accepted
test_set_frequency_invalid        - Zero/negative frequency rejected
test_coupling_strength            - Coupling clamped to [0, 1]
test_is_synchronized              - Threshold detection at φ≈0
test_is_anti_phase                - Threshold detection at φ≈π
test_normalized_phase             - Phase normalization to [0, 1]
test_compute_coupling             - Phase alignment calculation
test_direction                    - Oscillation direction tracking
test_elapsed_total                - Time accumulation
test_default_oscillator           - Default trait implementation
test_oscillation_reverses_at_boundaries - Direction reversal at limits
test_cos_phi_at_known_phases      - cos(0)=1, cos(π/2)=0, cos(π)=-1
```

---

## Edge Cases Tested

1. **Phase clamping**: Values outside [0, π] are clamped
2. **Frequency validation**: Zero/negative frequencies error
3. **Boundary reversal**: Direction flips at 0 and π
4. **High-frequency oscillation**: Rapid updates stay in bounds
5. **Coupling calculation**: Same phase = 1.0, opposite = 0.0

---

## Related Files

| File | Purpose |
|------|---------|
| `phase/consolidation.rs` | NREM/REM/Wake phase detection (separate concern) |
| `phase/mod.rs` | Re-exports PhaseOscillator and ConsolidationPhase |
| `config.rs` | PhaseConfig definition |
| `error.rs` | UtlError::PhaseError variant |
| `lib.rs:99` | `compute_learning_magnitude()` uses phi.cos() |

---

## Full State Verification Protocol

### Source of Truth
The phase state is stored in `PhaseOscillator.current_phase: f32`.

### Verification Commands

```bash
# 1. Run all oscillator tests
cargo test -p context-graph-utl --lib -- phase::oscillator 2>&1 | grep -E "(test|passed|failed)"

# 2. Verify test count
cargo test -p context-graph-utl --lib -- phase::oscillator 2>&1 | grep "24 passed"

# 3. Verify module compiles without warnings
cargo check -p context-graph-utl 2>&1 | grep -E "(error|warning)" || echo "No errors"
```

### Manual Edge Case Audit

**Edge Case 1: Empty/Zero Input**
```rust
// Verify in test: test_set_phase
oscillator.set_phase(-1.0);
assert_eq!(oscillator.phase(), 0.0);  // Clamped to min
```

**Edge Case 2: Maximum Limit**
```rust
// Verify in test: test_set_phase
oscillator.set_phase(5.0);
assert_eq!(oscillator.phase(), PI);  // Clamped to max
```

**Edge Case 3: Invalid Frequency**
```rust
// Verify in test: test_set_frequency_invalid
assert!(oscillator.set_frequency(0.0).is_err());
assert!(oscillator.set_frequency(-10.0).is_err());
```

### Evidence of Success
```bash
$ cargo test -p context-graph-utl --lib -- phase::oscillator 2>&1 | tail -3
test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 345 filtered out
```

---

## Sherlock Holmes Verification Checklist

- [ ] Run `cargo test -p context-graph-utl --lib -- phase::oscillator`
- [ ] Verify 24 tests pass with 0 failures
- [ ] Confirm `PhaseOscillator` struct exists at `oscillator.rs:45`
- [ ] Confirm `PhaseConfig` struct exists at `config.rs:436`
- [ ] Verify `cos_phase()` returns values in [-1, 1]
- [ ] Verify phase boundaries are enforced (no NaN/Infinity)
- [ ] Confirm `lib.rs:99` uses `phi.cos()` for learning magnitude

---

## NO Backwards Compatibility

- **NO fallbacks**: Invalid inputs error immediately
- **NO mock data**: Tests use real PhaseConfig and PhaseOscillator
- **NO workarounds**: Errors propagate via `UtlError::PhaseError`

If something fails, the error message indicates exactly what failed:
```rust
Err(UtlError::PhaseError(format!(
    "Initial phase {} out of range [{}, {}]",
    initial_phase, config.min_phase, config.max_phase
)))
```

---

*Task complete. Last verified: 2026-01-04*
*Sherlock Holmes audit: PASSED (24 tests, accurate documentation)*
*Git reference: f521803 feat(utl): complete context-graph-utl crate with 453 tests passing*
