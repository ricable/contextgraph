# M05-T12: Define CoherenceEntry and Rolling Window

| Field | Value |
|-------|-------|
| **Task ID** | M05-T12 |
| **Module** | context-graph-utl |
| **Status** | **NEEDS IMPLEMENTATION** |
| **Priority** | P1 (High) |
| **Depends On** | M05-T03 (CoherenceConfig) - COMPLETE |
| **Estimated Hours** | 2.5 |
| **Constitution Refs** | constitution.yaml:148-167 (UTL), contextprd.md Section 2.1 |

---

## CRITICAL: Task Status Discrepancy

**The _index.md claims this task is COMPLETE but the specification was NEVER implemented.**

### What Exists (Actual Implementation)
Location: `crates/context-graph-utl/src/coherence/window.rs`

```rust
// ACTUAL exports:
pub use window::{RollingWindow, WindowConfig};
pub use tracker::CoherenceTracker;
```

- `RollingWindow<T>` - Generic rolling window, no node_id, no importance, no timestamp
- `WindowConfig` - Just size and min_samples config
- `CoherenceTracker` - Uses `RollingWindow<Vec<f32>>` internally

### What This Task Specifies (NOT IMPLEMENTED)
- `CoherenceEntry` struct with: `node_id: Uuid`, `embedding: Vec<f32>`, `timestamp: DateTime<Utc>`, `importance: f32`
- `CoherenceWindow` struct that stores `CoherenceEntry` items with eviction

**The task specification was never implemented. A generic `RollingWindow<T>` was created instead which lacks the UTL-specific fields.**

---

## Executive Summary

Implement `CoherenceEntry` and `CoherenceWindow` structs for tracking recent memory entries with metadata (node_id, importance, timestamp) used in coherence computation. The current `RollingWindow<T>` is too generic and lacks UTL-specific tracking.

**Why this matters:** The constitution specifies that coherence tracking needs importance-weighted semantic similarity. Without `importance` on entries, the system cannot properly weight recent memories by their UTL-computed importance scores.

---

## Implementation Requirements

### File Location

**Primary File:** `crates/context-graph-utl/src/coherence/entry.rs` (NEW FILE)

**Modify:** `crates/context-graph-utl/src/coherence/mod.rs` to add exports

### Dependencies (Already in Cargo.toml)

```toml
# crates/context-graph-utl/Cargo.toml line 18-19
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.6", features = ["v4", "serde"] }
```

### 1. CoherenceEntry Struct

```rust
// File: crates/context-graph-utl/src/coherence/entry.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// An entry in the coherence tracking window.
///
/// Each entry represents a recently processed memory node and its embedding,
/// used for computing semantic coherence of new content. The importance field
/// enables weighted coherence calculations per constitution.yaml:148-167.
///
/// # Constitution Reference
/// - UTL formula: `L = f((ΔS × ΔC) · wₑ · cos φ)`
/// - Coherence (ΔC) in range [0,1]
/// - importance used for weighting in coherence computation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CoherenceEntry {
    /// Unique identifier of the memory node this embedding came from
    node_id: Uuid,

    /// Embedding vector of the content (typically 1536 dimensions per constitution)
    embedding: Vec<f32>,

    /// Timestamp when this entry was added to the window
    timestamp: DateTime<Utc>,

    /// Importance score from UTL computation [0, 1], used for weighting
    importance: f32,
}

impl CoherenceEntry {
    /// Create a new coherence entry with current timestamp.
    ///
    /// # Arguments
    /// * `node_id` - UUID of the source memory node
    /// * `embedding` - Embedding vector (validate non-empty)
    /// * `importance` - Importance score, clamped to [0, 1]
    ///
    /// # Errors
    /// Returns error if embedding is empty or contains NaN/Inf
    pub fn new(node_id: Uuid, embedding: Vec<f32>, importance: f32) -> Result<Self, CoherenceEntryError> {
        Self::validate_embedding(&embedding)?;
        Ok(Self {
            node_id,
            embedding,
            timestamp: Utc::now(),
            importance: importance.clamp(0.0, 1.0),
        })
    }

    /// Create entry with explicit timestamp (for testing/restoration).
    pub fn with_timestamp(
        node_id: Uuid,
        embedding: Vec<f32>,
        importance: f32,
        timestamp: DateTime<Utc>,
    ) -> Result<Self, CoherenceEntryError> {
        Self::validate_embedding(&embedding)?;
        Ok(Self {
            node_id,
            embedding,
            timestamp,
            importance: importance.clamp(0.0, 1.0),
        })
    }

    fn validate_embedding(embedding: &[f32]) -> Result<(), CoherenceEntryError> {
        if embedding.is_empty() {
            return Err(CoherenceEntryError::EmptyEmbedding);
        }
        for (i, &val) in embedding.iter().enumerate() {
            if val.is_nan() {
                return Err(CoherenceEntryError::NanValue { index: i });
            }
            if val.is_infinite() {
                return Err(CoherenceEntryError::InfiniteValue { index: i });
            }
        }
        Ok(())
    }

    #[inline]
    pub fn node_id(&self) -> Uuid { self.node_id }

    #[inline]
    pub fn embedding(&self) -> &[f32] { &self.embedding }

    #[inline]
    pub fn dimension(&self) -> usize { self.embedding.len() }

    #[inline]
    pub fn timestamp(&self) -> DateTime<Utc> { self.timestamp }

    #[inline]
    pub fn importance(&self) -> f32 { self.importance }

    /// Calculate age in seconds from now.
    pub fn age_seconds(&self) -> i64 {
        (Utc::now() - self.timestamp).num_seconds()
    }
}

/// Errors that can occur when creating a CoherenceEntry
#[derive(Debug, Clone, thiserror::Error)]
pub enum CoherenceEntryError {
    #[error("embedding vector cannot be empty")]
    EmptyEmbedding,

    #[error("embedding contains NaN at index {index}")]
    NanValue { index: usize },

    #[error("embedding contains Infinity at index {index}")]
    InfiniteValue { index: usize },
}
```

### 2. CoherenceWindow Struct

```rust
// Continue in: crates/context-graph-utl/src/coherence/entry.rs

use std::collections::VecDeque;

/// A fixed-capacity rolling window of CoherenceEntry items.
///
/// Maintains FIFO queue with automatic eviction of oldest entry when full.
/// Provides importance-weighted operations for UTL coherence computation.
///
/// # Constitution Reference
/// - Window supports coherence_recovery < 10s per perf targets
/// - Entries weighted by importance for semantic coherence
#[derive(Debug, Clone)]
pub struct CoherenceWindow {
    entries: VecDeque<CoherenceEntry>,
    capacity: usize,
}

impl CoherenceWindow {
    /// Create new window with specified capacity.
    ///
    /// # Panics
    /// Panics if capacity is 0 (fail fast per requirements).
    pub fn new(capacity: usize) -> Self {
        assert!(capacity > 0, "CoherenceWindow capacity must be > 0");
        Self {
            entries: VecDeque::with_capacity(capacity),
            capacity,
        }
    }

    /// Add entry, returning evicted entry if at capacity.
    pub fn push(&mut self, entry: CoherenceEntry) -> Option<CoherenceEntry> {
        let evicted = if self.entries.len() >= self.capacity {
            self.entries.pop_front()
        } else {
            None
        };
        self.entries.push_back(entry);
        evicted
    }

    /// Convenience: create and add entry in one call.
    pub fn add(
        &mut self,
        node_id: Uuid,
        embedding: Vec<f32>,
        importance: f32,
    ) -> Result<Option<CoherenceEntry>, CoherenceEntryError> {
        let entry = CoherenceEntry::new(node_id, embedding, importance)?;
        Ok(self.push(entry))
    }

    #[inline]
    pub fn len(&self) -> usize { self.entries.len() }

    #[inline]
    pub fn is_empty(&self) -> bool { self.entries.is_empty() }

    #[inline]
    pub fn is_full(&self) -> bool { self.entries.len() >= self.capacity }

    #[inline]
    pub fn capacity(&self) -> usize { self.capacity }

    pub fn clear(&mut self) { self.entries.clear(); }

    pub fn iter(&self) -> impl Iterator<Item = &CoherenceEntry> {
        self.entries.iter()
    }

    pub fn iter_rev(&self) -> impl Iterator<Item = &CoherenceEntry> {
        self.entries.iter().rev()
    }

    /// Get all embeddings as slices (for batch similarity computation).
    pub fn embeddings(&self) -> Vec<&[f32]> {
        self.entries.iter().map(|e| e.embedding()).collect()
    }

    /// Get embeddings with their importance weights.
    pub fn embeddings_with_importance(&self) -> Vec<(&[f32], f32)> {
        self.entries.iter().map(|e| (e.embedding(), e.importance())).collect()
    }

    pub fn newest(&self) -> Option<&CoherenceEntry> { self.entries.back() }
    pub fn oldest(&self) -> Option<&CoherenceEntry> { self.entries.front() }
    pub fn get(&self, index: usize) -> Option<&CoherenceEntry> { self.entries.get(index) }

    /// Remove entries older than max_age_seconds.
    /// Returns count of removed entries.
    pub fn evict_older_than(&mut self, max_age_seconds: i64) -> usize {
        let cutoff = Utc::now() - chrono::Duration::seconds(max_age_seconds);
        let before = self.entries.len();
        self.entries.retain(|e| e.timestamp >= cutoff);
        before - self.entries.len()
    }

    /// Calculate importance-weighted average importance.
    pub fn average_importance(&self) -> f32 {
        if self.entries.is_empty() { return 0.0; }
        let sum: f32 = self.entries.iter().map(|e| e.importance).sum();
        sum / self.entries.len() as f32
    }

    /// Find entry by node ID.
    pub fn find_by_id(&self, node_id: Uuid) -> Option<&CoherenceEntry> {
        self.entries.iter().find(|e| e.node_id == node_id)
    }

    /// Check if window contains entry with given node ID.
    pub fn contains_id(&self, node_id: Uuid) -> bool {
        self.entries.iter().any(|e| e.node_id == node_id)
    }
}

impl Default for CoherenceWindow {
    fn default() -> Self { Self::new(100) }
}

impl IntoIterator for CoherenceWindow {
    type Item = CoherenceEntry;
    type IntoIter = std::collections::vec_deque::IntoIter<CoherenceEntry>;
    fn into_iter(self) -> Self::IntoIter { self.entries.into_iter() }
}

impl<'a> IntoIterator for &'a CoherenceWindow {
    type Item = &'a CoherenceEntry;
    type IntoIter = std::collections::vec_deque::Iter<'a, CoherenceEntry>;
    fn into_iter(self) -> Self::IntoIter { self.entries.iter() }
}
```

### 3. Module Export Updates

**Modify:** `crates/context-graph-utl/src/coherence/mod.rs`

Add after line 36:
```rust
mod entry;
```

Add to exports after line 40:
```rust
pub use entry::{CoherenceEntry, CoherenceEntryError, CoherenceWindow};
```

---

## Test Cases

**File:** `crates/context-graph-utl/src/coherence/entry.rs` (co-located tests)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;

    // ========== CoherenceEntry Tests ==========

    #[test]
    fn test_entry_new_valid() {
        let id = Uuid::new_v4();
        let embedding = vec![0.1, 0.2, 0.3];
        let result = CoherenceEntry::new(id, embedding.clone(), 0.75);

        assert!(result.is_ok());
        let entry = result.unwrap();
        assert_eq!(entry.node_id(), id);
        assert_eq!(entry.embedding(), &embedding[..]);
        assert_eq!(entry.importance(), 0.75);
        assert!(entry.age_seconds() >= 0);
        assert_eq!(entry.dimension(), 3);
    }

    #[test]
    fn test_entry_importance_clamped_high() {
        let entry = CoherenceEntry::new(Uuid::new_v4(), vec![0.1], 1.5).unwrap();
        assert_eq!(entry.importance(), 1.0);
    }

    #[test]
    fn test_entry_importance_clamped_low() {
        let entry = CoherenceEntry::new(Uuid::new_v4(), vec![0.1], -0.5).unwrap();
        assert_eq!(entry.importance(), 0.0);
    }

    #[test]
    fn test_entry_empty_embedding_error() {
        let result = CoherenceEntry::new(Uuid::new_v4(), vec![], 0.5);
        assert!(matches!(result, Err(CoherenceEntryError::EmptyEmbedding)));
    }

    #[test]
    fn test_entry_nan_embedding_error() {
        let result = CoherenceEntry::new(Uuid::new_v4(), vec![0.1, f32::NAN, 0.3], 0.5);
        assert!(matches!(result, Err(CoherenceEntryError::NanValue { index: 1 })));
    }

    #[test]
    fn test_entry_infinite_embedding_error() {
        let result = CoherenceEntry::new(Uuid::new_v4(), vec![f32::INFINITY, 0.2], 0.5);
        assert!(matches!(result, Err(CoherenceEntryError::InfiniteValue { index: 0 })));
    }

    #[test]
    fn test_entry_with_timestamp() {
        let ts = Utc::now() - Duration::seconds(100);
        let entry = CoherenceEntry::with_timestamp(
            Uuid::new_v4(), vec![0.1], 0.5, ts
        ).unwrap();

        assert_eq!(entry.timestamp(), ts);
        assert!(entry.age_seconds() >= 100);
    }

    // ========== CoherenceWindow Tests ==========

    #[test]
    fn test_window_new() {
        let window = CoherenceWindow::new(50);
        assert_eq!(window.capacity(), 50);
        assert!(window.is_empty());
        assert_eq!(window.len(), 0);
    }

    #[test]
    fn test_window_default() {
        let window = CoherenceWindow::default();
        assert_eq!(window.capacity(), 100);
    }

    #[test]
    #[should_panic(expected = "capacity must be > 0")]
    fn test_window_zero_capacity_panics() {
        let _ = CoherenceWindow::new(0);
    }

    #[test]
    fn test_window_push_no_eviction() {
        let mut window = CoherenceWindow::new(10);
        let entry = CoherenceEntry::new(Uuid::new_v4(), vec![0.5], 0.5).unwrap();

        let evicted = window.push(entry);
        assert!(evicted.is_none());
        assert_eq!(window.len(), 1);
    }

    #[test]
    fn test_window_push_evicts_at_capacity() {
        let mut window = CoherenceWindow::new(3);

        for i in 0..3 {
            window.add(Uuid::new_v4(), vec![i as f32], 0.5).unwrap();
        }
        assert!(window.is_full());

        // This should evict the first entry (embedding[0] = 0.0)
        let evicted = window.add(Uuid::new_v4(), vec![99.0], 0.5).unwrap();

        assert!(evicted.is_some());
        assert_eq!(evicted.unwrap().embedding()[0], 0.0);
        assert_eq!(window.len(), 3);
    }

    #[test]
    fn test_window_fifo_order() {
        let mut window = CoherenceWindow::new(3);

        for i in 0..3 {
            window.add(Uuid::new_v4(), vec![i as f32], 0.5).unwrap();
        }

        assert_eq!(window.oldest().unwrap().embedding()[0], 0.0);
        assert_eq!(window.newest().unwrap().embedding()[0], 2.0);
    }

    #[test]
    fn test_window_embeddings() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![1.0, 2.0], 0.5).unwrap();
        window.add(Uuid::new_v4(), vec![3.0, 4.0], 0.5).unwrap();

        let embeddings = window.embeddings();
        assert_eq!(embeddings.len(), 2);
        assert_eq!(embeddings[0], &[1.0, 2.0]);
        assert_eq!(embeddings[1], &[3.0, 4.0]);
    }

    #[test]
    fn test_window_embeddings_with_importance() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![1.0], 0.3).unwrap();
        window.add(Uuid::new_v4(), vec![2.0], 0.7).unwrap();

        let weighted = window.embeddings_with_importance();
        assert_eq!(weighted.len(), 2);
        assert_eq!(weighted[0].1, 0.3);
        assert_eq!(weighted[1].1, 0.7);
    }

    #[test]
    fn test_window_find_by_id() {
        let mut window = CoherenceWindow::new(10);
        let id = Uuid::new_v4();

        window.add(id, vec![1.0], 0.5).unwrap();
        window.add(Uuid::new_v4(), vec![2.0], 0.5).unwrap();

        let found = window.find_by_id(id);
        assert!(found.is_some());
        assert_eq!(found.unwrap().embedding()[0], 1.0);

        assert!(window.find_by_id(Uuid::new_v4()).is_none());
    }

    #[test]
    fn test_window_contains_id() {
        let mut window = CoherenceWindow::new(10);
        let id = Uuid::new_v4();

        window.add(id, vec![1.0], 0.5).unwrap();

        assert!(window.contains_id(id));
        assert!(!window.contains_id(Uuid::new_v4()));
    }

    #[test]
    fn test_window_clear() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![1.0], 0.5).unwrap();
        window.add(Uuid::new_v4(), vec![2.0], 0.5).unwrap();

        window.clear();
        assert!(window.is_empty());
    }

    #[test]
    fn test_window_evict_older_than() {
        let mut window = CoherenceWindow::new(10);

        // Add old entry
        let old_ts = Utc::now() - Duration::seconds(200);
        let old_entry = CoherenceEntry::with_timestamp(
            Uuid::new_v4(), vec![1.0], 0.5, old_ts
        ).unwrap();
        window.push(old_entry);

        // Add recent entry
        window.add(Uuid::new_v4(), vec![2.0], 0.5).unwrap();

        let removed = window.evict_older_than(100);

        assert_eq!(removed, 1);
        assert_eq!(window.len(), 1);
        assert_eq!(window.newest().unwrap().embedding()[0], 2.0);
    }

    #[test]
    fn test_window_average_importance() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![0.1], 0.2).unwrap();
        window.add(Uuid::new_v4(), vec![0.1], 0.4).unwrap();
        window.add(Uuid::new_v4(), vec![0.1], 0.6).unwrap();

        let avg = window.average_importance();
        assert!((avg - 0.4).abs() < 1e-6);
    }

    #[test]
    fn test_window_average_importance_empty() {
        let window = CoherenceWindow::new(10);
        assert_eq!(window.average_importance(), 0.0);
    }

    #[test]
    fn test_window_iter() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![0.1], 0.1).unwrap();
        window.add(Uuid::new_v4(), vec![0.1], 0.2).unwrap();

        let importances: Vec<f32> = window.iter().map(|e| e.importance()).collect();
        assert_eq!(importances, vec![0.1, 0.2]);
    }

    #[test]
    fn test_window_iter_rev() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![0.1], 0.1).unwrap();
        window.add(Uuid::new_v4(), vec![0.1], 0.2).unwrap();

        let importances: Vec<f32> = window.iter_rev().map(|e| e.importance()).collect();
        assert_eq!(importances, vec![0.2, 0.1]);
    }

    #[test]
    fn test_window_into_iter() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![0.1], 0.1).unwrap();
        window.add(Uuid::new_v4(), vec![0.1], 0.2).unwrap();

        let entries: Vec<CoherenceEntry> = window.into_iter().collect();
        assert_eq!(entries.len(), 2);
    }
}
```

---

## Full State Verification Requirements

After implementing the logic, you MUST perform Full State Verification:

### 1. Source of Truth Definition
- **Primary**: Tests pass with `cargo test -p context-graph-utl --lib`
- **Secondary**: Module exports visible via `use context_graph_utl::coherence::{CoherenceEntry, CoherenceWindow}`
- **Tertiary**: No compilation errors, no warnings

### 2. Execute & Inspect
Run the following and capture output:

```bash
# Build and test
cargo test -p context-graph-utl coherence::entry --lib -- --nocapture 2>&1 | tee /tmp/m05-t12-test.log

# Verify exports work
echo 'use context_graph_utl::coherence::{CoherenceEntry, CoherenceWindow};' | cargo check -p context-graph-utl 2>&1

# Count new tests
grep -c "^    fn test_" crates/context-graph-utl/src/coherence/entry.rs
```

### 3. Boundary & Edge Case Audit

**You MUST manually test these 3 edge cases and print before/after state:**

#### Edge Case 1: Empty Embedding
```rust
// BEFORE: CoherenceEntry::new(Uuid::new_v4(), vec![], 0.5)
// Expected: Err(CoherenceEntryError::EmptyEmbedding)
// AFTER: Print error variant received
```

#### Edge Case 2: Window at Capacity Eviction
```rust
// BEFORE: window.len() == capacity, window.oldest().embedding()[0] == X
// ACTION: window.push(new_entry)
// AFTER: window.len() == capacity, evicted.embedding()[0] == X, oldest changed
```

#### Edge Case 3: NaN in Embedding
```rust
// BEFORE: CoherenceEntry::new(Uuid::new_v4(), vec![0.1, f32::NAN], 0.5)
// Expected: Err(CoherenceEntryError::NanValue { index: 1 })
// AFTER: Print error variant, confirm index is correct
```

### 4. Evidence of Success

Provide a log showing:
```
=== M05-T12 Verification Log ===
Timestamp: [actual timestamp]
Test Results: X passed, 0 failed
New Types Exported: CoherenceEntry, CoherenceEntryError, CoherenceWindow
Edge Case 1 (Empty): [PASS/FAIL] - [actual error]
Edge Case 2 (Eviction): [PASS/FAIL] - evicted entry had embedding[0]=[value]
Edge Case 3 (NaN): [PASS/FAIL] - error index=[value]
Total Tests in entry.rs: [count]
```

---

## Acceptance Criteria

### Functional Requirements
- [ ] `CoherenceEntry` struct with 4 fields (node_id, embedding, timestamp, importance)
- [ ] `CoherenceEntry::new()` validates embedding (non-empty, no NaN/Inf)
- [ ] `CoherenceEntry::new()` clamps importance to [0, 1]
- [ ] `CoherenceEntry::with_timestamp()` allows custom timestamp
- [ ] `CoherenceEntryError` enum with 3 variants (EmptyEmbedding, NanValue, InfiniteValue)
- [ ] `CoherenceWindow` uses `VecDeque<CoherenceEntry>`
- [ ] `CoherenceWindow::push()` returns evicted entry when at capacity
- [ ] `CoherenceWindow::add()` returns `Result` for validation errors
- [ ] `CoherenceWindow::evict_older_than()` removes stale entries
- [ ] `embeddings_with_importance()` returns embedding + importance pairs
- [ ] All iterator traits implemented

### Performance Requirements
- [ ] Push operation is O(1) amortized
- [ ] Eviction is O(1) (VecDeque front removal)
- [ ] No heap allocations in accessor methods

### Code Quality Requirements
- [ ] `Clone`, `Debug` implemented for all types
- [ ] `Serialize`, `Deserialize` for `CoherenceEntry`
- [ ] `Default` for `CoherenceWindow`
- [ ] NO `unwrap()` in production code
- [ ] All errors use `thiserror` for derivation
- [ ] Comprehensive rustdoc on all public items

---

## Integration Notes

### Upstream Dependencies (VERIFIED COMPLETE)
- M05-T03: `CoherenceConfig` exists at `src/config.rs:229-321`

### Downstream Consumers
- M05-T13: `CoherenceTracker` should be updated to use `CoherenceWindow` for importance-weighted coherence
- M05-T14: Structural coherence can query entries by node_id

### Breaking Change Notice
The existing `RollingWindow<T>` remains for backward compatibility. The new `CoherenceWindow` is purpose-built for UTL coherence tracking with importance weighting.

---

## FINAL VERIFICATION STEP

After completing ALL implementation:

**You MUST use the `sherlock-holmes` subagent to verify the ENTIRE task is complete.**

The sherlock-holmes agent will:
1. Verify all files exist at specified locations
2. Verify all tests pass
3. Verify exports are accessible
4. Identify any issues or discrepancies
5. Confirm acceptance criteria are met

**Fix any issues identified by sherlock-holmes before marking task complete.**

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-04 | AI Agent | Initial atomic task creation |
| 2026-01-04 | AI Agent | **AUDIT**: Discovered task was never implemented. Updated to reflect actual codebase state. Added proper error handling, validation, verification requirements. |
