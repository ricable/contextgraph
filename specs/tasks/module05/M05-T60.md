# M05-T60: Implement Tool Gating Warning System

## Task Metadata
- **ID**: M05-T60
- **Title**: Implement Tool Gating Warning System
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: high
- **Estimated Hours**: 2
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement tool gating warnings when entropy exceeds threshold per PRD Section 3.1.

Per PRD:
- "`tool_gating_warning`: When entropy > 0.8 (suggests refining query first)"
- This prevents agents from making poor decisions when the system is in high-uncertainty state

The warning should be included in inject_context and other retrieval tool responses when:
1. Current entropy > 0.8
2. Coherence < 0.3
3. Johari quadrant is Blind or Unknown

## File Paths

### Implementation
- `crates/context-graph-utl/src/gating/warning.rs`
- `crates/context-graph-utl/src/gating/mod.rs`

### Tests
- `crates/context-graph-utl/tests/tool_gating_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T22 | Implement UtlProcessor | pending |
| M05-T18 | Implement JohariClassifier | pending |

## Acceptance Criteria

- [ ] ToolGatingWarning struct defined
- [ ] Entropy threshold configurable (default: 0.8)
- [ ] Warning includes suggested refinement actions
- [ ] Integration point for inject_context response
- [ ] Multiple warning levels (caution, warning, critical)

## Specification References

- `contextgraphprd.md` Section 3.1 Context Injection
- `contextgraphprd.md` Section 3.2 Cognitive Pulse

## Implementation Notes

### Tool Gating Warning Structure

```rust
use serde::{Serialize, Deserialize};

/// Warning levels for tool gating
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum GatingLevel {
    /// No warning - proceed normally
    None,

    /// Caution - results may be suboptimal
    /// entropy > 0.6 or coherence < 0.5
    Caution,

    /// Warning - consider refining query
    /// entropy > 0.8 or coherence < 0.3
    Warning,

    /// Critical - strongly recommend refinement
    /// entropy > 0.9 or coherence < 0.2
    Critical,
}

/// Tool gating warning included in retrieval responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolGatingWarning {
    /// Warning level
    pub level: GatingLevel,

    /// Human-readable warning message
    pub message: String,

    /// Current entropy value that triggered warning
    pub entropy: f32,

    /// Current coherence value
    pub coherence: f32,

    /// Current Johari quadrant
    pub johari_quadrant: JohariQuadrant,

    /// Suggested actions to reduce uncertainty
    pub suggested_actions: Vec<GatingSuggestion>,

    /// Whether tool should be gated (blocked)
    pub should_gate: bool,
}

/// Suggested action to reduce uncertainty
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GatingSuggestion {
    /// Action type
    pub action: GatingAction,

    /// Human-readable description
    pub description: String,

    /// Expected entropy reduction if action taken
    pub expected_reduction: f32,

    /// Priority (1 = highest)
    pub priority: u8,
}

/// Types of gating actions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GatingAction {
    /// Refine the query with more specific terms
    RefineQuery { suggestions: Vec<String> },

    /// Add context to reduce ambiguity
    AddContext { needed_context: Vec<String> },

    /// Trigger dream consolidation
    TriggerDream,

    /// Ask user for clarification
    AskClarification { questions: Vec<String> },

    /// Narrow search scope
    NarrowScope { suggested_filters: Vec<String> },

    /// Get neighborhood context first
    GetNeighborhood { suggested_node_ids: Vec<String> },
}
```

### Gating Evaluator

```rust
/// Configuration for tool gating evaluation
#[derive(Debug, Clone)]
pub struct ToolGatingConfig {
    /// Entropy threshold for warning level
    pub warning_entropy_threshold: f32,  // Default: 0.8

    /// Entropy threshold for critical level
    pub critical_entropy_threshold: f32,  // Default: 0.9

    /// Coherence threshold for warning level
    pub warning_coherence_threshold: f32,  // Default: 0.3

    /// Coherence threshold for critical level
    pub critical_coherence_threshold: f32,  // Default: 0.2

    /// Whether to actually gate (block) tools at critical level
    pub enable_hard_gating: bool,  // Default: false

    /// Johari quadrants that trigger gating
    pub gated_quadrants: Vec<JohariQuadrant>,
}

impl Default for ToolGatingConfig {
    fn default() -> Self {
        Self {
            warning_entropy_threshold: 0.8,
            critical_entropy_threshold: 0.9,
            warning_coherence_threshold: 0.3,
            critical_coherence_threshold: 0.2,
            enable_hard_gating: false,
            gated_quadrants: vec![JohariQuadrant::Blind, JohariQuadrant::Unknown],
        }
    }
}

/// Evaluates whether tool gating warning should be issued
pub struct ToolGatingEvaluator {
    config: ToolGatingConfig,
}

impl ToolGatingEvaluator {
    pub fn new(config: ToolGatingConfig) -> Self {
        Self { config }
    }

    /// Evaluate gating based on current UTL state
    pub fn evaluate(&self, signal: &LearningSignal) -> Option<ToolGatingWarning> {
        let level = self.determine_level(signal);

        if level == GatingLevel::None {
            return None;
        }

        let message = self.generate_message(level, signal);
        let suggested_actions = self.generate_suggestions(level, signal);
        let should_gate = self.config.enable_hard_gating && level == GatingLevel::Critical;

        Some(ToolGatingWarning {
            level,
            message,
            entropy: signal.surprise,
            coherence: signal.coherence,
            johari_quadrant: signal.johari_quadrant,
            suggested_actions,
            should_gate,
        })
    }

    /// Determine gating level from UTL signal
    fn determine_level(&self, signal: &LearningSignal) -> GatingLevel {
        // Check critical thresholds first
        if signal.surprise >= self.config.critical_entropy_threshold
            || signal.coherence <= self.config.critical_coherence_threshold {
            return GatingLevel::Critical;
        }

        // Check warning thresholds
        if signal.surprise >= self.config.warning_entropy_threshold
            || signal.coherence <= self.config.warning_coherence_threshold {
            return GatingLevel::Warning;
        }

        // Check Johari quadrant
        if self.config.gated_quadrants.contains(&signal.johari_quadrant) {
            return GatingLevel::Caution;
        }

        // Check for elevated uncertainty
        if signal.surprise > 0.6 || signal.coherence < 0.5 {
            return GatingLevel::Caution;
        }

        GatingLevel::None
    }

    /// Generate human-readable message
    fn generate_message(&self, level: GatingLevel, signal: &LearningSignal) -> String {
        match level {
            GatingLevel::Critical => format!(
                "Critical uncertainty: entropy={:.2}, coherence={:.2}. \
                 Strongly recommend refining query before proceeding.",
                signal.surprise, signal.coherence
            ),
            GatingLevel::Warning => format!(
                "High uncertainty detected: entropy={:.2}, coherence={:.2}. \
                 Consider refining query for better results.",
                signal.surprise, signal.coherence
            ),
            GatingLevel::Caution => format!(
                "Elevated uncertainty in {:?} quadrant. \
                 Results may be suboptimal.",
                signal.johari_quadrant
            ),
            GatingLevel::None => String::new(),
        }
    }

    /// Generate actionable suggestions
    fn generate_suggestions(
        &self,
        level: GatingLevel,
        signal: &LearningSignal,
    ) -> Vec<GatingSuggestion> {
        let mut suggestions = Vec::new();

        // High entropy suggests query refinement
        if signal.surprise >= self.config.warning_entropy_threshold {
            suggestions.push(GatingSuggestion {
                action: GatingAction::RefineQuery {
                    suggestions: vec![
                        "Add specific keywords".to_string(),
                        "Narrow topic scope".to_string(),
                        "Specify time range".to_string(),
                    ],
                },
                description: "Refine query to reduce ambiguity".to_string(),
                expected_reduction: 0.2,
                priority: 1,
            });
        }

        // Low coherence suggests context needed
        if signal.coherence <= self.config.warning_coherence_threshold {
            suggestions.push(GatingSuggestion {
                action: GatingAction::GetNeighborhood {
                    suggested_node_ids: Vec::new(),  // Filled by caller
                },
                description: "Get neighborhood context first".to_string(),
                expected_reduction: 0.15,
                priority: 2,
            });
        }

        // Blind quadrant suggests asking for clarification
        if signal.johari_quadrant == JohariQuadrant::Blind {
            suggestions.push(GatingSuggestion {
                action: GatingAction::AskClarification {
                    questions: vec![
                        "What specific aspect are you interested in?".to_string(),
                        "Can you provide more context?".to_string(),
                    ],
                },
                description: "Ask user for clarification".to_string(),
                expected_reduction: 0.25,
                priority: 1,
            });
        }

        // Unknown quadrant suggests dream consolidation
        if signal.johari_quadrant == JohariQuadrant::Unknown && level >= GatingLevel::Warning {
            suggestions.push(GatingSuggestion {
                action: GatingAction::TriggerDream,
                description: "Trigger dream consolidation to improve coherence".to_string(),
                expected_reduction: 0.3,
                priority: 3,
            });
        }

        // Sort by priority
        suggestions.sort_by_key(|s| s.priority);

        suggestions
    }
}
```

### Integration with inject_context

```rust
/// Response extension for inject_context with gating warning
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectContextResponse {
    /// Retrieved and distilled context
    pub context: String,

    /// UTL metrics for this retrieval
    pub utl_metrics: UtlMetrics,

    /// Conflict detection result
    pub conflict_alert: Option<ConflictAlert>,

    /// Tool gating warning (if applicable)
    /// Per PRD: "tool_gating_warning: When entropy > 0.8"
    pub tool_gating_warning: Option<ToolGatingWarning>,

    /// Cognitive pulse header
    pub pulse: CognitivePulse,
}

impl UtlProcessor {
    /// Evaluate gating for retrieval operation
    pub fn evaluate_retrieval_gating(
        &self,
        signal: &LearningSignal,
    ) -> Option<ToolGatingWarning> {
        let evaluator = ToolGatingEvaluator::new(self.config.gating_config.clone());
        evaluator.evaluate(signal)
    }
}
```

## Testing Requirements

1. **Level Determination Tests**
   - entropy >= 0.9 -> Critical
   - entropy >= 0.8 -> Warning
   - coherence <= 0.2 -> Critical
   - coherence <= 0.3 -> Warning
   - Blind/Unknown quadrant -> Caution
   - Normal state -> None

2. **Suggestion Tests**
   - High entropy generates RefineQuery suggestion
   - Low coherence generates GetNeighborhood suggestion
   - Blind quadrant generates AskClarification suggestion
   - Unknown + Warning generates TriggerDream suggestion

3. **Integration Tests**
   - Warning included in inject_context response
   - Hard gating blocks tool when configured
   - Warning serializes correctly to JSON

4. **Configuration Tests**
   - Custom thresholds work correctly
   - enable_hard_gating flag respected
   - gated_quadrants configurable

---

*Task specification generated for Module 05 - UTL Integration*
